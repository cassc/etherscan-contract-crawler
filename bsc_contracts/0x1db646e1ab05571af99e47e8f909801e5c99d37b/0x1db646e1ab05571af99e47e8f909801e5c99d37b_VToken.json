{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OwnableUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\\n    function __Ownable2Step_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\\n    }\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\n\\nimport \\\"./IAccessControlManagerV8.sol\\\";\\n\\n/**\\n * @title Venus Access Control Contract.\\n * @dev The AccessControlledV8 contract is a wrapper around the OpenZeppelin AccessControl contract\\n *      It provides a standardized way to control access to methods within the Venus Smart Contract Ecosystem.\\n *      The contract allows the owner to set an AccessControlManager contract address.\\n *      It can restrict method calls based on the sender's role and the method's signature.\\n */\\n\\nabstract contract AccessControlledV8 is Initializable, Ownable2StepUpgradeable {\\n    /// @notice Access control manager contract\\n    IAccessControlManagerV8 private _accessControlManager;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n\\n    /// @notice Emitted when access control manager contract address is changed\\n    event NewAccessControlManager(address oldAccessControlManager, address newAccessControlManager);\\n\\n    /// @notice Thrown when the action is prohibited by AccessControlManager\\n    error Unauthorized(address sender, address calledContract, string methodSignature);\\n\\n    function __AccessControlled_init(address accessControlManager_) internal onlyInitializing {\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager_);\\n    }\\n\\n    function __AccessControlled_init_unchained(address accessControlManager_) internal onlyInitializing {\\n        _setAccessControlManager(accessControlManager_);\\n    }\\n\\n    /**\\n     * @notice Sets the address of AccessControlManager\\n     * @dev Admin function to set address of AccessControlManager\\n     * @param accessControlManager_ The new address of the AccessControlManager\\n     * @custom:event Emits NewAccessControlManager event\\n     * @custom:access Only Governance\\n     */\\n    function setAccessControlManager(address accessControlManager_) external onlyOwner {\\n        _setAccessControlManager(accessControlManager_);\\n    }\\n\\n    /**\\n     * @notice Returns the address of the access control manager contract\\n     */\\n    function accessControlManager() external view returns (IAccessControlManagerV8) {\\n        return _accessControlManager;\\n    }\\n\\n    /**\\n     * @dev Internal function to set address of AccessControlManager\\n     * @param accessControlManager_ The new address of the AccessControlManager\\n     */\\n    function _setAccessControlManager(address accessControlManager_) internal {\\n        require(address(accessControlManager_) != address(0), \\\"invalid acess control manager address\\\");\\n        address oldAccessControlManager = address(_accessControlManager);\\n        _accessControlManager = IAccessControlManagerV8(accessControlManager_);\\n        emit NewAccessControlManager(oldAccessControlManager, accessControlManager_);\\n    }\\n\\n    /**\\n     * @notice Reverts if the call is not allowed by AccessControlManager\\n     * @param signature Method signature\\n     */\\n    function _checkAccessAllowed(string memory signature) internal view {\\n        bool isAllowedToCall = _accessControlManager.isAllowedToCall(msg.sender, signature);\\n\\n        if (!isAllowedToCall) {\\n            revert Unauthorized(msg.sender, address(this), signature);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\ninterface IAccessControlManagerV8 is IAccessControl {\\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\\n\\n    function revokeCallPermission(\\n        address contractAddress,\\n        string calldata functionSig,\\n        address accountToRevoke\\n    ) external;\\n\\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\\n\\n    function hasPermission(\\n        address account,\\n        address contractAddress,\\n        string calldata functionSig\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\ninterface OracleInterface {\\n    function getPrice(address asset) external view returns (uint256);\\n}\\n\\ninterface ResilientOracleInterface is OracleInterface {\\n    function updatePrice(address vToken) external;\\n\\n    function updateAssetPrice(address asset) external;\\n\\n    function getUnderlyingPrice(address vToken) external view returns (uint256);\\n}\\n\\ninterface TwapInterface is OracleInterface {\\n    function updateTwap(address asset) external returns (uint256);\\n}\\n\\ninterface BoundValidatorInterface {\\n    function validatePriceWithAnchorPrice(\\n        address asset,\\n        uint256 reporterPrice,\\n        uint256 anchorPrice\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@venusprotocol/protocol-reserve/contracts/Interfaces/IProtocolShareReserve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\ninterface IProtocolShareReserve {\\n    /// @notice it represents the type of vToken income\\n    enum IncomeType {\\n        SPREAD,\\n        LIQUIDATION\\n    }\\n\\n    function updateAssetsState(\\n        address comptroller,\\n        address asset,\\n        IncomeType incomeType\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Comptroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\nimport { AccessControlledV8 } from \\\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\\\";\\n\\nimport { ComptrollerInterface } from \\\"./ComptrollerInterface.sol\\\";\\nimport { ComptrollerStorage } from \\\"./ComptrollerStorage.sol\\\";\\nimport { ExponentialNoError } from \\\"./ExponentialNoError.sol\\\";\\nimport { VToken } from \\\"./VToken.sol\\\";\\nimport { RewardsDistributor } from \\\"./Rewards/RewardsDistributor.sol\\\";\\nimport { MaxLoopsLimitHelper } from \\\"./MaxLoopsLimitHelper.sol\\\";\\nimport { ensureNonzeroAddress } from \\\"./lib/validators.sol\\\";\\n\\n/**\\n * @title Comptroller\\n * @author Venus\\n * @notice The Comptroller is designed to provide checks for all minting, redeeming, transferring, borrowing, lending, repaying, liquidating,\\n * and seizing done by the `vToken` contract. Each pool has one `Comptroller` checking these interactions across markets. When a user interacts\\n * with a given market by one of these main actions, a call is made to a corresponding hook in the associated `Comptroller`, which either allows\\n * or reverts the transaction. These hooks also update supply and borrow rewards as they are called. The comptroller holds the logic for assessing\\n * liquidity snapshots of an account via the collateral factor and liquidation threshold. This check determines the collateral needed for a borrow,\\n * as well as how much of a borrow may be liquidated. A user may borrow a portion of their collateral with the maximum amount determined by the\\n * markets collateral factor. However, if their borrowed amount exceeds an amount calculated using the market\u2019s corresponding liquidation threshold,\\n * the borrow is eligible for liquidation.\\n *\\n * The `Comptroller` also includes two functions `liquidateAccount()` and `healAccount()`, which are meant to handle accounts that do not exceed\\n * the `minLiquidatableCollateral` for the `Comptroller`:\\n *\\n * - `healAccount()`: This function is called to seize all of a given user\u2019s collateral, requiring the `msg.sender` repay a certain percentage\\n * of the debt calculated by `collateral/(borrows*liquidationIncentive)`. The function can only be called if the calculated percentage does not exceed\\n * 100%, because otherwise no `badDebt` would be created and `liquidateAccount()` should be used instead. The difference in the actual amount of debt\\n * and debt paid off is recorded as `badDebt` for each market, which can then be auctioned off for the risk reserves of the associated pool.\\n * - `liquidateAccount()`: This function can only be called if the collateral seized will cover all borrows of an account, as well as the liquidation\\n * incentive. Otherwise, the pool will incur bad debt, in which case the function `healAccount()` should be used instead. This function skips the logic\\n * verifying that the repay amount does not exceed the close factor.\\n */\\ncontract Comptroller is\\n    Ownable2StepUpgradeable,\\n    AccessControlledV8,\\n    ComptrollerStorage,\\n    ComptrollerInterface,\\n    ExponentialNoError,\\n    MaxLoopsLimitHelper\\n{\\n    // PoolRegistry, immutable to save on gas\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address public immutable poolRegistry;\\n\\n    /// @notice Emitted when an account enters a market\\n    event MarketEntered(VToken indexed vToken, address indexed account);\\n\\n    /// @notice Emitted when an account exits a market\\n    event MarketExited(VToken indexed vToken, address indexed account);\\n\\n    /// @notice Emitted when close factor is changed by admin\\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\\n\\n    /// @notice Emitted when a collateral factor is changed by admin\\n    event NewCollateralFactor(VToken vToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\\n\\n    /// @notice Emitted when liquidation threshold is changed by admin\\n    event NewLiquidationThreshold(\\n        VToken vToken,\\n        uint256 oldLiquidationThresholdMantissa,\\n        uint256 newLiquidationThresholdMantissa\\n    );\\n\\n    /// @notice Emitted when liquidation incentive is changed by admin\\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\\n\\n    /// @notice Emitted when price oracle is changed\\n    event NewPriceOracle(ResilientOracleInterface oldPriceOracle, ResilientOracleInterface newPriceOracle);\\n\\n    /// @notice Emitted when an action is paused on a market\\n    event ActionPausedMarket(VToken vToken, Action action, bool pauseState);\\n\\n    /// @notice Emitted when borrow cap for a vToken is changed\\n    event NewBorrowCap(VToken indexed vToken, uint256 newBorrowCap);\\n\\n    /// @notice Emitted when the collateral threshold (in USD) for non-batch liquidations is changed\\n    event NewMinLiquidatableCollateral(uint256 oldMinLiquidatableCollateral, uint256 newMinLiquidatableCollateral);\\n\\n    /// @notice Emitted when supply cap for a vToken is changed\\n    event NewSupplyCap(VToken indexed vToken, uint256 newSupplyCap);\\n\\n    /// @notice Emitted when a rewards distributor is added\\n    event NewRewardsDistributor(address indexed rewardsDistributor, address indexed rewardToken);\\n\\n    /// @notice Emitted when a market is supported\\n    event MarketSupported(VToken vToken);\\n\\n    /// @notice Emitted when forced liquidation is enabled or disabled for a market\\n    event IsForcedLiquidationEnabledUpdated(address indexed vToken, bool enable);\\n\\n    /// @notice Thrown when collateral factor exceeds the upper bound\\n    error InvalidCollateralFactor();\\n\\n    /// @notice Thrown when liquidation threshold exceeds the collateral factor\\n    error InvalidLiquidationThreshold();\\n\\n    /// @notice Thrown when the action is only available to specific sender, but the real sender was different\\n    error UnexpectedSender(address expectedSender, address actualSender);\\n\\n    /// @notice Thrown when the oracle returns an invalid price for some asset\\n    error PriceError(address vToken);\\n\\n    /// @notice Thrown if VToken unexpectedly returned a nonzero error code while trying to get account snapshot\\n    error SnapshotError(address vToken, address user);\\n\\n    /// @notice Thrown when the market is not listed\\n    error MarketNotListed(address market);\\n\\n    /// @notice Thrown when a market has an unexpected comptroller\\n    error ComptrollerMismatch();\\n\\n    /// @notice Thrown when user is not member of market\\n    error MarketNotCollateral(address vToken, address user);\\n\\n    /**\\n     * @notice Thrown during the liquidation if user's total collateral amount is lower than\\n     *   a predefined threshold. In this case only batch liquidations (either liquidateAccount\\n     *   or healAccount) are available.\\n     */\\n    error MinimalCollateralViolated(uint256 expectedGreaterThan, uint256 actual);\\n    error CollateralExceedsThreshold(uint256 expectedLessThanOrEqualTo, uint256 actual);\\n    error InsufficientCollateral(uint256 collateralToSeize, uint256 availableCollateral);\\n\\n    /// @notice Thrown when the account doesn't have enough liquidity to redeem or borrow\\n    error InsufficientLiquidity();\\n\\n    /// @notice Thrown when trying to liquidate a healthy account\\n    error InsufficientShortfall();\\n\\n    /// @notice Thrown when trying to repay more than allowed by close factor\\n    error TooMuchRepay();\\n\\n    /// @notice Thrown if the user is trying to exit a market in which they have an outstanding debt\\n    error NonzeroBorrowBalance();\\n\\n    /// @notice Thrown when trying to perform an action that is paused\\n    error ActionPaused(address market, Action action);\\n\\n    /// @notice Thrown when trying to add a market that is already listed\\n    error MarketAlreadyListed(address market);\\n\\n    /// @notice Thrown if the supply cap is exceeded\\n    error SupplyCapExceeded(address market, uint256 cap);\\n\\n    /// @notice Thrown if the borrow cap is exceeded\\n    error BorrowCapExceeded(address market, uint256 cap);\\n\\n    /// @param poolRegistry_ Pool registry address\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    /// @custom:error ZeroAddressNotAllowed is thrown when pool registry address is zero\\n    constructor(address poolRegistry_) {\\n        ensureNonzeroAddress(poolRegistry_);\\n\\n        poolRegistry = poolRegistry_;\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @param loopLimit Limit for the loops can iterate to avoid the DOS\\n     * @param accessControlManager Access control manager contract address\\n     */\\n    function initialize(uint256 loopLimit, address accessControlManager) external initializer {\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager);\\n\\n        _setMaxLoopsLimit(loopLimit);\\n    }\\n\\n    /**\\n     * @notice Add assets to be included in account liquidity calculation; enabling them to be used as collateral\\n     * @param vTokens The list of addresses of the vToken markets to be enabled\\n     * @return errors An array of NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event MarketEntered is emitted for each market on success\\n     * @custom:error ActionPaused error is thrown if entering any of the markets is paused\\n     * @custom:error MarketNotListed error is thrown if any of the markets is not listed\\n     * @custom:access Not restricted\\n     */\\n    function enterMarkets(address[] memory vTokens) external override returns (uint256[] memory) {\\n        uint256 len = vTokens.length;\\n\\n        uint256[] memory results = new uint256[](len);\\n        for (uint256 i; i < len; ++i) {\\n            VToken vToken = VToken(vTokens[i]);\\n\\n            _addToMarket(vToken, msg.sender);\\n            results[i] = NO_ERROR;\\n        }\\n\\n        return results;\\n    }\\n\\n    /**\\n     * @notice Removes asset from sender's account liquidity calculation; disabling them as collateral\\n     * @dev Sender must not have an outstanding borrow balance in the asset,\\n     *  or be providing necessary collateral for an outstanding borrow.\\n     * @param vTokenAddress The address of the asset to be removed\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event MarketExited is emitted on success\\n     * @custom:error ActionPaused error is thrown if exiting the market is paused\\n     * @custom:error NonzeroBorrowBalance error is thrown if the user has an outstanding borrow in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if exiting the market would lead to user's insolvency\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function exitMarket(address vTokenAddress) external override returns (uint256) {\\n        _checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);\\n        VToken vToken = VToken(vTokenAddress);\\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\\n        (uint256 tokensHeld, uint256 amountOwed, ) = _safeGetAccountSnapshot(vToken, msg.sender);\\n\\n        /* Fail if the sender has a borrow balance */\\n        if (amountOwed != 0) {\\n            revert NonzeroBorrowBalance();\\n        }\\n\\n        /* Fail if the sender is not permitted to redeem all of their tokens */\\n        _checkRedeemAllowed(vTokenAddress, msg.sender, tokensHeld);\\n\\n        Market storage marketToExit = markets[address(vToken)];\\n\\n        /* Return true if the sender is not already \u2018in\u2019 the market */\\n        if (!marketToExit.accountMembership[msg.sender]) {\\n            return NO_ERROR;\\n        }\\n\\n        /* Set vToken account membership to false */\\n        delete marketToExit.accountMembership[msg.sender];\\n\\n        /* Delete vToken from the account\u2019s list of assets */\\n        // load into memory for faster iteration\\n        VToken[] memory userAssetList = accountAssets[msg.sender];\\n        uint256 len = userAssetList.length;\\n\\n        uint256 assetIndex = len;\\n        for (uint256 i; i < len; ++i) {\\n            if (userAssetList[i] == vToken) {\\n                assetIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // We *must* have found the asset in the list or our redundant data structure is broken\\n        assert(assetIndex < len);\\n\\n        // copy last item in list to location of item to be removed, reduce length by 1\\n        VToken[] storage storedList = accountAssets[msg.sender];\\n        storedList[assetIndex] = storedList[storedList.length - 1];\\n        storedList.pop();\\n\\n        emit MarketExited(vToken, msg.sender);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /*** Policy Hooks ***/\\n\\n    /**\\n     * @notice Checks if the account should be allowed to mint tokens in the given market\\n     * @param vToken The market to verify the mint against\\n     * @param minter The account which would get the minted tokens\\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\\n     * @custom:error ActionPaused error is thrown if supplying to this market is paused\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error SupplyCapExceeded error is thrown if the total supply exceeds the cap after minting\\n     * @custom:access Not restricted\\n     */\\n    function preMintHook(address vToken, address minter, uint256 mintAmount) external override {\\n        _checkActionPauseState(vToken, Action.MINT);\\n\\n        if (!markets[vToken].isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        uint256 supplyCap = supplyCaps[vToken];\\n        // Skipping the cap check for uncapped coins to save some gas\\n        if (supplyCap != type(uint256).max) {\\n            uint256 vTokenSupply = VToken(vToken).totalSupply();\\n            Exp memory exchangeRate = Exp({ mantissa: VToken(vToken).exchangeRateStored() });\\n            uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(exchangeRate, vTokenSupply, mintAmount);\\n            if (nextTotalSupply > supplyCap) {\\n                revert SupplyCapExceeded(vToken, supplyCap);\\n            }\\n        }\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vToken);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, minter);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\\n     * @param vToken The market to verify the redeem against\\n     * @param redeemer The account which would redeem the tokens\\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\\n     * @custom:error ActionPaused error is thrown if withdrawals are paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if the withdrawal would lead to user's insolvency\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function preRedeemHook(address vToken, address redeemer, uint256 redeemTokens) external override {\\n        _checkActionPauseState(vToken, Action.REDEEM);\\n\\n        _checkRedeemAllowed(vToken, redeemer, redeemTokens);\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vToken);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, redeemer);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\\n     * @param vToken The market to verify the borrow against\\n     * @param borrower The account which would borrow the asset\\n     * @param borrowAmount The amount of underlying the account would borrow\\n     * @custom:error ActionPaused error is thrown if borrowing is paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if there is not enough collateral to borrow\\n     * @custom:error BorrowCapExceeded is thrown if the borrow cap will be exceeded should this borrow succeed\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted if vToken is enabled as collateral, otherwise only vToken\\n     */\\n    /// disable-eslint\\n    function preBorrowHook(address vToken, address borrower, uint256 borrowAmount) external override {\\n        _checkActionPauseState(vToken, Action.BORROW);\\n\\n        if (!markets[vToken].isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        if (!markets[vToken].accountMembership[borrower]) {\\n            // only vTokens may call borrowAllowed if borrower not in market\\n            _checkSenderIs(vToken);\\n\\n            // attempt to add borrower to the market or revert\\n            _addToMarket(VToken(msg.sender), borrower);\\n        }\\n\\n        // Update the prices of tokens\\n        updatePrices(borrower);\\n\\n        if (oracle.getUnderlyingPrice(vToken) == 0) {\\n            revert PriceError(address(vToken));\\n        }\\n\\n        uint256 borrowCap = borrowCaps[vToken];\\n        // Skipping the cap check for uncapped coins to save some gas\\n        if (borrowCap != type(uint256).max) {\\n            uint256 totalBorrows = VToken(vToken).totalBorrows();\\n            uint256 badDebt = VToken(vToken).badDebt();\\n            uint256 nextTotalBorrows = totalBorrows + borrowAmount + badDebt;\\n            if (nextTotalBorrows > borrowCap) {\\n                revert BorrowCapExceeded(vToken, borrowCap);\\n            }\\n        }\\n\\n        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(\\n            borrower,\\n            VToken(vToken),\\n            0,\\n            borrowAmount,\\n            _getCollateralFactor\\n        );\\n\\n        if (snapshot.shortfall > 0) {\\n            revert InsufficientLiquidity();\\n        }\\n\\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenBorrowIndex(vToken, borrowIndex);\\n            rewardsDistributor.distributeBorrowerRewardToken(vToken, borrower, borrowIndex);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\\n     * @param vToken The market to verify the repay against\\n     * @param borrower The account which would borrowed the asset\\n     * @custom:error ActionPaused error is thrown if repayments are paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:access Not restricted\\n     */\\n    function preRepayHook(address vToken, address borrower) external override {\\n        _checkActionPauseState(vToken, Action.REPAY);\\n\\n        oracle.updatePrice(vToken);\\n\\n        if (!markets[vToken].isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenBorrowIndex(vToken, borrowIndex);\\n            rewardsDistributor.distributeBorrowerRewardToken(vToken, borrower, borrowIndex);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the liquidation should be allowed to occur\\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\\n     * @param borrower The address of the borrower\\n     * @param repayAmount The amount of underlying being repaid\\n     * @param skipLiquidityCheck Allows the borrow to be liquidated regardless of the account liquidity\\n     * @custom:error ActionPaused error is thrown if liquidations are paused in this market\\n     * @custom:error MarketNotListed error is thrown if either collateral or borrowed token is not listed\\n     * @custom:error TooMuchRepay error is thrown if the liquidator is trying to repay more than allowed by close factor\\n     * @custom:error MinimalCollateralViolated is thrown if the users' total collateral is lower than the threshold for non-batch liquidations\\n     * @custom:error InsufficientShortfall is thrown when trying to liquidate a healthy account\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     */\\n    function preLiquidateHook(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        address borrower,\\n        uint256 repayAmount,\\n        bool skipLiquidityCheck\\n    ) external override {\\n        // Pause Action.LIQUIDATE on BORROWED TOKEN to prevent liquidating it.\\n        // If we want to pause liquidating to vTokenCollateral, we should pause\\n        // Action.SEIZE on it\\n        _checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);\\n\\n        // Update the prices of tokens\\n        updatePrices(borrower);\\n\\n        if (!markets[vTokenBorrowed].isListed) {\\n            revert MarketNotListed(address(vTokenBorrowed));\\n        }\\n        if (!markets[vTokenCollateral].isListed) {\\n            revert MarketNotListed(address(vTokenCollateral));\\n        }\\n\\n        uint256 borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\\n\\n        /* Allow accounts to be liquidated if it is a forced liquidation */\\n        if (skipLiquidityCheck || isForcedLiquidationEnabled[vTokenBorrowed]) {\\n            if (repayAmount > borrowBalance) {\\n                revert TooMuchRepay();\\n            }\\n            return;\\n        }\\n\\n        /* The borrower must have shortfall and collateral > threshold in order to be liquidatable */\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);\\n\\n        if (snapshot.totalCollateral <= minLiquidatableCollateral) {\\n            /* The liquidator should use either liquidateAccount or healAccount */\\n            revert MinimalCollateralViolated(minLiquidatableCollateral, snapshot.totalCollateral);\\n        }\\n\\n        if (snapshot.shortfall == 0) {\\n            revert InsufficientShortfall();\\n        }\\n\\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\\n        uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\\n        if (repayAmount > maxClose) {\\n            revert TooMuchRepay();\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the seizing of assets should be allowed to occur\\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\\n     * @param seizerContract Contract that tries to seize the asset (either borrowed vToken or Comptroller)\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\n     * @param borrower The address of the borrower\\n     * @custom:error ActionPaused error is thrown if seizing this type of collateral is paused\\n     * @custom:error MarketNotListed error is thrown if either collateral or borrowed token is not listed\\n     * @custom:error ComptrollerMismatch error is when seizer contract or seized asset belong to different pools\\n     * @custom:access Not restricted\\n     */\\n    function preSeizeHook(\\n        address vTokenCollateral,\\n        address seizerContract,\\n        address liquidator,\\n        address borrower\\n    ) external override {\\n        // Pause Action.SEIZE on COLLATERAL to prevent seizing it.\\n        // If we want to pause liquidating vTokenBorrowed, we should pause\\n        // Action.LIQUIDATE on it\\n        _checkActionPauseState(vTokenCollateral, Action.SEIZE);\\n\\n        Market storage market = markets[vTokenCollateral];\\n\\n        if (!market.isListed) {\\n            revert MarketNotListed(vTokenCollateral);\\n        }\\n\\n        if (seizerContract == address(this)) {\\n            // If Comptroller is the seizer, just check if collateral's comptroller\\n            // is equal to the current address\\n            if (address(VToken(vTokenCollateral).comptroller()) != address(this)) {\\n                revert ComptrollerMismatch();\\n            }\\n        } else {\\n            // If the seizer is not the Comptroller, check that the seizer is a\\n            // listed market, and that the markets' comptrollers match\\n            if (!markets[seizerContract].isListed) {\\n                revert MarketNotListed(seizerContract);\\n            }\\n            if (VToken(vTokenCollateral).comptroller() != VToken(seizerContract).comptroller()) {\\n                revert ComptrollerMismatch();\\n            }\\n        }\\n\\n        if (!market.accountMembership[borrower]) {\\n            revert MarketNotCollateral(vTokenCollateral, borrower);\\n        }\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vTokenCollateral);\\n            rewardsDistributor.distributeSupplierRewardToken(vTokenCollateral, borrower);\\n            rewardsDistributor.distributeSupplierRewardToken(vTokenCollateral, liquidator);\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\\n     * @param vToken The market to verify the transfer against\\n     * @param src The account which sources the tokens\\n     * @param dst The account which receives the tokens\\n     * @param transferTokens The number of vTokens to transfer\\n     * @custom:error ActionPaused error is thrown if withdrawals are paused in this market\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InsufficientLiquidity error is thrown if the withdrawal would lead to user's insolvency\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function preTransferHook(address vToken, address src, address dst, uint256 transferTokens) external override {\\n        _checkActionPauseState(vToken, Action.TRANSFER);\\n\\n        // Currently the only consideration is whether or not\\n        //  the src is allowed to redeem this many tokens\\n        _checkRedeemAllowed(vToken, src, transferTokens);\\n\\n        // Keep the flywheel moving\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            rewardsDistributor.updateRewardTokenSupplyIndex(vToken);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, src);\\n            rewardsDistributor.distributeSupplierRewardToken(vToken, dst);\\n        }\\n    }\\n\\n    /*** Pool-level operations ***/\\n\\n    /**\\n     * @notice Seizes all the remaining collateral, makes msg.sender repay the existing\\n     *   borrows, and treats the rest of the debt as bad debt (for each market).\\n     *   The sender has to repay a certain percentage of the debt, computed as\\n     *   collateral / (borrows * liquidationIncentive).\\n     * @param user account to heal\\n     * @custom:error CollateralExceedsThreshold error is thrown when the collateral is too big for healing\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function healAccount(address user) external {\\n        VToken[] memory userAssets = accountAssets[user];\\n        uint256 userAssetsCount = userAssets.length;\\n\\n        address liquidator = msg.sender;\\n        {\\n            ResilientOracleInterface oracle_ = oracle;\\n            // We need all user's markets to be fresh for the computations to be correct\\n            for (uint256 i; i < userAssetsCount; ++i) {\\n                userAssets[i].accrueInterest();\\n                oracle_.updatePrice(address(userAssets[i]));\\n            }\\n        }\\n\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(user, _getLiquidationThreshold);\\n\\n        if (snapshot.totalCollateral > minLiquidatableCollateral) {\\n            revert CollateralExceedsThreshold(minLiquidatableCollateral, snapshot.totalCollateral);\\n        }\\n\\n        if (snapshot.shortfall == 0) {\\n            revert InsufficientShortfall();\\n        }\\n\\n        // percentage = collateral / (borrows * liquidation incentive)\\n        Exp memory collateral = Exp({ mantissa: snapshot.totalCollateral });\\n        Exp memory scaledBorrows = mul_(\\n            Exp({ mantissa: snapshot.borrows }),\\n            Exp({ mantissa: liquidationIncentiveMantissa })\\n        );\\n\\n        Exp memory percentage = div_(collateral, scaledBorrows);\\n        if (lessThanExp(Exp({ mantissa: MANTISSA_ONE }), percentage)) {\\n            revert CollateralExceedsThreshold(scaledBorrows.mantissa, collateral.mantissa);\\n        }\\n\\n        for (uint256 i; i < userAssetsCount; ++i) {\\n            VToken market = userAssets[i];\\n\\n            (uint256 tokens, uint256 borrowBalance, ) = _safeGetAccountSnapshot(market, user);\\n            uint256 repaymentAmount = mul_ScalarTruncate(percentage, borrowBalance);\\n\\n            // Seize the entire collateral\\n            if (tokens != 0) {\\n                market.seize(liquidator, user, tokens);\\n            }\\n            // Repay a certain percentage of the borrow, forgive the rest\\n            if (borrowBalance != 0) {\\n                market.healBorrow(liquidator, user, repaymentAmount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Liquidates all borrows of the borrower. Callable only if the collateral is less than\\n     *   a predefined threshold, and the account collateral can be seized to cover all borrows. If\\n     *   the collateral is higher than the threshold, use regular liquidations. If the collateral is\\n     *   below the threshold, and the account is insolvent, use healAccount.\\n     * @param borrower the borrower address\\n     * @param orders an array of liquidation orders\\n     * @custom:error CollateralExceedsThreshold error is thrown when the collateral is too big for a batch liquidation\\n     * @custom:error InsufficientCollateral error is thrown when there is not enough collateral to cover the debt\\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\n     * @custom:access Not restricted\\n     */\\n    function liquidateAccount(address borrower, LiquidationOrder[] calldata orders) external {\\n        // We will accrue interest and update the oracle prices later during the liquidation\\n\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);\\n\\n        if (snapshot.totalCollateral > minLiquidatableCollateral) {\\n            // You should use the regular vToken.liquidateBorrow(...) call\\n            revert CollateralExceedsThreshold(minLiquidatableCollateral, snapshot.totalCollateral);\\n        }\\n\\n        uint256 collateralToSeize = mul_ScalarTruncate(\\n            Exp({ mantissa: liquidationIncentiveMantissa }),\\n            snapshot.borrows\\n        );\\n        if (collateralToSeize >= snapshot.totalCollateral) {\\n            // There is not enough collateral to seize. Use healBorrow to repay some part of the borrow\\n            // and record bad debt.\\n            revert InsufficientCollateral(collateralToSeize, snapshot.totalCollateral);\\n        }\\n\\n        if (snapshot.shortfall == 0) {\\n            revert InsufficientShortfall();\\n        }\\n\\n        uint256 ordersCount = orders.length;\\n\\n        _ensureMaxLoops(ordersCount / 2);\\n\\n        for (uint256 i; i < ordersCount; ++i) {\\n            if (!markets[address(orders[i].vTokenBorrowed)].isListed) {\\n                revert MarketNotListed(address(orders[i].vTokenBorrowed));\\n            }\\n            if (!markets[address(orders[i].vTokenCollateral)].isListed) {\\n                revert MarketNotListed(address(orders[i].vTokenCollateral));\\n            }\\n\\n            LiquidationOrder calldata order = orders[i];\\n            order.vTokenBorrowed.forceLiquidateBorrow(\\n                msg.sender,\\n                borrower,\\n                order.repayAmount,\\n                order.vTokenCollateral,\\n                true\\n            );\\n        }\\n\\n        VToken[] memory borrowMarkets = accountAssets[borrower];\\n        uint256 marketsCount = borrowMarkets.length;\\n\\n        for (uint256 i; i < marketsCount; ++i) {\\n            (, uint256 borrowBalance, ) = _safeGetAccountSnapshot(borrowMarkets[i], borrower);\\n            require(borrowBalance == 0, \\\"Nonzero borrow balance after liquidation\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the closeFactor to use when liquidating borrows\\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\\n     * @custom:event Emits NewCloseFactor on success\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setCloseFactor(uint256 newCloseFactorMantissa) external {\\n        _checkAccessAllowed(\\\"setCloseFactor(uint256)\\\");\\n        require(MAX_CLOSE_FACTOR_MANTISSA >= newCloseFactorMantissa, \\\"Close factor greater than maximum close factor\\\");\\n        require(MIN_CLOSE_FACTOR_MANTISSA <= newCloseFactorMantissa, \\\"Close factor smaller than minimum close factor\\\");\\n\\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\\n        closeFactorMantissa = newCloseFactorMantissa;\\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Sets the collateralFactor for a market\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param vToken The market to set the factor on\\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\\n     * @param newLiquidationThresholdMantissa The new liquidation threshold, scaled by 1e18\\n     * @custom:event Emits NewCollateralFactor when collateral factor is updated\\n     *    and NewLiquidationThreshold when liquidation threshold is updated\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\n     * @custom:error InvalidCollateralFactor error is thrown when collateral factor is too high\\n     * @custom:error InvalidLiquidationThreshold error is thrown when liquidation threshold is lower than collateral factor\\n     * @custom:error PriceError is thrown when the oracle returns an invalid price for the asset\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setCollateralFactor(\\n        VToken vToken,\\n        uint256 newCollateralFactorMantissa,\\n        uint256 newLiquidationThresholdMantissa\\n    ) external {\\n        _checkAccessAllowed(\\\"setCollateralFactor(address,uint256,uint256)\\\");\\n\\n        // Verify market is listed\\n        Market storage market = markets[address(vToken)];\\n        if (!market.isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        // Check collateral factor <= 0.9\\n        if (newCollateralFactorMantissa > MAX_COLLATERAL_FACTOR_MANTISSA) {\\n            revert InvalidCollateralFactor();\\n        }\\n\\n        // Ensure that liquidation threshold <= 1\\n        if (newLiquidationThresholdMantissa > MANTISSA_ONE) {\\n            revert InvalidLiquidationThreshold();\\n        }\\n\\n        // Ensure that liquidation threshold >= CF\\n        if (newLiquidationThresholdMantissa < newCollateralFactorMantissa) {\\n            revert InvalidLiquidationThreshold();\\n        }\\n\\n        // If collateral factor != 0, fail if price == 0\\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(address(vToken)) == 0) {\\n            revert PriceError(address(vToken));\\n        }\\n\\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\\n        if (newCollateralFactorMantissa != oldCollateralFactorMantissa) {\\n            market.collateralFactorMantissa = newCollateralFactorMantissa;\\n            emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\\n        }\\n\\n        uint256 oldLiquidationThresholdMantissa = market.liquidationThresholdMantissa;\\n        if (newLiquidationThresholdMantissa != oldLiquidationThresholdMantissa) {\\n            market.liquidationThresholdMantissa = newLiquidationThresholdMantissa;\\n            emit NewLiquidationThreshold(vToken, oldLiquidationThresholdMantissa, newLiquidationThresholdMantissa);\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets liquidationIncentive\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\\n     * @custom:event Emits NewLiquidationIncentive on success\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external {\\n        require(newLiquidationIncentiveMantissa >= MANTISSA_ONE, \\\"liquidation incentive should be greater than 1e18\\\");\\n\\n        _checkAccessAllowed(\\\"setLiquidationIncentive(uint256)\\\");\\n\\n        // Save current value for use in log\\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\\n\\n        // Set liquidation incentive to new incentive\\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\\n\\n        // Emit event with old incentive, new incentive\\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\\n    }\\n\\n    /**\\n     * @notice Add the market to the markets mapping and set it as listed\\n     * @dev Only callable by the PoolRegistry\\n     * @param vToken The address of the market (token) to list\\n     * @custom:error MarketAlreadyListed is thrown if the market is already listed in this pool\\n     * @custom:access Only PoolRegistry\\n     */\\n    function supportMarket(VToken vToken) external {\\n        _checkSenderIs(poolRegistry);\\n\\n        if (markets[address(vToken)].isListed) {\\n            revert MarketAlreadyListed(address(vToken));\\n        }\\n\\n        require(vToken.isVToken(), \\\"Comptroller: Invalid vToken\\\"); // Sanity check to make sure its really a VToken\\n\\n        Market storage newMarket = markets[address(vToken)];\\n        newMarket.isListed = true;\\n        newMarket.collateralFactorMantissa = 0;\\n        newMarket.liquidationThresholdMantissa = 0;\\n\\n        _addMarket(address(vToken));\\n\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\n\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\n            rewardsDistributors[i].initializeMarket(address(vToken));\\n        }\\n\\n        emit MarketSupported(vToken);\\n    }\\n\\n    /**\\n     * @notice Set the given borrow caps for the given vToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\\n     * @dev This function is restricted by the AccessControlManager\\n     * @dev A borrow cap of type(uint256).max corresponds to unlimited borrowing.\\n     * @dev Borrow caps smaller than the current total borrows are accepted. This way, new borrows will not be allowed\\n            until the total borrows amount goes below the new borrow cap\\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of type(uint256).max corresponds to unlimited borrowing.\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setMarketBorrowCaps(VToken[] calldata vTokens, uint256[] calldata newBorrowCaps) external {\\n        _checkAccessAllowed(\\\"setMarketBorrowCaps(address[],uint256[])\\\");\\n\\n        uint256 numMarkets = vTokens.length;\\n        uint256 numBorrowCaps = newBorrowCaps.length;\\n\\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \\\"invalid input\\\");\\n\\n        _ensureMaxLoops(numMarkets);\\n\\n        for (uint256 i; i < numMarkets; ++i) {\\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set the given supply caps for the given vToken markets. Supply that brings total Supply to or above supply cap will revert.\\n     * @dev This function is restricted by the AccessControlManager\\n     * @dev A supply cap of type(uint256).max corresponds to unlimited supply.\\n     * @dev Supply caps smaller than the current total supplies are accepted. This way, new supplies will not be allowed\\n            until the total supplies amount goes below the new supply cap\\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of type(uint256).max corresponds to unlimited supply.\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\\n        _checkAccessAllowed(\\\"setMarketSupplyCaps(address[],uint256[])\\\");\\n        uint256 vTokensCount = vTokens.length;\\n\\n        require(vTokensCount != 0, \\\"invalid number of markets\\\");\\n        require(vTokensCount == newSupplyCaps.length, \\\"invalid number of markets\\\");\\n\\n        _ensureMaxLoops(vTokensCount);\\n\\n        for (uint256 i; i < vTokensCount; ++i) {\\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Pause/unpause specified actions\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param marketsList Markets to pause/unpause the actions on\\n     * @param actionsList List of action ids to pause/unpause\\n     * @param paused The new paused state (true=paused, false=unpaused)\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setActionsPaused(VToken[] calldata marketsList, Action[] calldata actionsList, bool paused) external {\\n        _checkAccessAllowed(\\\"setActionsPaused(address[],uint256[],bool)\\\");\\n\\n        uint256 marketsCount = marketsList.length;\\n        uint256 actionsCount = actionsList.length;\\n\\n        _ensureMaxLoops(marketsCount * actionsCount);\\n\\n        for (uint256 marketIdx; marketIdx < marketsCount; ++marketIdx) {\\n            for (uint256 actionIdx; actionIdx < actionsCount; ++actionIdx) {\\n                _setActionPaused(address(marketsList[marketIdx]), actionsList[actionIdx], paused);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Set the given collateral threshold for non-batch liquidations. Regular liquidations\\n     *   will fail if the collateral amount is less than this threshold. Liquidators should use batch\\n     *   operations like liquidateAccount or healAccount.\\n     * @dev This function is restricted by the AccessControlManager\\n     * @param newMinLiquidatableCollateral The new min liquidatable collateral (in USD).\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setMinLiquidatableCollateral(uint256 newMinLiquidatableCollateral) external {\\n        _checkAccessAllowed(\\\"setMinLiquidatableCollateral(uint256)\\\");\\n\\n        uint256 oldMinLiquidatableCollateral = minLiquidatableCollateral;\\n        minLiquidatableCollateral = newMinLiquidatableCollateral;\\n        emit NewMinLiquidatableCollateral(oldMinLiquidatableCollateral, newMinLiquidatableCollateral);\\n    }\\n\\n    /**\\n     * @notice Add a new RewardsDistributor and initialize it with all markets. We can add several RewardsDistributor\\n     * contracts with the same rewardToken, and there could be overlaping among them considering the last reward block\\n     * @dev Only callable by the admin\\n     * @param _rewardsDistributor Address of the RewardDistributor contract to add\\n     * @custom:access Only Governance\\n     * @custom:event Emits NewRewardsDistributor with distributor address\\n     */\\n    function addRewardsDistributor(RewardsDistributor _rewardsDistributor) external onlyOwner {\\n        require(!rewardsDistributorExists[address(_rewardsDistributor)], \\\"already exists\\\");\\n\\n        uint256 rewardsDistributorsLen = rewardsDistributors.length;\\n        _ensureMaxLoops(rewardsDistributorsLen + 1);\\n\\n        rewardsDistributors.push(_rewardsDistributor);\\n        rewardsDistributorExists[address(_rewardsDistributor)] = true;\\n\\n        uint256 marketsCount = allMarkets.length;\\n\\n        for (uint256 i; i < marketsCount; ++i) {\\n            _rewardsDistributor.initializeMarket(address(allMarkets[i]));\\n        }\\n\\n        emit NewRewardsDistributor(address(_rewardsDistributor), address(_rewardsDistributor.rewardToken()));\\n    }\\n\\n    /**\\n     * @notice Sets a new price oracle for the Comptroller\\n     * @dev Only callable by the admin\\n     * @param newOracle Address of the new price oracle to set\\n     * @custom:event Emits NewPriceOracle on success\\n     * @custom:error ZeroAddressNotAllowed is thrown when the new oracle address is zero\\n     */\\n    function setPriceOracle(ResilientOracleInterface newOracle) external onlyOwner {\\n        ensureNonzeroAddress(address(newOracle));\\n\\n        ResilientOracleInterface oldOracle = oracle;\\n        oracle = newOracle;\\n        emit NewPriceOracle(oldOracle, newOracle);\\n    }\\n\\n    /**\\n     * @notice Set the for loop iteration limit to avoid DOS\\n     * @param limit Limit for the max loops can execute at a time\\n     */\\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\\n        _setMaxLoopsLimit(limit);\\n    }\\n\\n    /**\\n     * @notice Enables forced liquidations for a market. If forced liquidation is enabled,\\n     * borrows in the market may be liquidated regardless of the account liquidity\\n     * @param vTokenBorrowed Borrowed vToken\\n     * @param enable Whether to enable forced liquidations\\n     */\\n    function setForcedLiquidation(address vTokenBorrowed, bool enable) external {\\n        _checkAccessAllowed(\\\"setForcedLiquidation(address,bool)\\\");\\n        ensureNonzeroAddress(vTokenBorrowed);\\n\\n        if (!markets[vTokenBorrowed].isListed) {\\n            revert MarketNotListed(vTokenBorrowed);\\n        }\\n\\n        isForcedLiquidationEnabled[vTokenBorrowed] = enable;\\n        emit IsForcedLiquidationEnabledUpdated(vTokenBorrowed, enable);\\n    }\\n\\n    /**\\n     * @notice Determine the current account liquidity with respect to liquidation threshold requirements\\n     * @dev The interface of this function is intentionally kept compatible with Compound and Venus Core\\n     * @param account The account get liquidity for\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return liquidity Account liquidity in excess of liquidation threshold requirements,\\n     * @return shortfall Account shortfall below liquidation threshold requirements\\n     */\\n    function getAccountLiquidity(\\n        address account\\n    ) external view returns (uint256 error, uint256 liquidity, uint256 shortfall) {\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(account, _getLiquidationThreshold);\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\n    }\\n\\n    /**\\n     * @notice Determine the current account liquidity with respect to collateral requirements\\n     * @dev The interface of this function is intentionally kept compatible with Compound and Venus Core\\n     * @param account The account get liquidity for\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return liquidity Account liquidity in excess of collateral requirements,\\n     * @return shortfall Account shortfall below collateral requirements\\n     */\\n    function getBorrowingPower(\\n        address account\\n    ) external view returns (uint256 error, uint256 liquidity, uint256 shortfall) {\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(account, _getCollateralFactor);\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\n    }\\n\\n    /**\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\n     * @dev The interface of this function is intentionally kept compatible with Compound and Venus Core\\n     * @param vTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return liquidity Hypothetical account liquidity in excess of collateral requirements,\\n     * @return shortfall Hypothetical account shortfall below collateral requirements\\n     */\\n    function getHypotheticalAccountLiquidity(\\n        address account,\\n        address vTokenModify,\\n        uint256 redeemTokens,\\n        uint256 borrowAmount\\n    ) external view returns (uint256 error, uint256 liquidity, uint256 shortfall) {\\n        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(\\n            account,\\n            VToken(vTokenModify),\\n            redeemTokens,\\n            borrowAmount,\\n            _getCollateralFactor\\n        );\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\n    }\\n\\n    /**\\n     * @notice Return all of the markets\\n     * @dev The automatic getter may be used to access an individual market.\\n     * @return markets The list of market addresses\\n     */\\n    function getAllMarkets() external view override returns (VToken[] memory) {\\n        return allMarkets;\\n    }\\n\\n    /**\\n     * @notice Check if a market is marked as listed (active)\\n     * @param vToken vToken Address for the market to check\\n     * @return listed True if listed otherwise false\\n     */\\n    function isMarketListed(VToken vToken) external view returns (bool) {\\n        return markets[address(vToken)].isListed;\\n    }\\n\\n    /*** Assets You Are In ***/\\n\\n    /**\\n     * @notice Returns the assets an account has entered\\n     * @param account The address of the account to pull assets for\\n     * @return A list with the assets the account has entered\\n     */\\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\\n        VToken[] memory assetsIn = accountAssets[account];\\n\\n        return assetsIn;\\n    }\\n\\n    /**\\n     * @notice Returns whether the given account is entered in a given market\\n     * @param account The address of the account to check\\n     * @param vToken The vToken to check\\n     * @return True if the account is in the market specified, otherwise false.\\n     */\\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\\n        return markets[address(vToken)].accountMembership[account];\\n    }\\n\\n    /**\\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\\n     * @param vTokenBorrowed The address of the borrowed vToken\\n     * @param vTokenCollateral The address of the collateral vToken\\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return tokensToSeize Number of vTokenCollateral tokens to be seized in a liquidation\\n     * @custom:error PriceError if the oracle returns an invalid price\\n     */\\n    function liquidateCalculateSeizeTokens(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        uint256 actualRepayAmount\\n    ) external view override returns (uint256 error, uint256 tokensToSeize) {\\n        /* Read oracle prices for borrowed and collateral markets */\\n        uint256 priceBorrowedMantissa = _safeGetUnderlyingPrice(VToken(vTokenBorrowed));\\n        uint256 priceCollateralMantissa = _safeGetUnderlyingPrice(VToken(vTokenCollateral));\\n\\n        /*\\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\\n         *  seizeTokens = seizeAmount / exchangeRate\\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\\n         */\\n        uint256 exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\\n        uint256 seizeTokens;\\n        Exp memory numerator;\\n        Exp memory denominator;\\n        Exp memory ratio;\\n\\n        numerator = mul_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: priceBorrowedMantissa }));\\n        denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\\n        ratio = div_(numerator, denominator);\\n\\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\\n\\n        return (NO_ERROR, seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Returns reward speed given a vToken\\n     * @param vToken The vToken to get the reward speeds for\\n     * @return rewardSpeeds Array of total supply and borrow speeds and reward token for all reward distributors\\n     */\\n    function getRewardsByMarket(address vToken) external view returns (RewardSpeeds[] memory rewardSpeeds) {\\n        uint256 rewardsDistributorsLength = rewardsDistributors.length;\\n        rewardSpeeds = new RewardSpeeds[](rewardsDistributorsLength);\\n        for (uint256 i; i < rewardsDistributorsLength; ++i) {\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\n            address rewardToken = address(rewardsDistributor.rewardToken());\\n            rewardSpeeds[i] = RewardSpeeds({\\n                rewardToken: rewardToken,\\n                supplySpeed: rewardsDistributor.rewardTokenSupplySpeeds(vToken),\\n                borrowSpeed: rewardsDistributor.rewardTokenBorrowSpeeds(vToken)\\n            });\\n        }\\n        return rewardSpeeds;\\n    }\\n\\n    /**\\n     * @notice Return all reward distributors for this pool\\n     * @return Array of RewardDistributor addresses\\n     */\\n    function getRewardDistributors() external view returns (RewardsDistributor[] memory) {\\n        return rewardsDistributors;\\n    }\\n\\n    /**\\n     * @notice A marker method that returns true for a valid Comptroller contract\\n     * @return Always true\\n     */\\n    function isComptroller() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Update the prices of all the tokens associated with the provided account\\n     * @param account Address of the account to get associated tokens with\\n     */\\n    function updatePrices(address account) public {\\n        VToken[] memory vTokens = accountAssets[account];\\n        uint256 vTokensCount = vTokens.length;\\n\\n        ResilientOracleInterface oracle_ = oracle;\\n\\n        for (uint256 i; i < vTokensCount; ++i) {\\n            oracle_.updatePrice(address(vTokens[i]));\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a certain action is paused on a market\\n     * @param market vToken address\\n     * @param action Action to check\\n     * @return paused True if the action is paused otherwise false\\n     */\\n    function actionPaused(address market, Action action) public view returns (bool) {\\n        return _actionPaused[market][action];\\n    }\\n\\n    /**\\n     * @notice Add the market to the borrower's \\\"assets in\\\" for liquidity calculations\\n     * @param vToken The market to enter\\n     * @param borrower The address of the account to modify\\n     */\\n    function _addToMarket(VToken vToken, address borrower) internal {\\n        _checkActionPauseState(address(vToken), Action.ENTER_MARKET);\\n        Market storage marketToJoin = markets[address(vToken)];\\n\\n        if (!marketToJoin.isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        if (marketToJoin.accountMembership[borrower]) {\\n            // already joined\\n            return;\\n        }\\n\\n        // survived the gauntlet, add to list\\n        // NOTE: we store these somewhat redundantly as a significant optimization\\n        //  this avoids having to iterate through the list for the most common use cases\\n        //  that is, only when we need to perform liquidity checks\\n        //  and not whenever we want to check if an account is in a particular market\\n        marketToJoin.accountMembership[borrower] = true;\\n        accountAssets[borrower].push(vToken);\\n\\n        emit MarketEntered(vToken, borrower);\\n    }\\n\\n    /**\\n     * @notice Internal function to validate that a market hasn't already been added\\n     * and if it hasn't adds it\\n     * @param vToken The market to support\\n     */\\n    function _addMarket(address vToken) internal {\\n        uint256 marketsCount = allMarkets.length;\\n\\n        for (uint256 i; i < marketsCount; ++i) {\\n            if (allMarkets[i] == VToken(vToken)) {\\n                revert MarketAlreadyListed(vToken);\\n            }\\n        }\\n        allMarkets.push(VToken(vToken));\\n        marketsCount = allMarkets.length;\\n        _ensureMaxLoops(marketsCount);\\n    }\\n\\n    /**\\n     * @dev Pause/unpause an action on a market\\n     * @param market Market to pause/unpause the action on\\n     * @param action Action id to pause/unpause\\n     * @param paused The new paused state (true=paused, false=unpaused)\\n     */\\n    function _setActionPaused(address market, Action action, bool paused) internal {\\n        require(markets[market].isListed, \\\"cannot pause a market that is not listed\\\");\\n        _actionPaused[market][action] = paused;\\n        emit ActionPausedMarket(VToken(market), action, paused);\\n    }\\n\\n    /**\\n     * @dev Internal function to check that vTokens can be safely redeemed for the underlying asset.\\n     * @param vToken Address of the vTokens to redeem\\n     * @param redeemer Account redeeming the tokens\\n     * @param redeemTokens The number of tokens to redeem\\n     */\\n    function _checkRedeemAllowed(address vToken, address redeemer, uint256 redeemTokens) internal {\\n        Market storage market = markets[vToken];\\n\\n        if (!market.isListed) {\\n            revert MarketNotListed(address(vToken));\\n        }\\n\\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\\n        if (!market.accountMembership[redeemer]) {\\n            return;\\n        }\\n\\n        // Update the prices of tokens\\n        updatePrices(redeemer);\\n\\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\\n        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(\\n            redeemer,\\n            VToken(vToken),\\n            redeemTokens,\\n            0,\\n            _getCollateralFactor\\n        );\\n        if (snapshot.shortfall > 0) {\\n            revert InsufficientLiquidity();\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the total collateral, weighted collateral, borrow balance, liquidity, shortfall\\n     * @param account The account to get the snapshot for\\n     * @param weight The function to compute the weight of the collateral \u2013\u00a0either collateral factor or\\n     *  liquidation threshold. Accepts the address of the vToken and returns the weight as Exp.\\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\\n     *  without calculating accumulated interest.\\n     * @return snapshot Account liquidity snapshot\\n     */\\n    function _getCurrentLiquiditySnapshot(\\n        address account,\\n        function(VToken) internal view returns (Exp memory) weight\\n    ) internal view returns (AccountLiquiditySnapshot memory snapshot) {\\n        return _getHypotheticalLiquiditySnapshot(account, VToken(address(0)), 0, 0, weight);\\n    }\\n\\n    /**\\n     * @notice Determine what the supply/borrow balances would be if the given amounts were redeemed/borrowed\\n     * @param vTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @param weight The function to compute the weight of the collateral \u2013\u00a0either collateral factor or\\n         liquidation threshold. Accepts the address of the VToken and returns the weight\\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\\n     *  without calculating accumulated interest.\\n     * @return snapshot Account liquidity snapshot\\n     */\\n    function _getHypotheticalLiquiditySnapshot(\\n        address account,\\n        VToken vTokenModify,\\n        uint256 redeemTokens,\\n        uint256 borrowAmount,\\n        function(VToken) internal view returns (Exp memory) weight\\n    ) internal view returns (AccountLiquiditySnapshot memory snapshot) {\\n        // For each asset the account is in\\n        VToken[] memory assets = accountAssets[account];\\n        uint256 assetsCount = assets.length;\\n\\n        for (uint256 i; i < assetsCount; ++i) {\\n            VToken asset = assets[i];\\n\\n            // Read the balances and exchange rate from the vToken\\n            (uint256 vTokenBalance, uint256 borrowBalance, uint256 exchangeRateMantissa) = _safeGetAccountSnapshot(\\n                asset,\\n                account\\n            );\\n\\n            // Get the normalized price of the asset\\n            Exp memory oraclePrice = Exp({ mantissa: _safeGetUnderlyingPrice(asset) });\\n\\n            // Pre-compute conversion factors from vTokens -> usd\\n            Exp memory vTokenPrice = mul_(Exp({ mantissa: exchangeRateMantissa }), oraclePrice);\\n            Exp memory weightedVTokenPrice = mul_(weight(asset), vTokenPrice);\\n\\n            // weightedCollateral += weightedVTokenPrice * vTokenBalance\\n            snapshot.weightedCollateral = mul_ScalarTruncateAddUInt(\\n                weightedVTokenPrice,\\n                vTokenBalance,\\n                snapshot.weightedCollateral\\n            );\\n\\n            // totalCollateral += vTokenPrice * vTokenBalance\\n            snapshot.totalCollateral = mul_ScalarTruncateAddUInt(vTokenPrice, vTokenBalance, snapshot.totalCollateral);\\n\\n            // borrows += oraclePrice * borrowBalance\\n            snapshot.borrows = mul_ScalarTruncateAddUInt(oraclePrice, borrowBalance, snapshot.borrows);\\n\\n            // Calculate effects of interacting with vTokenModify\\n            if (asset == vTokenModify) {\\n                // redeem effect\\n                // effects += tokensToDenom * redeemTokens\\n                snapshot.effects = mul_ScalarTruncateAddUInt(weightedVTokenPrice, redeemTokens, snapshot.effects);\\n\\n                // borrow effect\\n                // effects += oraclePrice * borrowAmount\\n                snapshot.effects = mul_ScalarTruncateAddUInt(oraclePrice, borrowAmount, snapshot.effects);\\n            }\\n        }\\n\\n        uint256 borrowPlusEffects = snapshot.borrows + snapshot.effects;\\n        // These are safe, as the underflow condition is checked first\\n        unchecked {\\n            if (snapshot.weightedCollateral > borrowPlusEffects) {\\n                snapshot.liquidity = snapshot.weightedCollateral - borrowPlusEffects;\\n                snapshot.shortfall = 0;\\n            } else {\\n                snapshot.liquidity = 0;\\n                snapshot.shortfall = borrowPlusEffects - snapshot.weightedCollateral;\\n            }\\n        }\\n\\n        return snapshot;\\n    }\\n\\n    /**\\n     * @dev Retrieves price from oracle for an asset and checks it is nonzero\\n     * @param asset Address for asset to query price\\n     * @return Underlying price\\n     */\\n    function _safeGetUnderlyingPrice(VToken asset) internal view returns (uint256) {\\n        uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(address(asset));\\n        if (oraclePriceMantissa == 0) {\\n            revert PriceError(address(asset));\\n        }\\n        return oraclePriceMantissa;\\n    }\\n\\n    /**\\n     * @dev Return collateral factor for a market\\n     * @param asset Address for asset\\n     * @return Collateral factor as exponential\\n     */\\n    function _getCollateralFactor(VToken asset) internal view returns (Exp memory) {\\n        return Exp({ mantissa: markets[address(asset)].collateralFactorMantissa });\\n    }\\n\\n    /**\\n     * @dev Retrieves liquidation threshold for a market as an exponential\\n     * @param asset Address for asset to liquidation threshold\\n     * @return Liquidation threshold as exponential\\n     */\\n    function _getLiquidationThreshold(VToken asset) internal view returns (Exp memory) {\\n        return Exp({ mantissa: markets[address(asset)].liquidationThresholdMantissa });\\n    }\\n\\n    /**\\n     * @dev Returns supply and borrow balances of user in vToken, reverts on failure\\n     * @param vToken Market to query\\n     * @param user Account address\\n     * @return vTokenBalance Balance of vTokens, the same as vToken.balanceOf(user)\\n     * @return borrowBalance Borrowed amount, including the interest\\n     * @return exchangeRateMantissa Stored exchange rate\\n     */\\n    function _safeGetAccountSnapshot(\\n        VToken vToken,\\n        address user\\n    ) internal view returns (uint256 vTokenBalance, uint256 borrowBalance, uint256 exchangeRateMantissa) {\\n        uint256 err;\\n        (err, vTokenBalance, borrowBalance, exchangeRateMantissa) = vToken.getAccountSnapshot(user);\\n        if (err != 0) {\\n            revert SnapshotError(address(vToken), user);\\n        }\\n        return (vTokenBalance, borrowBalance, exchangeRateMantissa);\\n    }\\n\\n    /// @notice Reverts if the call is not from expectedSender\\n    /// @param expectedSender Expected transaction sender\\n    function _checkSenderIs(address expectedSender) internal view {\\n        if (msg.sender != expectedSender) {\\n            revert UnexpectedSender(expectedSender, msg.sender);\\n        }\\n    }\\n\\n    /// @notice Reverts if a certain action is paused on a market\\n    /// @param market Market to check\\n    /// @param action Action to check\\n    function _checkActionPauseState(address market, Action action) private view {\\n        if (actionPaused(market, action)) {\\n            revert ActionPaused(market, action);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ComptrollerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\n\\nimport { VToken } from \\\"./VToken.sol\\\";\\nimport { RewardsDistributor } from \\\"./Rewards/RewardsDistributor.sol\\\";\\n\\n/**\\n * @title ComptrollerInterface\\n * @author Venus\\n * @notice Interface implemented by the `Comptroller` contract.\\n */\\ninterface ComptrollerInterface {\\n    /*** Assets You Are In ***/\\n\\n    function enterMarkets(address[] calldata vTokens) external returns (uint256[] memory);\\n\\n    function exitMarket(address vToken) external returns (uint256);\\n\\n    /*** Policy Hooks ***/\\n\\n    function preMintHook(address vToken, address minter, uint256 mintAmount) external;\\n\\n    function preRedeemHook(address vToken, address redeemer, uint256 redeemTokens) external;\\n\\n    function preBorrowHook(address vToken, address borrower, uint256 borrowAmount) external;\\n\\n    function preRepayHook(address vToken, address borrower) external;\\n\\n    function preLiquidateHook(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        address borrower,\\n        uint256 repayAmount,\\n        bool skipLiquidityCheck\\n    ) external;\\n\\n    function preSeizeHook(\\n        address vTokenCollateral,\\n        address vTokenBorrowed,\\n        address liquidator,\\n        address borrower\\n    ) external;\\n\\n    function preTransferHook(address vToken, address src, address dst, uint256 transferTokens) external;\\n\\n    function isComptroller() external view returns (bool);\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    function liquidateCalculateSeizeTokens(\\n        address vTokenBorrowed,\\n        address vTokenCollateral,\\n        uint256 repayAmount\\n    ) external view returns (uint256, uint256);\\n\\n    function getAllMarkets() external view returns (VToken[] memory);\\n}\\n\\n/**\\n * @title ComptrollerViewInterface\\n * @author Venus\\n * @notice Interface implemented by the `Comptroller` contract, including only some util view functions.\\n */\\ninterface ComptrollerViewInterface {\\n    function markets(address) external view returns (bool, uint256);\\n\\n    function oracle() external view returns (ResilientOracleInterface);\\n\\n    function getAssetsIn(address) external view returns (VToken[] memory);\\n\\n    function closeFactorMantissa() external view returns (uint256);\\n\\n    function liquidationIncentiveMantissa() external view returns (uint256);\\n\\n    function minLiquidatableCollateral() external view returns (uint256);\\n\\n    function getRewardDistributors() external view returns (RewardsDistributor[] memory);\\n\\n    function getAllMarkets() external view returns (VToken[] memory);\\n\\n    function borrowCaps(address) external view returns (uint256);\\n\\n    function supplyCaps(address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/ComptrollerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\n\\nimport { VToken } from \\\"./VToken.sol\\\";\\nimport { RewardsDistributor } from \\\"./Rewards/RewardsDistributor.sol\\\";\\n\\n/**\\n * @title ComptrollerStorage\\n * @author Venus\\n * @notice Storage layout for the `Comptroller` contract.\\n */\\ncontract ComptrollerStorage {\\n    struct LiquidationOrder {\\n        VToken vTokenCollateral;\\n        VToken vTokenBorrowed;\\n        uint256 repayAmount;\\n    }\\n\\n    struct AccountLiquiditySnapshot {\\n        uint256 totalCollateral;\\n        uint256 weightedCollateral;\\n        uint256 borrows;\\n        uint256 effects;\\n        uint256 liquidity;\\n        uint256 shortfall;\\n    }\\n\\n    struct RewardSpeeds {\\n        address rewardToken;\\n        uint256 supplySpeed;\\n        uint256 borrowSpeed;\\n    }\\n\\n    struct Market {\\n        // Whether or not this market is listed\\n        bool isListed;\\n        //  Multiplier representing the most one can borrow against their collateral in this market.\\n        //  For instance, 0.9 to allow borrowing 90% of collateral value.\\n        //  Must be between 0 and 1, and stored as a mantissa.\\n        uint256 collateralFactorMantissa;\\n        //  Multiplier representing the collateralization after which the borrow is eligible\\n        //  for liquidation. For instance, 0.8 liquidate when the borrow is 80% of collateral\\n        //  value. Must be between 0 and collateral factor, stored as a mantissa.\\n        uint256 liquidationThresholdMantissa;\\n        // Per-market mapping of \\\"accounts in this asset\\\"\\n        mapping(address => bool) accountMembership;\\n    }\\n\\n    enum Action {\\n        MINT,\\n        REDEEM,\\n        BORROW,\\n        REPAY,\\n        SEIZE,\\n        LIQUIDATE,\\n        TRANSFER,\\n        ENTER_MARKET,\\n        EXIT_MARKET\\n    }\\n\\n    /**\\n     * @notice Oracle which gives the price of any given asset\\n     */\\n    ResilientOracleInterface public oracle;\\n\\n    /**\\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\n     */\\n    uint256 public closeFactorMantissa;\\n\\n    /**\\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\\n     */\\n    uint256 public liquidationIncentiveMantissa;\\n\\n    /**\\n     * @notice Per-account mapping of \\\"assets you are in\\\"\\n     */\\n    mapping(address => VToken[]) public accountAssets;\\n\\n    /**\\n     * @notice Official mapping of vTokens -> Market metadata\\n     * @dev Used e.g. to determine if a market is supported\\n     */\\n    mapping(address => Market) public markets;\\n\\n    /// @notice A list of all markets\\n    VToken[] public allMarkets;\\n\\n    /// @notice Borrow caps enforced by borrowAllowed for each vToken address. Defaults to zero which restricts borrowing.\\n    mapping(address => uint256) public borrowCaps;\\n\\n    /// @notice Minimal collateral required for regular (non-batch) liquidations\\n    uint256 public minLiquidatableCollateral;\\n\\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting not allowed\\n    mapping(address => uint256) public supplyCaps;\\n\\n    /// @notice True if a certain action is paused on a certain market\\n    mapping(address => mapping(Action => bool)) internal _actionPaused;\\n\\n    // List of Reward Distributors added\\n    RewardsDistributor[] internal rewardsDistributors;\\n\\n    // Used to check if rewards distributor is added\\n    mapping(address => bool) internal rewardsDistributorExists;\\n\\n    /// @notice Flag indicating whether forced liquidation enabled for a market\\n    mapping(address => bool) public isForcedLiquidationEnabled;\\n\\n    uint256 internal constant NO_ERROR = 0;\\n\\n    // closeFactorMantissa must be strictly greater than this value\\n    uint256 internal constant MIN_CLOSE_FACTOR_MANTISSA = 0.05e18; // 0.05\\n\\n    // closeFactorMantissa must not exceed this value\\n    uint256 internal constant MAX_CLOSE_FACTOR_MANTISSA = 0.9e18; // 0.9\\n\\n    // No collateralFactorMantissa may exceed this value\\n    uint256 internal constant MAX_COLLATERAL_FACTOR_MANTISSA = 0.9e18; // 0.9\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/ErrorReporter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title TokenErrorReporter\\n * @author Venus\\n * @notice Errors that can be thrown by the `VToken` contract.\\n */\\ncontract TokenErrorReporter {\\n    uint256 public constant NO_ERROR = 0; // support legacy return codes\\n\\n    error TransferNotAllowed();\\n\\n    error MintFreshnessCheck();\\n\\n    error RedeemFreshnessCheck();\\n    error RedeemTransferOutNotPossible();\\n\\n    error BorrowFreshnessCheck();\\n    error BorrowCashNotAvailable();\\n\\n    error RepayBorrowFreshnessCheck();\\n\\n    error HealBorrowUnauthorized();\\n    error ForceLiquidateBorrowUnauthorized();\\n\\n    error LiquidateFreshnessCheck();\\n    error LiquidateCollateralFreshnessCheck();\\n    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\\n    error LiquidateLiquidatorIsBorrower();\\n    error LiquidateCloseAmountIsZero();\\n    error LiquidateCloseAmountIsUintMax();\\n\\n    error LiquidateSeizeLiquidatorIsBorrower();\\n\\n    error ProtocolSeizeShareTooBig();\\n\\n    error SetReserveFactorFreshCheck();\\n    error SetReserveFactorBoundsCheck();\\n\\n    error AddReservesFactorFreshCheck(uint256 actualAddAmount);\\n\\n    error ReduceReservesFreshCheck();\\n    error ReduceReservesCashNotAvailable();\\n    error ReduceReservesCashValidation();\\n\\n    error SetInterestRateModelFreshCheck();\\n}\\n\"\r\n    },\r\n    \"contracts/ExponentialNoError.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { EXP_SCALE as EXP_SCALE_, MANTISSA_ONE as MANTISSA_ONE_ } from \\\"./lib/constants.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract ExponentialNoError {\\n    struct Exp {\\n        uint256 mantissa;\\n    }\\n\\n    struct Double {\\n        uint256 mantissa;\\n    }\\n\\n    uint256 internal constant EXP_SCALE = EXP_SCALE_;\\n    uint256 internal constant DOUBLE_SCALE = 1e36;\\n    uint256 internal constant HALF_EXP_SCALE = EXP_SCALE / 2;\\n    uint256 internal constant MANTISSA_ONE = MANTISSA_ONE_;\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * EXP_SCALE}) = 15\\n     */\\n    function truncate(Exp memory exp) internal pure returns (uint256) {\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\n        return exp.mantissa / EXP_SCALE;\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\\n        Exp memory product = mul_(a, scalar);\\n        return truncate(product);\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint256 scalar, uint256 addend) internal pure returns (uint256) {\\n        Exp memory product = mul_(a, scalar);\\n        return add_(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n        return left.mantissa < right.mantissa;\\n    }\\n\\n    function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\\n        require(n <= type(uint224).max, errorMessage);\\n        return uint224(n);\\n    }\\n\\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n <= type(uint32).max, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: add_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function add_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\\n    }\\n\\n    function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / EXP_SCALE });\\n    }\\n\\n    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: mul_(a.mantissa, b) });\\n    }\\n\\n    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n        return mul_(a, b.mantissa) / EXP_SCALE;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: mul_(a.mantissa, b.mantissa) / DOUBLE_SCALE });\\n    }\\n\\n    function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n        return Double({ mantissa: mul_(a.mantissa, b) });\\n    }\\n\\n    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\\n        return mul_(a, b.mantissa) / DOUBLE_SCALE;\\n    }\\n\\n    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: div_(mul_(a.mantissa, EXP_SCALE), b.mantissa) });\\n    }\\n\\n    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n        return Exp({ mantissa: div_(a.mantissa, b) });\\n    }\\n\\n    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n        return div_(mul_(a, EXP_SCALE), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({ mantissa: div_(mul_(a.mantissa, DOUBLE_SCALE), b.mantissa) });\\n    }\\n\\n    function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n        return Double({ mantissa: div_(a.mantissa, b) });\\n    }\\n\\n    function div_(uint256 a, Double memory b) internal pure returns (uint256) {\\n        return div_(mul_(a, DOUBLE_SCALE), b.mantissa);\\n    }\\n\\n    function div_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\\n        return Double({ mantissa: div_(mul_(a, DOUBLE_SCALE), b) });\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/InterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title Compound's InterestRateModel Interface\\n * @author Compound\\n */\\nabstract contract InterestRateModel {\\n    /**\\n     * @notice Calculates the current borrow interest rate per block\\n     * @param cash The total amount of cash the market has\\n     * @param borrows The total amount of borrows the market has outstanding\\n     * @param reserves The total amount of reserves the market has\\n     * @param badDebt The amount of badDebt in the market\\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\n     */\\n    function getBorrowRate(\\n        uint256 cash,\\n        uint256 borrows,\\n        uint256 reserves,\\n        uint256 badDebt\\n    ) external view virtual returns (uint256);\\n\\n    /**\\n     * @notice Calculates the current supply interest rate per block\\n     * @param cash The total amount of cash the market has\\n     * @param borrows The total amount of borrows the market has outstanding\\n     * @param reserves The total amount of reserves the market has\\n     * @param reserveFactorMantissa The current reserve factor the market has\\n     * @param badDebt The amount of badDebt in the market\\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n     */\\n    function getSupplyRate(\\n        uint256 cash,\\n        uint256 borrows,\\n        uint256 reserves,\\n        uint256 reserveFactorMantissa,\\n        uint256 badDebt\\n    ) external view virtual returns (uint256);\\n\\n    /**\\n     * @notice Indicator that this is an InterestRateModel contract (for inspection)\\n     * @return Always true\\n     */\\n    function isInterestRateModel() external pure virtual returns (bool) {\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/// @dev The approximate number of blocks per year that is assumed by the interest rate model\\nuint256 constant BLOCKS_PER_YEAR = 10_512_000;\\n\\n/// @dev Base unit for computations, usually used in scaling (multiplications, divisions)\\nuint256 constant EXP_SCALE = 1e18;\\n\\n/// @dev A unit (literal one) in EXP_SCALE, usually used in additions/subtractions\\nuint256 constant MANTISSA_ONE = EXP_SCALE;\\n\"\r\n    },\r\n    \"contracts/lib/validators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/// @notice Thrown if the supplied address is a zero address where it is not allowed\\nerror ZeroAddressNotAllowed();\\n\\n/// @notice Checks if the provided address is nonzero, reverts otherwise\\n/// @param address_ Address to check\\n/// @custom:error ZeroAddressNotAllowed is thrown if the provided address is a zero address\\nfunction ensureNonzeroAddress(address address_) pure {\\n    if (address_ == address(0)) {\\n        revert ZeroAddressNotAllowed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MaxLoopsLimitHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\n/**\\n * @title MaxLoopsLimitHelper\\n * @author Venus\\n * @notice Abstract contract used to avoid collection with too many items that would generate gas errors and DoS.\\n */\\nabstract contract MaxLoopsLimitHelper {\\n    // Limit for the loops to avoid the DOS\\n    uint256 public maxLoopsLimit;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n\\n    /// @notice Emitted when max loops limit is set\\n    event MaxLoopsLimitUpdated(uint256 oldMaxLoopsLimit, uint256 newmaxLoopsLimit);\\n\\n    /// @notice Thrown an error on maxLoopsLimit exceeds for any loop\\n    error MaxLoopsLimitExceeded(uint256 loopsLimit, uint256 requiredLoops);\\n\\n    /**\\n     * @notice Set the limit for the loops can iterate to avoid the DOS\\n     * @param limit Limit for the max loops can execute at a time\\n     */\\n    function _setMaxLoopsLimit(uint256 limit) internal {\\n        require(limit > maxLoopsLimit, \\\"Comptroller: Invalid maxLoopsLimit\\\");\\n\\n        uint256 oldMaxLoopsLimit = maxLoopsLimit;\\n        maxLoopsLimit = limit;\\n\\n        emit MaxLoopsLimitUpdated(oldMaxLoopsLimit, limit);\\n    }\\n\\n    /**\\n     * @notice Compare the maxLoopsLimit with number of the times loop iterate\\n     * @param len Length of the loops iterate\\n     * @custom:error MaxLoopsLimitExceeded error is thrown when loops length exceeds maxLoopsLimit\\n     */\\n    function _ensureMaxLoops(uint256 len) internal view {\\n        if (len > maxLoopsLimit) {\\n            revert MaxLoopsLimitExceeded(maxLoopsLimit, len);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Rewards/RewardsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { AccessControlledV8 } from \\\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\\\";\\n\\nimport { ExponentialNoError } from \\\"../ExponentialNoError.sol\\\";\\nimport { VToken } from \\\"../VToken.sol\\\";\\nimport { Comptroller } from \\\"../Comptroller.sol\\\";\\nimport { MaxLoopsLimitHelper } from \\\"../MaxLoopsLimitHelper.sol\\\";\\n\\n/**\\n * @title `RewardsDistributor`\\n * @author Venus\\n * @notice Contract used to configure, track and distribute rewards to users based on their actions (borrows and supplies) in the protocol.\\n * Users can receive additional rewards through a `RewardsDistributor`. Each `RewardsDistributor` proxy is initialized with a specific reward\\n * token and `Comptroller`, which can then distribute the reward token to users that supply or borrow in the associated pool.\\n * Authorized users can set the reward token borrow and supply speeds for each market in the pool. This sets a fixed amount of reward\\n * token to be released each block for borrowers and suppliers, which is distributed based on a user\u2019s percentage of the borrows or supplies\\n * respectively. The owner can also set up reward distributions to contributor addresses (distinct from suppliers and borrowers) by setting\\n * their contributor reward token speed, which similarly allocates a fixed amount of reward token per block.\\n *\\n * The owner has the ability to transfer any amount of reward tokens held by the contract to any other address. Rewards are not distributed\\n * automatically and must be claimed by a user calling `claimRewardToken()`. Users should be aware that it is up to the owner and other centralized\\n * entities to ensure that the `RewardsDistributor` holds enough tokens to distribute the accumulated rewards of users and contributors.\\n */\\ncontract RewardsDistributor is ExponentialNoError, Ownable2StepUpgradeable, AccessControlledV8, MaxLoopsLimitHelper {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    struct RewardToken {\\n        // The market's last updated rewardTokenBorrowIndex or rewardTokenSupplyIndex\\n        uint224 index;\\n        // The block number the index was last updated at\\n        uint32 block;\\n        // The block number at which to stop rewards\\n        uint32 lastRewardingBlock;\\n    }\\n\\n    /// @notice The initial REWARD TOKEN index for a market\\n    uint224 public constant INITIAL_INDEX = 1e36;\\n\\n    /// @notice The REWARD TOKEN market supply state for each market\\n    mapping(address => RewardToken) public rewardTokenSupplyState;\\n\\n    /// @notice The REWARD TOKEN borrow index for each market for each supplier as of the last time they accrued REWARD TOKEN\\n    mapping(address => mapping(address => uint256)) public rewardTokenSupplierIndex;\\n\\n    /// @notice The REWARD TOKEN accrued but not yet transferred to each user\\n    mapping(address => uint256) public rewardTokenAccrued;\\n\\n    /// @notice The rate at which rewardToken is distributed to the corresponding borrow market (per block)\\n    mapping(address => uint256) public rewardTokenBorrowSpeeds;\\n\\n    /// @notice The rate at which rewardToken is distributed to the corresponding supply market (per block)\\n    mapping(address => uint256) public rewardTokenSupplySpeeds;\\n\\n    /// @notice The REWARD TOKEN market borrow state for each market\\n    mapping(address => RewardToken) public rewardTokenBorrowState;\\n\\n    /// @notice The portion of REWARD TOKEN that each contributor receives per block\\n    mapping(address => uint256) public rewardTokenContributorSpeeds;\\n\\n    /// @notice Last block at which a contributor's REWARD TOKEN rewards have been allocated\\n    mapping(address => uint256) public lastContributorBlock;\\n\\n    /// @notice The REWARD TOKEN borrow index for each market for each borrower as of the last time they accrued REWARD TOKEN\\n    mapping(address => mapping(address => uint256)) public rewardTokenBorrowerIndex;\\n\\n    Comptroller private comptroller;\\n\\n    IERC20Upgradeable public rewardToken;\\n\\n    /// @notice Emitted when REWARD TOKEN is distributed to a supplier\\n    event DistributedSupplierRewardToken(\\n        VToken indexed vToken,\\n        address indexed supplier,\\n        uint256 rewardTokenDelta,\\n        uint256 rewardTokenTotal,\\n        uint256 rewardTokenSupplyIndex\\n    );\\n\\n    /// @notice Emitted when REWARD TOKEN is distributed to a borrower\\n    event DistributedBorrowerRewardToken(\\n        VToken indexed vToken,\\n        address indexed borrower,\\n        uint256 rewardTokenDelta,\\n        uint256 rewardTokenTotal,\\n        uint256 rewardTokenBorrowIndex\\n    );\\n\\n    /// @notice Emitted when a new supply-side REWARD TOKEN speed is calculated for a market\\n    event RewardTokenSupplySpeedUpdated(VToken indexed vToken, uint256 newSpeed);\\n\\n    /// @notice Emitted when a new borrow-side REWARD TOKEN speed is calculated for a market\\n    event RewardTokenBorrowSpeedUpdated(VToken indexed vToken, uint256 newSpeed);\\n\\n    /// @notice Emitted when REWARD TOKEN is granted by admin\\n    event RewardTokenGranted(address indexed recipient, uint256 amount);\\n\\n    /// @notice Emitted when a new REWARD TOKEN speed is set for a contributor\\n    event ContributorRewardTokenSpeedUpdated(address indexed contributor, uint256 newSpeed);\\n\\n    /// @notice Emitted when a market is initialized\\n    event MarketInitialized(address indexed vToken);\\n\\n    /// @notice Emitted when a reward token supply index is updated\\n    event RewardTokenSupplyIndexUpdated(address indexed vToken);\\n\\n    /// @notice Emitted when a reward token borrow index is updated\\n    event RewardTokenBorrowIndexUpdated(address indexed vToken, Exp marketBorrowIndex);\\n\\n    /// @notice Emitted when a reward for contributor is updated\\n    event ContributorRewardsUpdated(address indexed contributor, uint256 rewardAccrued);\\n\\n    /// @notice Emitted when a reward token last rewarding block for supply is updated\\n    event SupplyLastRewardingBlockUpdated(address indexed vToken, uint32 newBlock);\\n\\n    /// @notice Emitted when a reward token last rewarding block for borrow is updated\\n    event BorrowLastRewardingBlockUpdated(address indexed vToken, uint32 newBlock);\\n\\n    modifier onlyComptroller() {\\n        require(address(comptroller) == msg.sender, \\\"Only comptroller can call this function\\\");\\n        _;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice RewardsDistributor initializer\\n     * @dev Initializes the deployer to owner\\n     * @param comptroller_ Comptroller to attach the reward distributor to\\n     * @param rewardToken_ Reward token to distribute\\n     * @param loopsLimit_ Maximum number of iterations for the loops in this contract\\n     * @param accessControlManager_ AccessControlManager contract address\\n     */\\n    function initialize(\\n        Comptroller comptroller_,\\n        IERC20Upgradeable rewardToken_,\\n        uint256 loopsLimit_,\\n        address accessControlManager_\\n    ) external initializer {\\n        comptroller = comptroller_;\\n        rewardToken = rewardToken_;\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager_);\\n\\n        _setMaxLoopsLimit(loopsLimit_);\\n    }\\n\\n    function initializeMarket(address vToken) external onlyComptroller {\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\n\\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\\n\\n        /*\\n         * Update market state indices\\n         */\\n        if (supplyState.index == 0) {\\n            // Initialize supply state index with default value\\n            supplyState.index = INITIAL_INDEX;\\n        }\\n\\n        if (borrowState.index == 0) {\\n            // Initialize borrow state index with default value\\n            borrowState.index = INITIAL_INDEX;\\n        }\\n\\n        /*\\n         * Update market state block numbers\\n         */\\n        supplyState.block = borrowState.block = blockNumber;\\n\\n        emit MarketInitialized(vToken);\\n    }\\n\\n    /*** Reward Token Distribution ***/\\n\\n    /**\\n     * @notice Calculate reward token accrued by a borrower and possibly transfer it to them\\n     *         Borrowers will begin to accrue after the first interaction with the protocol.\\n     * @dev This function should only be called when the user has a borrow position in the market\\n     *      (e.g. Comptroller.preBorrowHook, and Comptroller.preRepayHook)\\n     *      We avoid an external call to check if they are in the market to save gas because this function is called in many places\\n     * @param vToken The market in which the borrower is interacting\\n     * @param borrower The address of the borrower to distribute REWARD TOKEN to\\n     * @param marketBorrowIndex The current global borrow index of vToken\\n     */\\n    function distributeBorrowerRewardToken(\\n        address vToken,\\n        address borrower,\\n        Exp memory marketBorrowIndex\\n    ) external onlyComptroller {\\n        _distributeBorrowerRewardToken(vToken, borrower, marketBorrowIndex);\\n    }\\n\\n    function updateRewardTokenSupplyIndex(address vToken) external onlyComptroller {\\n        _updateRewardTokenSupplyIndex(vToken);\\n    }\\n\\n    /**\\n     * @notice Transfer REWARD TOKEN to the recipient\\n     * @dev Note: If there is not enough REWARD TOKEN, we do not perform the transfer all\\n     * @param recipient The address of the recipient to transfer REWARD TOKEN to\\n     * @param amount The amount of REWARD TOKEN to (possibly) transfer\\n     */\\n    function grantRewardToken(address recipient, uint256 amount) external onlyOwner {\\n        uint256 amountLeft = _grantRewardToken(recipient, amount);\\n        require(amountLeft == 0, \\\"insufficient rewardToken for grant\\\");\\n        emit RewardTokenGranted(recipient, amount);\\n    }\\n\\n    function updateRewardTokenBorrowIndex(address vToken, Exp memory marketBorrowIndex) external onlyComptroller {\\n        _updateRewardTokenBorrowIndex(vToken, marketBorrowIndex);\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN borrow and supply speeds for the specified markets\\n     * @param vTokens The markets whose REWARD TOKEN speed to update\\n     * @param supplySpeeds New supply-side REWARD TOKEN speed for the corresponding market\\n     * @param borrowSpeeds New borrow-side REWARD TOKEN speed for the corresponding market\\n     */\\n    function setRewardTokenSpeeds(\\n        VToken[] memory vTokens,\\n        uint256[] memory supplySpeeds,\\n        uint256[] memory borrowSpeeds\\n    ) external {\\n        _checkAccessAllowed(\\\"setRewardTokenSpeeds(address[],uint256[],uint256[])\\\");\\n        uint256 numTokens = vTokens.length;\\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \\\"invalid setRewardTokenSpeeds\\\");\\n\\n        for (uint256 i; i < numTokens; ++i) {\\n            _setRewardTokenSpeed(vTokens[i], supplySpeeds[i], borrowSpeeds[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN last rewarding block for the specified markets\\n     * @param vTokens The markets whose REWARD TOKEN last rewarding block to update\\n     * @param supplyLastRewardingBlocks New supply-side REWARD TOKEN last rewarding block for the corresponding market\\n     * @param borrowLastRewardingBlocks New borrow-side REWARD TOKEN last rewarding block for the corresponding market\\n     */\\n    function setLastRewardingBlocks(\\n        VToken[] calldata vTokens,\\n        uint32[] calldata supplyLastRewardingBlocks,\\n        uint32[] calldata borrowLastRewardingBlocks\\n    ) external {\\n        _checkAccessAllowed(\\\"setLastRewardingBlock(address[],uint32[],uint32[])\\\");\\n        uint256 numTokens = vTokens.length;\\n        require(\\n            numTokens == supplyLastRewardingBlocks.length && numTokens == borrowLastRewardingBlocks.length,\\n            \\\"RewardsDistributor::setLastRewardingBlocks invalid input\\\"\\n        );\\n\\n        for (uint256 i; i < numTokens; ) {\\n            _setLastRewardingBlock(vTokens[i], supplyLastRewardingBlocks[i], borrowLastRewardingBlocks[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN speed for a single contributor\\n     * @param contributor The contributor whose REWARD TOKEN speed to update\\n     * @param rewardTokenSpeed New REWARD TOKEN speed for contributor\\n     */\\n    function setContributorRewardTokenSpeed(address contributor, uint256 rewardTokenSpeed) external onlyOwner {\\n        // note that REWARD TOKEN speed could be set to 0 to halt liquidity rewards for a contributor\\n        updateContributorRewards(contributor);\\n        if (rewardTokenSpeed == 0) {\\n            // release storage\\n            delete lastContributorBlock[contributor];\\n        } else {\\n            lastContributorBlock[contributor] = getBlockNumber();\\n        }\\n        rewardTokenContributorSpeeds[contributor] = rewardTokenSpeed;\\n\\n        emit ContributorRewardTokenSpeedUpdated(contributor, rewardTokenSpeed);\\n    }\\n\\n    function distributeSupplierRewardToken(address vToken, address supplier) external onlyComptroller {\\n        _distributeSupplierRewardToken(vToken, supplier);\\n    }\\n\\n    /**\\n     * @notice Claim all the rewardToken accrued by holder in all markets\\n     * @param holder The address to claim REWARD TOKEN for\\n     */\\n    function claimRewardToken(address holder) external {\\n        return claimRewardToken(holder, comptroller.getAllMarkets());\\n    }\\n\\n    /**\\n     * @notice Set the limit for the loops can iterate to avoid the DOS\\n     * @param limit Limit for the max loops can execute at a time\\n     */\\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\\n        _setMaxLoopsLimit(limit);\\n    }\\n\\n    /**\\n     * @notice Calculate additional accrued REWARD TOKEN for a contributor since last accrual\\n     * @param contributor The address to calculate contributor rewards for\\n     */\\n    function updateContributorRewards(address contributor) public {\\n        uint256 rewardTokenSpeed = rewardTokenContributorSpeeds[contributor];\\n        uint256 blockNumber = getBlockNumber();\\n        uint256 deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\\n        if (deltaBlocks > 0 && rewardTokenSpeed > 0) {\\n            uint256 newAccrued = mul_(deltaBlocks, rewardTokenSpeed);\\n            uint256 contributorAccrued = add_(rewardTokenAccrued[contributor], newAccrued);\\n\\n            rewardTokenAccrued[contributor] = contributorAccrued;\\n            lastContributorBlock[contributor] = blockNumber;\\n\\n            emit ContributorRewardsUpdated(contributor, rewardTokenAccrued[contributor]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim all the rewardToken accrued by holder in the specified markets\\n     * @param holder The address to claim REWARD TOKEN for\\n     * @param vTokens The list of markets to claim REWARD TOKEN in\\n     */\\n    function claimRewardToken(address holder, VToken[] memory vTokens) public {\\n        uint256 vTokensCount = vTokens.length;\\n\\n        _ensureMaxLoops(vTokensCount);\\n\\n        for (uint256 i; i < vTokensCount; ++i) {\\n            VToken vToken = vTokens[i];\\n            require(comptroller.isMarketListed(vToken), \\\"market must be listed\\\");\\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\\n            _updateRewardTokenBorrowIndex(address(vToken), borrowIndex);\\n            _distributeBorrowerRewardToken(address(vToken), holder, borrowIndex);\\n            _updateRewardTokenSupplyIndex(address(vToken));\\n            _distributeSupplierRewardToken(address(vToken), holder);\\n        }\\n        rewardTokenAccrued[holder] = _grantRewardToken(holder, rewardTokenAccrued[holder]);\\n    }\\n\\n    function getBlockNumber() public view virtual returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN last rewarding block for a single market.\\n     * @param vToken market's whose reward token last rewarding block to be updated\\n     * @param supplyLastRewardingBlock New supply-side REWARD TOKEN last rewarding block for market\\n     * @param borrowLastRewardingBlock New borrow-side REWARD TOKEN last rewarding block for market\\n     */\\n    function _setLastRewardingBlock(\\n        VToken vToken,\\n        uint32 supplyLastRewardingBlock,\\n        uint32 borrowLastRewardingBlock\\n    ) internal {\\n        require(comptroller.isMarketListed(vToken), \\\"rewardToken market is not listed\\\");\\n\\n        uint256 blockNumber = getBlockNumber();\\n\\n        require(supplyLastRewardingBlock > blockNumber, \\\"setting last rewarding block in the past is not allowed\\\");\\n        require(borrowLastRewardingBlock > blockNumber, \\\"setting last rewarding block in the past is not allowed\\\");\\n\\n        uint32 currentSupplyLastRewardingBlock = rewardTokenSupplyState[address(vToken)].lastRewardingBlock;\\n        uint32 currentBorrowLastRewardingBlock = rewardTokenBorrowState[address(vToken)].lastRewardingBlock;\\n\\n        require(\\n            currentSupplyLastRewardingBlock == 0 || currentSupplyLastRewardingBlock > blockNumber,\\n            \\\"this RewardsDistributor is already locked\\\"\\n        );\\n        require(\\n            currentBorrowLastRewardingBlock == 0 || currentBorrowLastRewardingBlock > blockNumber,\\n            \\\"this RewardsDistributor is already locked\\\"\\n        );\\n\\n        if (currentSupplyLastRewardingBlock != supplyLastRewardingBlock) {\\n            rewardTokenSupplyState[address(vToken)].lastRewardingBlock = supplyLastRewardingBlock;\\n            emit SupplyLastRewardingBlockUpdated(address(vToken), supplyLastRewardingBlock);\\n        }\\n\\n        if (currentBorrowLastRewardingBlock != borrowLastRewardingBlock) {\\n            rewardTokenBorrowState[address(vToken)].lastRewardingBlock = borrowLastRewardingBlock;\\n            emit BorrowLastRewardingBlockUpdated(address(vToken), borrowLastRewardingBlock);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set REWARD TOKEN speed for a single market.\\n     * @param vToken market's whose reward token rate to be updated\\n     * @param supplySpeed New supply-side REWARD TOKEN speed for market\\n     * @param borrowSpeed New borrow-side REWARD TOKEN speed for market\\n     */\\n    function _setRewardTokenSpeed(VToken vToken, uint256 supplySpeed, uint256 borrowSpeed) internal {\\n        require(comptroller.isMarketListed(vToken), \\\"rewardToken market is not listed\\\");\\n\\n        if (rewardTokenSupplySpeeds[address(vToken)] != supplySpeed) {\\n            // Supply speed updated so let's update supply state to ensure that\\n            //  1. REWARD TOKEN accrued properly for the old speed, and\\n            //  2. REWARD TOKEN accrued at the new speed starts after this block.\\n            _updateRewardTokenSupplyIndex(address(vToken));\\n\\n            // Update speed and emit event\\n            rewardTokenSupplySpeeds[address(vToken)] = supplySpeed;\\n            emit RewardTokenSupplySpeedUpdated(vToken, supplySpeed);\\n        }\\n\\n        if (rewardTokenBorrowSpeeds[address(vToken)] != borrowSpeed) {\\n            // Borrow speed updated so let's update borrow state to ensure that\\n            //  1. REWARD TOKEN accrued properly for the old speed, and\\n            //  2. REWARD TOKEN accrued at the new speed starts after this block.\\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\\n            _updateRewardTokenBorrowIndex(address(vToken), borrowIndex);\\n\\n            // Update speed and emit event\\n            rewardTokenBorrowSpeeds[address(vToken)] = borrowSpeed;\\n            emit RewardTokenBorrowSpeedUpdated(vToken, borrowSpeed);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate REWARD TOKEN accrued by a supplier and possibly transfer it to them.\\n     * @param vToken The market in which the supplier is interacting\\n     * @param supplier The address of the supplier to distribute REWARD TOKEN to\\n     */\\n    function _distributeSupplierRewardToken(address vToken, address supplier) internal {\\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\\n        uint256 supplyIndex = supplyState.index;\\n        uint256 supplierIndex = rewardTokenSupplierIndex[vToken][supplier];\\n\\n        // Update supplier's index to the current index since we are distributing accrued REWARD TOKEN\\n        rewardTokenSupplierIndex[vToken][supplier] = supplyIndex;\\n\\n        if (supplierIndex == 0 && supplyIndex >= INITIAL_INDEX) {\\n            // Covers the case where users supplied tokens before the market's supply state index was set.\\n            // Rewards the user with REWARD TOKEN accrued from the start of when supplier rewards were first\\n            // set for the market.\\n            supplierIndex = INITIAL_INDEX;\\n        }\\n\\n        // Calculate change in the cumulative sum of the REWARD TOKEN per vToken accrued\\n        Double memory deltaIndex = Double({ mantissa: sub_(supplyIndex, supplierIndex) });\\n\\n        uint256 supplierTokens = VToken(vToken).balanceOf(supplier);\\n\\n        // Calculate REWARD TOKEN accrued: vTokenAmount * accruedPerVToken\\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\\n\\n        uint256 supplierAccrued = add_(rewardTokenAccrued[supplier], supplierDelta);\\n        rewardTokenAccrued[supplier] = supplierAccrued;\\n\\n        emit DistributedSupplierRewardToken(VToken(vToken), supplier, supplierDelta, supplierAccrued, supplyIndex);\\n    }\\n\\n    /**\\n     * @notice Calculate reward token accrued by a borrower and possibly transfer it to them.\\n     * @param vToken The market in which the borrower is interacting\\n     * @param borrower The address of the borrower to distribute REWARD TOKEN to\\n     * @param marketBorrowIndex The current global borrow index of vToken\\n     */\\n    function _distributeBorrowerRewardToken(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\\n        uint256 borrowIndex = borrowState.index;\\n        uint256 borrowerIndex = rewardTokenBorrowerIndex[vToken][borrower];\\n\\n        // Update borrowers's index to the current index since we are distributing accrued REWARD TOKEN\\n        rewardTokenBorrowerIndex[vToken][borrower] = borrowIndex;\\n\\n        if (borrowerIndex == 0 && borrowIndex >= INITIAL_INDEX) {\\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\\n            // Rewards the user with REWARD TOKEN accrued from the start of when borrower rewards were first\\n            // set for the market.\\n            borrowerIndex = INITIAL_INDEX;\\n        }\\n\\n        // Calculate change in the cumulative sum of the REWARD TOKEN per borrowed unit accrued\\n        Double memory deltaIndex = Double({ mantissa: sub_(borrowIndex, borrowerIndex) });\\n\\n        uint256 borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\\n\\n        // Calculate REWARD TOKEN accrued: vTokenAmount * accruedPerBorrowedUnit\\n        if (borrowerAmount != 0) {\\n            uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\\n\\n            uint256 borrowerAccrued = add_(rewardTokenAccrued[borrower], borrowerDelta);\\n            rewardTokenAccrued[borrower] = borrowerAccrued;\\n\\n            emit DistributedBorrowerRewardToken(VToken(vToken), borrower, borrowerDelta, borrowerAccrued, borrowIndex);\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer REWARD TOKEN to the user.\\n     * @dev Note: If there is not enough REWARD TOKEN, we do not perform the transfer all.\\n     * @param user The address of the user to transfer REWARD TOKEN to\\n     * @param amount The amount of REWARD TOKEN to (possibly) transfer\\n     * @return The amount of REWARD TOKEN which was NOT transferred to the user\\n     */\\n    function _grantRewardToken(address user, uint256 amount) internal returns (uint256) {\\n        uint256 rewardTokenRemaining = rewardToken.balanceOf(address(this));\\n        if (amount > 0 && amount <= rewardTokenRemaining) {\\n            rewardToken.safeTransfer(user, amount);\\n            return 0;\\n        }\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice Accrue REWARD TOKEN to the market by updating the supply index\\n     * @param vToken The market whose supply index to update\\n     * @dev Index is a cumulative sum of the REWARD TOKEN per vToken accrued\\n     */\\n    function _updateRewardTokenSupplyIndex(address vToken) internal {\\n        RewardToken storage supplyState = rewardTokenSupplyState[vToken];\\n        uint256 supplySpeed = rewardTokenSupplySpeeds[vToken];\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\n\\n        if (supplyState.lastRewardingBlock > 0 && blockNumber > supplyState.lastRewardingBlock) {\\n            blockNumber = supplyState.lastRewardingBlock;\\n        }\\n\\n        uint256 deltaBlocks = sub_(uint256(blockNumber), uint256(supplyState.block));\\n\\n        if (deltaBlocks > 0 && supplySpeed > 0) {\\n            uint256 supplyTokens = VToken(vToken).totalSupply();\\n            uint256 accruedSinceUpdate = mul_(deltaBlocks, supplySpeed);\\n            Double memory ratio = supplyTokens > 0\\n                ? fraction(accruedSinceUpdate, supplyTokens)\\n                : Double({ mantissa: 0 });\\n            supplyState.index = safe224(\\n                add_(Double({ mantissa: supplyState.index }), ratio).mantissa,\\n                \\\"new index exceeds 224 bits\\\"\\n            );\\n            supplyState.block = blockNumber;\\n        } else if (deltaBlocks > 0) {\\n            supplyState.block = blockNumber;\\n        }\\n\\n        emit RewardTokenSupplyIndexUpdated(vToken);\\n    }\\n\\n    /**\\n     * @notice Accrue REWARD TOKEN to the market by updating the borrow index\\n     * @param vToken The market whose borrow index to update\\n     * @param marketBorrowIndex The current global borrow index of vToken\\n     * @dev Index is a cumulative sum of the REWARD TOKEN per vToken accrued\\n     */\\n    function _updateRewardTokenBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\\n        RewardToken storage borrowState = rewardTokenBorrowState[vToken];\\n        uint256 borrowSpeed = rewardTokenBorrowSpeeds[vToken];\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\n\\n        if (borrowState.lastRewardingBlock > 0 && blockNumber > borrowState.lastRewardingBlock) {\\n            blockNumber = borrowState.lastRewardingBlock;\\n        }\\n\\n        uint256 deltaBlocks = sub_(uint256(blockNumber), uint256(borrowState.block));\\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\\n            uint256 borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\\n            uint256 accruedSinceUpdate = mul_(deltaBlocks, borrowSpeed);\\n            Double memory ratio = borrowAmount > 0\\n                ? fraction(accruedSinceUpdate, borrowAmount)\\n                : Double({ mantissa: 0 });\\n            borrowState.index = safe224(\\n                add_(Double({ mantissa: borrowState.index }), ratio).mantissa,\\n                \\\"new index exceeds 224 bits\\\"\\n            );\\n            borrowState.block = blockNumber;\\n        } else if (deltaBlocks > 0) {\\n            borrowState.block = blockNumber;\\n        }\\n\\n        emit RewardTokenBorrowIndexUpdated(vToken, marketBorrowIndex);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/VToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { AccessControlledV8 } from \\\"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\\\";\\nimport { IProtocolShareReserve } from \\\"@venusprotocol/protocol-reserve/contracts/Interfaces/IProtocolShareReserve.sol\\\";\\n\\nimport { VTokenInterface } from \\\"./VTokenInterfaces.sol\\\";\\nimport { ComptrollerInterface, ComptrollerViewInterface } from \\\"./ComptrollerInterface.sol\\\";\\nimport { TokenErrorReporter } from \\\"./ErrorReporter.sol\\\";\\nimport { InterestRateModel } from \\\"./InterestRateModel.sol\\\";\\nimport { ExponentialNoError } from \\\"./ExponentialNoError.sol\\\";\\nimport { ensureNonzeroAddress } from \\\"./lib/validators.sol\\\";\\n\\n/**\\n * @title VToken\\n * @author Venus\\n * @notice Each asset that is supported by a pool is integrated through an instance of the `VToken` contract. As outlined in the protocol overview,\\n * each isolated pool creates its own `vToken` corresponding to an asset. Within a given pool, each included `vToken` is referred to as a market of\\n * the pool. The main actions a user regularly interacts with in a market are:\\n\\n- mint/redeem of vTokens;\\n- transfer of vTokens;\\n- borrow/repay a loan on an underlying asset;\\n- liquidate a borrow or liquidate/heal an account.\\n\\n * A user supplies the underlying asset to a pool by minting `vTokens`, where the corresponding `vToken` amount is determined by the `exchangeRate`.\\n * The `exchangeRate` will change over time, dependent on a number of factors, some of which accrue interest. Additionally, once users have minted\\n * `vToken` in a pool, they can borrow any asset in the isolated pool by using their `vToken` as collateral. In order to borrow an asset or use a `vToken`\\n * as collateral, the user must be entered into each corresponding market (else, the `vToken` will not be considered collateral for a borrow). Note that\\n * a user may borrow up to a portion of their collateral determined by the market\u2019s collateral factor. However, if their borrowed amount exceeds an amount\\n * calculated using the market\u2019s corresponding liquidation threshold, the borrow is eligible for liquidation. When a user repays a borrow, they must also\\n * pay off interest accrued on the borrow.\\n * \\n * The Venus protocol includes unique mechanisms for healing an account and liquidating an account. These actions are performed in the `Comptroller`\\n * and consider all borrows and collateral for which a given account is entered within a market. These functions may only be called on an account with a\\n * total collateral amount that is no larger than a universal `minLiquidatableCollateral` value, which is used for all markets within a `Comptroller`.\\n * Both functions settle all of an account\u2019s borrows, but `healAccount()` may add `badDebt` to a vToken. For more detail, see the description of\\n * `healAccount()` and `liquidateAccount()` in the `Comptroller` summary section below.\\n */\\ncontract VToken is\\n    Ownable2StepUpgradeable,\\n    AccessControlledV8,\\n    VTokenInterface,\\n    ExponentialNoError,\\n    TokenErrorReporter\\n{\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    uint256 internal constant DEFAULT_PROTOCOL_SEIZE_SHARE_MANTISSA = 5e16; // 5%\\n\\n    /**\\n     * Reentrancy Guard **\\n     */\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     */\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"re-entered\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true; // get a gas-refund post-Istanbul\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\\n        // to set the state variables.\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Construct a new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param admin_ Address of the administrator of this token\\n     * @param accessControlManager_ AccessControlManager contract address\\n     * @param riskManagement Addresses of risk & income related contracts\\n     * @param reserveFactorMantissa_ Percentage of borrow interest that goes to reserves (from 0 to 1e18)\\n     * @custom:error ZeroAddressNotAllowed is thrown when admin address is zero\\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\\n     */\\n    function initialize(\\n        address underlying_,\\n        ComptrollerInterface comptroller_,\\n        InterestRateModel interestRateModel_,\\n        uint256 initialExchangeRateMantissa_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        address admin_,\\n        address accessControlManager_,\\n        RiskManagementInit memory riskManagement,\\n        uint256 reserveFactorMantissa_\\n    ) external initializer {\\n        ensureNonzeroAddress(admin_);\\n\\n        // Initialize the market\\n        _initialize(\\n            underlying_,\\n            comptroller_,\\n            interestRateModel_,\\n            initialExchangeRateMantissa_,\\n            name_,\\n            symbol_,\\n            decimals_,\\n            admin_,\\n            accessControlManager_,\\n            riskManagement,\\n            reserveFactorMantissa_\\n        );\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return success True if the transfer succeeded, reverts otherwise\\n     * @custom:event Emits Transfer event on success\\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\\n     * @custom:access Not restricted\\n     */\\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\\n        _transferTokens(msg.sender, msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return success True if the transfer succeeded, reverts otherwise\\n     * @custom:event Emits Transfer event on success\\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\\n     * @custom:access Not restricted\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\\n        _transferTokens(msg.sender, src, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\\n     * @return success Whether or not the approval succeeded\\n     * @custom:event Emits Approval event\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\n     */\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        ensureNonzeroAddress(spender);\\n\\n        address src = msg.sender;\\n        transferAllowances[src][spender] = amount;\\n        emit Approval(src, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Increase approval for `spender`\\n     * @param spender The address of the account which may transfer tokens\\n     * @param addedValue The number of additional tokens spender can transfer\\n     * @return success Whether or not the approval succeeded\\n     * @custom:event Emits Approval event\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\\n        ensureNonzeroAddress(spender);\\n\\n        address src = msg.sender;\\n        uint256 newAllowance = transferAllowances[src][spender];\\n        newAllowance += addedValue;\\n        transferAllowances[src][spender] = newAllowance;\\n\\n        emit Approval(src, spender, newAllowance);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Decreases approval for `spender`\\n     * @param spender The address of the account which may transfer tokens\\n     * @param subtractedValue The number of tokens to remove from total approval\\n     * @return success Whether or not the approval succeeded\\n     * @custom:event Emits Approval event\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {\\n        ensureNonzeroAddress(spender);\\n\\n        address src = msg.sender;\\n        uint256 currentAllowance = transferAllowances[src][spender];\\n        require(currentAllowance >= subtractedValue, \\\"decreased allowance below zero\\\");\\n        unchecked {\\n            currentAllowance -= subtractedValue;\\n        }\\n\\n        transferAllowances[src][spender] = currentAllowance;\\n\\n        emit Approval(src, spender, currentAllowance);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get the underlying balance of the `owner`\\n     * @dev This also accrues interest in a transaction\\n     * @param owner The address of the account to query\\n     * @return amount The amount of underlying owned by `owner`\\n     */\\n    function balanceOfUnderlying(address owner) external override returns (uint256) {\\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\\n    }\\n\\n    /**\\n     * @notice Returns the current total borrows plus accrued interest\\n     * @return totalBorrows The total borrows with interest\\n     */\\n    function totalBorrowsCurrent() external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        return totalBorrows;\\n    }\\n\\n    /**\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\n     * @return borrowBalance The calculated balance\\n     */\\n    function borrowBalanceCurrent(address account) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        return _borrowBalanceStored(account);\\n    }\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function mint(uint256 mintAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        _mintFresh(msg.sender, msg.sender, mintAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender calls on-behalf of minter. minter supplies assets into the market and receives vTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param minter User whom the supply will be attributed to\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     * @custom:error ZeroAddressNotAllowed is thrown when minter address is zero\\n     */\\n    function mintBehalf(address minter, uint256 mintAmount) external override nonReentrant returns (uint256) {\\n        ensureNonzeroAddress(minter);\\n\\n        accrueInterest();\\n        // _mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        _mintFresh(msg.sender, minter, mintAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems vTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of vTokens to redeem into underlying\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Redeem and Transfer events; may emit AccrueInterest\\n     * @custom:error RedeemTransferOutNotPossible is thrown when the protocol has insufficient cash\\n     * @custom:access Not restricted\\n     */\\n    function redeem(uint256 redeemTokens) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        _redeemFresh(msg.sender, redeemTokens, 0);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     */\\n    function redeemUnderlying(uint256 redeemAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        _redeemFresh(msg.sender, 0, redeemAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender borrows assets from the protocol to their own address\\n     * @param borrowAmount The amount of the underlying asset to borrow\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits Borrow event; may emit AccrueInterest\\n     * @custom:error BorrowCashNotAvailable is thrown when the protocol has insufficient cash\\n     * @custom:access Not restricted\\n     */\\n    function borrow(uint256 borrowAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\\n        _borrowFresh(msg.sender, borrowAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay, or type(uint256).max for the full outstanding amount\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function repayBorrow(uint256 repayAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        _repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay, or type(uint256).max for the full outstanding amount\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        // _repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        _repayBorrowFresh(msg.sender, borrower, repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral vToken\\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral vToken\\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\\n     * @custom:access Not restricted\\n     */\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral\\n    ) external override returns (uint256) {\\n        _liquidateBorrow(msg.sender, borrower, repayAmount, vTokenCollateral, false);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice sets protocol share accumulated from liquidations\\n     * @dev must be equal or less than liquidation incentive - 1\\n     * @param newProtocolSeizeShareMantissa_ new protocol share mantissa\\n     * @custom:event Emits NewProtocolSeizeShare event on success\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\n     * @custom:error ProtocolSeizeShareTooBig is thrown when the new seize share is too high\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setProtocolSeizeShare(uint256 newProtocolSeizeShareMantissa_) external {\\n        _checkAccessAllowed(\\\"setProtocolSeizeShare(uint256)\\\");\\n        uint256 liquidationIncentive = ComptrollerViewInterface(address(comptroller)).liquidationIncentiveMantissa();\\n        if (newProtocolSeizeShareMantissa_ + MANTISSA_ONE > liquidationIncentive) {\\n            revert ProtocolSeizeShareTooBig();\\n        }\\n\\n        uint256 oldProtocolSeizeShareMantissa = protocolSeizeShareMantissa;\\n        protocolSeizeShareMantissa = newProtocolSeizeShareMantissa_;\\n        emit NewProtocolSeizeShare(oldProtocolSeizeShareMantissa, newProtocolSeizeShareMantissa_);\\n    }\\n\\n    /**\\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n     * @dev Admin function to accrue interest and set a new reserve factor\\n     * @param newReserveFactorMantissa New reserve factor (from 0 to 1e18)\\n     * @custom:event Emits NewReserveFactor event; may emit AccrueInterest\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\n     * @custom:error SetReserveFactorBoundsCheck is thrown when the new reserve factor is too high\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setReserveFactor(uint256 newReserveFactorMantissa) external override nonReentrant {\\n        _checkAccessAllowed(\\\"setReserveFactor(uint256)\\\");\\n\\n        accrueInterest();\\n        _setReserveFactorFresh(newReserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring to the protocol reserve contract\\n     * @dev Gracefully return if reserves already reduced in accrueInterest\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @custom:event Emits ReservesReduced event; may emit AccrueInterest\\n     * @custom:error ReduceReservesCashNotAvailable is thrown when the vToken does not have sufficient cash\\n     * @custom:error ReduceReservesCashValidation is thrown when trying to withdraw more cash than the reserves have\\n     * @custom:access Not restricted\\n     */\\n    function reduceReserves(uint256 reduceAmount) external override nonReentrant {\\n        accrueInterest();\\n        if (reduceReservesBlockNumber == _getBlockNumber()) return;\\n        _reduceReservesFresh(reduceAmount);\\n    }\\n\\n    /**\\n     * @notice The sender adds to reserves.\\n     * @param addAmount The amount of underlying token to add as reserves\\n     * @custom:event Emits ReservesAdded event; may emit AccrueInterest\\n     * @custom:access Not restricted\\n     */\\n    function addReserves(uint256 addAmount) external override nonReentrant {\\n        accrueInterest();\\n        _addReservesFresh(addAmount);\\n    }\\n\\n    /**\\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n     * @dev Admin function to accrue interest and update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @custom:event Emits NewMarketInterestRateModel event; may emit AccrueInterest\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\n     * @custom:access Controlled by AccessControlManager\\n     */\\n    function setInterestRateModel(InterestRateModel newInterestRateModel) external override {\\n        _checkAccessAllowed(\\\"setInterestRateModel(address)\\\");\\n\\n        accrueInterest();\\n        _setInterestRateModelFresh(newInterestRateModel);\\n    }\\n\\n    /**\\n     * @notice Repays a certain amount of debt, treats the rest of the borrow as bad debt, essentially\\n     *   \\\"forgiving\\\" the borrower. Healing is a situation that should rarely happen. However, some pools\\n     *   may list risky assets or be configured improperly \u2013 we want to still handle such cases gracefully.\\n     *   We assume that Comptroller does the seizing, so this function is only available to Comptroller.\\n     * @dev This function does not call any Comptroller hooks (like \\\"healAllowed\\\"), because we assume\\n     *   the Comptroller does all the necessary checks before calling this function.\\n     * @param payer account who repays the debt\\n     * @param borrower account to heal\\n     * @param repayAmount amount to repay\\n     * @custom:event Emits RepayBorrow, BadDebtIncreased events; may emit AccrueInterest\\n     * @custom:error HealBorrowUnauthorized is thrown when the request does not come from Comptroller\\n     * @custom:access Only Comptroller\\n     */\\n    function healBorrow(address payer, address borrower, uint256 repayAmount) external override nonReentrant {\\n        if (repayAmount != 0) {\\n            comptroller.preRepayHook(address(this), borrower);\\n        }\\n\\n        if (msg.sender != address(comptroller)) {\\n            revert HealBorrowUnauthorized();\\n        }\\n\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\n        uint256 totalBorrowsNew = totalBorrows;\\n\\n        uint256 actualRepayAmount;\\n        if (repayAmount != 0) {\\n            // _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n            // We violate checks-effects-interactions here to account for tokens that take transfer fees\\n            actualRepayAmount = _doTransferIn(payer, repayAmount);\\n            totalBorrowsNew = totalBorrowsNew - actualRepayAmount;\\n            emit RepayBorrow(\\n                payer,\\n                borrower,\\n                actualRepayAmount,\\n                accountBorrowsPrev - actualRepayAmount,\\n                totalBorrowsNew\\n            );\\n        }\\n\\n        // The transaction will fail if trying to repay too much\\n        uint256 badDebtDelta = accountBorrowsPrev - actualRepayAmount;\\n        if (badDebtDelta != 0) {\\n            uint256 badDebtOld = badDebt;\\n            uint256 badDebtNew = badDebtOld + badDebtDelta;\\n            totalBorrowsNew = totalBorrowsNew - badDebtDelta;\\n            badDebt = badDebtNew;\\n\\n            // We treat healing as \\\"repayment\\\", where vToken is the payer\\n            emit RepayBorrow(address(this), borrower, badDebtDelta, 0, totalBorrowsNew);\\n            emit BadDebtIncreased(borrower, badDebtDelta, badDebtOld, badDebtNew);\\n        }\\n\\n        accountBorrows[borrower].principal = 0;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        emit HealBorrow(payer, borrower, repayAmount);\\n    }\\n\\n    /**\\n     * @notice The extended version of liquidations, callable only by Comptroller. May skip\\n     *  the close factor check. The collateral seized is transferred to the liquidator.\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\n     *   regardless of the account liquidity\\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\\n     * @custom:error ForceLiquidateBorrowUnauthorized is thrown when the request does not come from Comptroller\\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral vToken\\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral vToken\\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\\n     * @custom:access Only Comptroller\\n     */\\n    function forceLiquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipLiquidityCheck\\n    ) external override {\\n        if (msg.sender != address(comptroller)) {\\n            revert ForceLiquidateBorrowUnauthorized();\\n        }\\n        _liquidateBorrow(liquidator, borrower, repayAmount, vTokenCollateral, skipLiquidityCheck);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Will fail unless called by another vToken during the process of liquidation.\\n     *  It's absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of vTokens to seize\\n     * @custom:event Emits Transfer, ReservesAdded events\\n     * @custom:error LiquidateSeizeLiquidatorIsBorrower is thrown when trying to liquidate self\\n     * @custom:access Not restricted\\n     */\\n    function seize(address liquidator, address borrower, uint256 seizeTokens) external override nonReentrant {\\n        _seize(msg.sender, liquidator, borrower, seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Updates bad debt\\n     * @dev Called only when bad debt is recovered from auction\\n     * @param recoveredAmount_ The amount of bad debt recovered\\n     * @custom:event Emits BadDebtRecovered event\\n     * @custom:access Only Shortfall contract\\n     */\\n    function badDebtRecovered(uint256 recoveredAmount_) external {\\n        require(msg.sender == shortfall, \\\"only shortfall contract can update bad debt\\\");\\n        require(recoveredAmount_ <= badDebt, \\\"more than bad debt recovered from auction\\\");\\n\\n        uint256 badDebtOld = badDebt;\\n        uint256 badDebtNew = badDebtOld - recoveredAmount_;\\n        badDebt = badDebtNew;\\n\\n        emit BadDebtRecovered(badDebtOld, badDebtNew);\\n    }\\n\\n    /**\\n     * @notice Sets protocol share reserve contract address\\n     * @param protocolShareReserve_ The address of the protocol share reserve contract\\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\\n     * @custom:access Only Governance\\n     */\\n    function setProtocolShareReserve(address payable protocolShareReserve_) external onlyOwner {\\n        _setProtocolShareReserve(protocolShareReserve_);\\n    }\\n\\n    /**\\n     * @notice Sets shortfall contract address\\n     * @param shortfall_ The address of the shortfall contract\\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\\n     * @custom:access Only Governance\\n     */\\n    function setShortfallContract(address shortfall_) external onlyOwner {\\n        _setShortfallContract(shortfall_);\\n    }\\n\\n    /**\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\n     * @param token The address of the ERC-20 token to sweep\\n     * @custom:access Only Governance\\n     */\\n    function sweepToken(IERC20Upgradeable token) external override {\\n        require(msg.sender == owner(), \\\"VToken::sweepToken: only admin can sweep tokens\\\");\\n        require(address(token) != underlying, \\\"VToken::sweepToken: can not sweep underlying token\\\");\\n        uint256 balance = token.balanceOf(address(this));\\n        token.safeTransfer(owner(), balance);\\n\\n        emit SweepToken(address(token));\\n    }\\n\\n    /**\\n     * @notice A public function to set new threshold of block difference after which funds will be sent to the protocol share reserve\\n     * @param _newReduceReservesBlockDelta block difference value\\n     * @custom:access Only Governance\\n     */\\n    function setReduceReservesBlockDelta(uint256 _newReduceReservesBlockDelta) external {\\n        _checkAccessAllowed(\\\"setReduceReservesBlockDelta(uint256)\\\");\\n        require(_newReduceReservesBlockDelta > 0, \\\"Invalid Input\\\");\\n        emit NewReduceReservesBlockDelta(reduceReservesBlockDelta, _newReduceReservesBlockDelta);\\n        reduceReservesBlockDelta = _newReduceReservesBlockDelta;\\n    }\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return amount The number of tokens allowed to be spent (type(uint256).max means infinite)\\n     */\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        return transferAllowances[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Get the token balance of the `owner`\\n     * @param owner The address of the account to query\\n     * @return amount The number of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) external view override returns (uint256) {\\n        return accountTokens[owner];\\n    }\\n\\n    /**\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\n     * @param account Address of the account to snapshot\\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\\n     * @return vTokenBalance User's balance of vTokens\\n     * @return borrowBalance Amount owed in terms of underlying\\n     * @return exchangeRate Stored exchange rate\\n     */\\n    function getAccountSnapshot(\\n        address account\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 error, uint256 vTokenBalance, uint256 borrowBalance, uint256 exchangeRate)\\n    {\\n        return (NO_ERROR, accountTokens[account], _borrowBalanceStored(account), _exchangeRateStored());\\n    }\\n\\n    /**\\n     * @notice Get cash balance of this vToken in the underlying asset\\n     * @return cash The quantity of underlying asset owned by this contract\\n     */\\n    function getCash() external view override returns (uint256) {\\n        return _getCashPrior();\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block borrow interest rate for this vToken\\n     * @return rate The borrow interest rate per block, scaled by 1e18\\n     */\\n    function borrowRatePerBlock() external view override returns (uint256) {\\n        return interestRateModel.getBorrowRate(_getCashPrior(), totalBorrows, totalReserves, badDebt);\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block supply interest rate for this v\\n     * @return rate The supply interest rate per block, scaled by 1e18\\n     */\\n    function supplyRatePerBlock() external view override returns (uint256) {\\n        return\\n            interestRateModel.getSupplyRate(\\n                _getCashPrior(),\\n                totalBorrows,\\n                totalReserves,\\n                reserveFactorMantissa,\\n                badDebt\\n            );\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return borrowBalance The calculated balance\\n     */\\n    function borrowBalanceStored(address account) external view override returns (uint256) {\\n        return _borrowBalanceStored(account);\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the VToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStored() external view override returns (uint256) {\\n        return _exchangeRateStored();\\n    }\\n\\n    /**\\n     * @notice Accrue interest then return the up-to-date exchange rate\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateCurrent() public override nonReentrant returns (uint256) {\\n        accrueInterest();\\n        return _exchangeRateStored();\\n    }\\n\\n    /**\\n     * @notice Applies accrued interest to total borrows and reserves\\n     * @dev This calculates interest accrued from the last checkpointed block\\n     *  up to the current block and writes new checkpoint to storage and\\n     *  reduce spread reserves to protocol share reserve\\n     *  if currentBlock - reduceReservesBlockNumber >= blockDelta\\n     * @return Always NO_ERROR\\n     * @custom:event Emits AccrueInterest event on success\\n     * @custom:access Not restricted\\n     */\\n    function accrueInterest() public virtual override returns (uint256) {\\n        /* Remember the initial block number */\\n        uint256 currentBlockNumber = _getBlockNumber();\\n        uint256 accrualBlockNumberPrior = accrualBlockNumber;\\n\\n        /* Short-circuit accumulating 0 interest */\\n        if (accrualBlockNumberPrior == currentBlockNumber) {\\n            return NO_ERROR;\\n        }\\n\\n        /* Read the previous values out of storage */\\n        uint256 cashPrior = _getCashPrior();\\n        uint256 borrowsPrior = totalBorrows;\\n        uint256 reservesPrior = totalReserves;\\n        uint256 borrowIndexPrior = borrowIndex;\\n\\n        /* Calculate the current borrow interest rate */\\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior, badDebt);\\n        require(borrowRateMantissa <= MAX_BORROW_RATE_MANTISSA, \\\"borrow rate is absurdly high\\\");\\n\\n        /* Calculate the number of blocks elapsed since the last accrual */\\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumberPrior;\\n\\n        /*\\n         * Calculate the interest accumulated into borrows and reserves and the new index:\\n         *  simpleInterestFactor = borrowRate * blockDelta\\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\n         */\\n\\n        Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\\n        uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\\n        uint256 totalBorrowsNew = interestAccumulated + borrowsPrior;\\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\\n            Exp({ mantissa: reserveFactorMantissa }),\\n            interestAccumulated,\\n            reservesPrior\\n        );\\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the previously calculated values into storage */\\n        accrualBlockNumber = currentBlockNumber;\\n        borrowIndex = borrowIndexNew;\\n        totalBorrows = totalBorrowsNew;\\n        totalReserves = totalReservesNew;\\n\\n        if (currentBlockNumber - reduceReservesBlockNumber >= reduceReservesBlockDelta) {\\n            reduceReservesBlockNumber = currentBlockNumber;\\n            _reduceReservesFresh(totalReservesNew);\\n        }\\n\\n        /* We emit an AccrueInterest event */\\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice User supplies assets into the market and receives vTokens in exchange\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param payer The address of the account which is sending the assets for supply\\n     * @param minter The address of the account which is supplying the assets\\n     * @param mintAmount The amount of the underlying asset to supply\\n     */\\n    function _mintFresh(address payer, address minter, uint256 mintAmount) internal {\\n        /* Fail if mint not allowed */\\n        comptroller.preMintHook(address(this), minter, mintAmount);\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert MintFreshnessCheck();\\n        }\\n\\n        Exp memory exchangeRate = Exp({ mantissa: _exchangeRateStored() });\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         *  We call `_doTransferIn` for the minter and the mintAmount.\\n         *  `_doTransferIn` reverts if anything goes wrong, since we can't be sure if\\n         *  side-effects occurred. The function returns the amount actually transferred,\\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\\n         *  of cash.\\n         */\\n        uint256 actualMintAmount = _doTransferIn(payer, mintAmount);\\n\\n        /*\\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\\n         *  mintTokens = actualMintAmount / exchangeRate\\n         */\\n\\n        uint256 mintTokens = div_(actualMintAmount, exchangeRate);\\n\\n        /*\\n         * We calculate the new total supply of vTokens and minter token balance, checking for overflow:\\n         *  totalSupplyNew = totalSupply + mintTokens\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\n         * And write them into storage\\n         */\\n        totalSupply = totalSupply + mintTokens;\\n        uint256 balanceAfter = accountTokens[minter] + mintTokens;\\n        accountTokens[minter] = balanceAfter;\\n\\n        /* We emit a Mint event, and a Transfer event */\\n        emit Mint(minter, actualMintAmount, mintTokens, balanceAfter);\\n        emit Transfer(address(0), minter, mintTokens);\\n    }\\n\\n    /**\\n     * @notice User redeems vTokens in exchange for the underlying asset\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param redeemer The address of the account which is redeeming the tokens\\n     * @param redeemTokensIn The number of vTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming vTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     */\\n    function _redeemFresh(address redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn) internal {\\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"one of redeemTokensIn or redeemAmountIn must be zero\\\");\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert RedeemFreshnessCheck();\\n        }\\n\\n        /* exchangeRate = invoke Exchange Rate Stored() */\\n        Exp memory exchangeRate = Exp({ mantissa: _exchangeRateStored() });\\n\\n        uint256 redeemTokens;\\n        uint256 redeemAmount;\\n\\n        /* If redeemTokensIn > 0: */\\n        if (redeemTokensIn > 0) {\\n            /*\\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\\n             *  redeemTokens = redeemTokensIn\\n             */\\n            redeemTokens = redeemTokensIn;\\n        } else {\\n            /*\\n             * We get the current exchange rate and calculate the amount to be redeemed:\\n             *  redeemTokens = redeemAmountIn / exchangeRate\\n             */\\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\\n\\n            uint256 _redeemAmount = mul_(redeemTokens, exchangeRate);\\n            if (_redeemAmount != 0 && _redeemAmount != redeemAmountIn) redeemTokens++; // round up\\n        }\\n\\n        // redeemAmount = exchangeRate * redeemTokens\\n        redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokens);\\n\\n        // Revert if amount is zero\\n        if (redeemAmount == 0) {\\n            revert(\\\"redeemAmount is zero\\\");\\n        }\\n\\n        /* Fail if redeem not allowed */\\n        comptroller.preRedeemHook(address(this), redeemer, redeemTokens);\\n\\n        /* Fail gracefully if protocol has insufficient cash */\\n        if (_getCashPrior() - totalReserves < redeemAmount) {\\n            revert RedeemTransferOutNotPossible();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\\n         */\\n        totalSupply = totalSupply - redeemTokens;\\n        uint256 balanceAfter = accountTokens[redeemer] - redeemTokens;\\n        accountTokens[redeemer] = balanceAfter;\\n\\n        /*\\n         * We invoke _doTransferOut for the redeemer and the redeemAmount.\\n         *  On success, the vToken has redeemAmount less of cash.\\n         *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        _doTransferOut(redeemer, redeemAmount);\\n\\n        /* We emit a Transfer event, and a Redeem event */\\n        emit Transfer(redeemer, address(this), redeemTokens);\\n        emit Redeem(redeemer, redeemAmount, redeemTokens, balanceAfter);\\n    }\\n\\n    /**\\n     * @notice Users borrow assets from the protocol to their own address\\n     * @param borrower User who borrows the assets\\n     * @param borrowAmount The amount of the underlying asset to borrow\\n     */\\n    function _borrowFresh(address borrower, uint256 borrowAmount) internal {\\n        /* Fail if borrow not allowed */\\n        comptroller.preBorrowHook(address(this), borrower, borrowAmount);\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert BorrowFreshnessCheck();\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient underlying cash */\\n        if (_getCashPrior() - totalReserves < borrowAmount) {\\n            revert BorrowCashNotAvailable();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on overflow:\\n         *  accountBorrowNew = accountBorrow + borrowAmount\\n         *  totalBorrowsNew = totalBorrows + borrowAmount\\n         */\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\n        uint256 accountBorrowsNew = accountBorrowsPrev + borrowAmount;\\n        uint256 totalBorrowsNew = totalBorrows + borrowAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\\n        `*/\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /*\\n         * We invoke _doTransferOut for the borrower and the borrowAmount.\\n         *  On success, the vToken borrowAmount less of cash.\\n         *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        _doTransferOut(borrower, borrowAmount);\\n\\n        /* We emit a Borrow event */\\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\\n    }\\n\\n    /**\\n     * @notice Borrows are repaid by another user (possibly the borrower).\\n     * @param payer the account paying off the borrow\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount the amount of underlying tokens being returned, or type(uint256).max for the full outstanding amount\\n     * @return (uint) the actual repayment amount.\\n     */\\n    function _repayBorrowFresh(address payer, address borrower, uint256 repayAmount) internal returns (uint256) {\\n        /* Fail if repayBorrow not allowed */\\n        comptroller.preRepayHook(address(this), borrower);\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert RepayBorrowFreshnessCheck();\\n        }\\n\\n        /* We fetch the amount the borrower owes, with accumulated interest */\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\n\\n        uint256 repayAmountFinal = repayAmount >= accountBorrowsPrev ? accountBorrowsPrev : repayAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call _doTransferIn for the payer and the repayAmount\\n         *  On success, the vToken holds an additional repayAmount of cash.\\n         *  _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *   it returns the amount actually transferred, in case of a fee.\\n         */\\n        uint256 actualRepayAmount = _doTransferIn(payer, repayAmountFinal);\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on underflow:\\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\\n         */\\n        uint256 accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\\n        uint256 totalBorrowsNew = totalBorrows - actualRepayAmount;\\n\\n        /* We write the previously calculated values into storage */\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /* We emit a RepayBorrow event */\\n        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\\n\\n        return actualRepayAmount;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\n     *   regardless of the account liquidity\\n     */\\n    function _liquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipLiquidityCheck\\n    ) internal nonReentrant {\\n        accrueInterest();\\n\\n        uint256 error = vTokenCollateral.accrueInterest();\\n        if (error != NO_ERROR) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n            revert LiquidateAccrueCollateralInterestFailed(error);\\n        }\\n\\n        // _liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\n        _liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral, skipLiquidityCheck);\\n    }\\n\\n    /**\\n     * @notice The liquidator liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param borrower The borrower of this vToken to be liquidated\\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\n     *   regardless of the account liquidity\\n     */\\n    function _liquidateBorrowFresh(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipLiquidityCheck\\n    ) internal {\\n        /* Fail if liquidate not allowed */\\n        comptroller.preLiquidateHook(\\n            address(this),\\n            address(vTokenCollateral),\\n            borrower,\\n            repayAmount,\\n            skipLiquidityCheck\\n        );\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert LiquidateFreshnessCheck();\\n        }\\n\\n        /* Verify vTokenCollateral market's block number equals current block number */\\n        if (vTokenCollateral.accrualBlockNumber() != _getBlockNumber()) {\\n            revert LiquidateCollateralFreshnessCheck();\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateLiquidatorIsBorrower();\\n        }\\n\\n        /* Fail if repayAmount = 0 */\\n        if (repayAmount == 0) {\\n            revert LiquidateCloseAmountIsZero();\\n        }\\n\\n        /* Fail if repayAmount = type(uint256).max */\\n        if (repayAmount == type(uint256).max) {\\n            revert LiquidateCloseAmountIsUintMax();\\n        }\\n\\n        /* Fail if repayBorrow fails */\\n        uint256 actualRepayAmount = _repayBorrowFresh(liquidator, borrower, repayAmount);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We calculate the number of collateral tokens that will be seized */\\n        (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\\n            address(this),\\n            address(vTokenCollateral),\\n            actualRepayAmount\\n        );\\n        require(amountSeizeError == NO_ERROR, \\\"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\\\");\\n\\n        /* Revert if borrower collateral token balance < seizeTokens */\\n        require(vTokenCollateral.balanceOf(borrower) >= seizeTokens, \\\"LIQUIDATE_SEIZE_TOO_MUCH\\\");\\n\\n        // If this is also the collateral, call _seize internally to avoid re-entrancy, otherwise make an external call\\n        if (address(vTokenCollateral) == address(this)) {\\n            _seize(address(this), liquidator, borrower, seizeTokens);\\n        } else {\\n            vTokenCollateral.seize(liquidator, borrower, seizeTokens);\\n        }\\n\\n        /* We emit a LiquidateBorrow event */\\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(vTokenCollateral), seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another VToken.\\n     *  It's absolutely critical to use msg.sender as the seizer vToken and not a parameter.\\n     * @param seizerContract The contract seizing the collateral (either borrowed vToken or Comptroller)\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of vTokens to seize\\n     */\\n    function _seize(address seizerContract, address liquidator, address borrower, uint256 seizeTokens) internal {\\n        /* Fail if seize not allowed */\\n        comptroller.preSeizeHook(address(this), seizerContract, liquidator, borrower);\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateSeizeLiquidatorIsBorrower();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\n         */\\n        uint256 liquidationIncentiveMantissa = ComptrollerViewInterface(address(comptroller))\\n            .liquidationIncentiveMantissa();\\n        uint256 numerator = mul_(seizeTokens, Exp({ mantissa: protocolSeizeShareMantissa }));\\n        uint256 protocolSeizeTokens = div_(numerator, Exp({ mantissa: liquidationIncentiveMantissa }));\\n        uint256 liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\\n        Exp memory exchangeRate = Exp({ mantissa: _exchangeRateStored() });\\n        uint256 protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the calculated values into storage */\\n        totalSupply = totalSupply - protocolSeizeTokens;\\n        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\\n        accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\\n\\n        // _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n        // Transferring an underlying asset to the protocolShareReserve contract to channel the funds for different use.\\n        _doTransferOut(protocolShareReserve, protocolSeizeAmount);\\n\\n        // Update the pool asset's state in the protocol share reserve for the above transfer.\\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\\n            address(comptroller),\\n            underlying,\\n            IProtocolShareReserve.IncomeType.LIQUIDATION\\n        );\\n\\n        /* Emit a Transfer event */\\n        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\\n        emit ProtocolSeize(borrower, protocolShareReserve, protocolSeizeAmount);\\n    }\\n\\n    function _setComptroller(ComptrollerInterface newComptroller) internal {\\n        ComptrollerInterface oldComptroller = comptroller;\\n        // Ensure invoke comptroller.isComptroller() returns true\\n        require(newComptroller.isComptroller(), \\\"marker method returned false\\\");\\n\\n        // Set market's comptroller to newComptroller\\n        comptroller = newComptroller;\\n\\n        // Emit NewComptroller(oldComptroller, newComptroller)\\n        emit NewComptroller(oldComptroller, newComptroller);\\n    }\\n\\n    /**\\n     * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\n     * @dev Admin function to set a new reserve factor\\n     * @param newReserveFactorMantissa New reserve factor (from 0 to 1e18)\\n     */\\n    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal {\\n        // Verify market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert SetReserveFactorFreshCheck();\\n        }\\n\\n        // Check newReserveFactor \u2264 maxReserveFactor\\n        if (newReserveFactorMantissa > MAX_RESERVE_FACTOR_MANTISSA) {\\n            revert SetReserveFactorBoundsCheck();\\n        }\\n\\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\\n        reserveFactorMantissa = newReserveFactorMantissa;\\n\\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Add reserves by transferring from caller\\n     * @dev Requires fresh interest accrual\\n     * @param addAmount Amount of addition to reserves\\n     * @return actualAddAmount The actual amount added, excluding the potential token fees\\n     */\\n    function _addReservesFresh(uint256 addAmount) internal returns (uint256) {\\n        // totalReserves + actualAddAmount\\n        uint256 totalReservesNew;\\n        uint256 actualAddAmount;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert AddReservesFactorFreshCheck(actualAddAmount);\\n        }\\n\\n        actualAddAmount = _doTransferIn(msg.sender, addAmount);\\n        totalReservesNew = totalReserves + actualAddAmount;\\n        totalReserves = totalReservesNew;\\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\n\\n        return actualAddAmount;\\n    }\\n\\n    /**\\n     * @notice Reduces reserves by transferring to the protocol reserve contract\\n     * @dev Requires fresh interest accrual\\n     * @param reduceAmount Amount of reduction to reserves\\n     */\\n    function _reduceReservesFresh(uint256 reduceAmount) internal {\\n        if (reduceAmount == 0) {\\n            return;\\n        }\\n        // totalReserves - reduceAmount\\n        uint256 totalReservesNew;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert ReduceReservesFreshCheck();\\n        }\\n\\n        // Fail gracefully if protocol has insufficient underlying cash\\n        if (_getCashPrior() < reduceAmount) {\\n            revert ReduceReservesCashNotAvailable();\\n        }\\n\\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\\n        if (reduceAmount > totalReserves) {\\n            revert ReduceReservesCashValidation();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        totalReservesNew = totalReserves - reduceAmount;\\n\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\n        totalReserves = totalReservesNew;\\n\\n        // _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n        // Transferring an underlying asset to the protocolShareReserve contract to channel the funds for different use.\\n        _doTransferOut(protocolShareReserve, reduceAmount);\\n\\n        // Update the pool asset's state in the protocol share reserve for the above transfer.\\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\\n            address(comptroller),\\n            underlying,\\n            IProtocolShareReserve.IncomeType.SPREAD\\n        );\\n\\n        emit SpreadReservesReduced(protocolShareReserve, reduceAmount, totalReservesNew);\\n    }\\n\\n    /**\\n     * @notice updates the interest rate model (*requires fresh interest accrual)\\n     * @dev Admin function to update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     */\\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal {\\n        // Used to store old model for use in the event that is emitted on success\\n        InterestRateModel oldInterestRateModel;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != _getBlockNumber()) {\\n            revert SetInterestRateModelFreshCheck();\\n        }\\n\\n        // Track the market's current interest rate model\\n        oldInterestRateModel = interestRateModel;\\n\\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\n        require(newInterestRateModel.isInterestRateModel(), \\\"marker method returned false\\\");\\n\\n        // Set the interest rate model to newInterestRateModel\\n        interestRateModel = newInterestRateModel;\\n\\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\\n    }\\n\\n    /**\\n     * Safe Token **\\n     */\\n\\n    /**\\n     * @dev Similar to ERC-20 transfer, but handles tokens that have transfer fees.\\n     *      This function returns the actual amount received,\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\n     * @param from Sender of the underlying tokens\\n     * @param amount Amount of underlying to transfer\\n     * @return Actual amount received\\n     */\\n    function _doTransferIn(address from, uint256 amount) internal virtual returns (uint256) {\\n        IERC20Upgradeable token = IERC20Upgradeable(underlying);\\n        uint256 balanceBefore = token.balanceOf(address(this));\\n        token.safeTransferFrom(from, address(this), amount);\\n        uint256 balanceAfter = token.balanceOf(address(this));\\n        // Return the amount that was *actually* transferred\\n        return balanceAfter - balanceBefore;\\n    }\\n\\n    /**\\n     * @dev Just a regular ERC-20 transfer, reverts on failure\\n     * @param to Receiver of the underlying tokens\\n     * @param amount Amount of underlying to transfer\\n     */\\n    function _doTransferOut(address to, uint256 amount) internal virtual {\\n        IERC20Upgradeable token = IERC20Upgradeable(underlying);\\n        token.safeTransfer(to, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\n     * @dev Called by both `transfer` and `transferFrom` internally\\n     * @param spender The address of the account performing the transfer\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param tokens The number of tokens to transfer\\n     */\\n    function _transferTokens(address spender, address src, address dst, uint256 tokens) internal {\\n        /* Fail if transfer not allowed */\\n        comptroller.preTransferHook(address(this), src, dst, tokens);\\n\\n        /* Do not allow self-transfers */\\n        if (src == dst) {\\n            revert TransferNotAllowed();\\n        }\\n\\n        /* Get the allowance, infinite for the account owner */\\n        uint256 startingAllowance;\\n        if (spender == src) {\\n            startingAllowance = type(uint256).max;\\n        } else {\\n            startingAllowance = transferAllowances[src][spender];\\n        }\\n\\n        /* Do the calculations, checking for {under,over}flow */\\n        uint256 allowanceNew = startingAllowance - tokens;\\n        uint256 srcTokensNew = accountTokens[src] - tokens;\\n        uint256 dstTokensNew = accountTokens[dst] + tokens;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n\\n        accountTokens[src] = srcTokensNew;\\n        accountTokens[dst] = dstTokensNew;\\n\\n        /* Eat some of the allowance (if necessary) */\\n        if (startingAllowance != type(uint256).max) {\\n            transferAllowances[src][spender] = allowanceNew;\\n        }\\n\\n        /* We emit a Transfer event */\\n        emit Transfer(src, dst, tokens);\\n    }\\n\\n    /**\\n     * @notice Initialize the money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param admin_ Address of the administrator of this token\\n     * @param accessControlManager_ AccessControlManager contract address\\n     * @param riskManagement Addresses of risk & income related contracts\\n     * @param reserveFactorMantissa_ Percentage of borrow interest that goes to reserves (from 0 to 1e18)\\n     */\\n    function _initialize(\\n        address underlying_,\\n        ComptrollerInterface comptroller_,\\n        InterestRateModel interestRateModel_,\\n        uint256 initialExchangeRateMantissa_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        address admin_,\\n        address accessControlManager_,\\n        RiskManagementInit memory riskManagement,\\n        uint256 reserveFactorMantissa_\\n    ) internal onlyInitializing {\\n        __Ownable2Step_init();\\n        __AccessControlled_init_unchained(accessControlManager_);\\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"market may only be initialized once\\\");\\n\\n        // Set initial exchange rate\\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\\n        require(initialExchangeRateMantissa > 0, \\\"initial exchange rate must be greater than zero.\\\");\\n\\n        _setComptroller(comptroller_);\\n\\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\n        accrualBlockNumber = _getBlockNumber();\\n        borrowIndex = MANTISSA_ONE;\\n\\n        // Set the interest rate model (depends on block number / borrow index)\\n        _setInterestRateModelFresh(interestRateModel_);\\n\\n        _setReserveFactorFresh(reserveFactorMantissa_);\\n\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n        _setShortfallContract(riskManagement.shortfall);\\n        _setProtocolShareReserve(riskManagement.protocolShareReserve);\\n        protocolSeizeShareMantissa = DEFAULT_PROTOCOL_SEIZE_SHARE_MANTISSA;\\n\\n        // Set underlying and sanity check it\\n        underlying = underlying_;\\n        IERC20Upgradeable(underlying).totalSupply();\\n\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\n        _notEntered = true;\\n        _transferOwnership(admin_);\\n    }\\n\\n    function _setShortfallContract(address shortfall_) internal {\\n        ensureNonzeroAddress(shortfall_);\\n        address oldShortfall = shortfall;\\n        shortfall = shortfall_;\\n        emit NewShortfallContract(oldShortfall, shortfall_);\\n    }\\n\\n    function _setProtocolShareReserve(address payable protocolShareReserve_) internal {\\n        ensureNonzeroAddress(protocolShareReserve_);\\n        address oldProtocolShareReserve = address(protocolShareReserve);\\n        protocolShareReserve = protocolShareReserve_;\\n        emit NewProtocolShareReserve(oldProtocolShareReserve, address(protocolShareReserve_));\\n    }\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying tokens owned by this contract\\n     */\\n    function _getCashPrior() internal view virtual returns (uint256) {\\n        return IERC20Upgradeable(underlying).balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Function to simply retrieve block number\\n     *  This exists mainly for inheriting test contracts to stub this result.\\n     * @return Current block number\\n     */\\n    function _getBlockNumber() internal view virtual returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return borrowBalance the calculated balance\\n     */\\n    function _borrowBalanceStored(address account) internal view returns (uint256) {\\n        /* Get borrowBalance and borrowIndex */\\n        BorrowSnapshot memory borrowSnapshot = accountBorrows[account];\\n\\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\n         */\\n        if (borrowSnapshot.principal == 0) {\\n            return 0;\\n        }\\n\\n        /* Calculate new borrow balance using the interest index:\\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\n         */\\n        uint256 principalTimesIndex = borrowSnapshot.principal * borrowIndex;\\n\\n        return principalTimesIndex / borrowSnapshot.interestIndex;\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the VToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\n     */\\n    function _exchangeRateStored() internal view virtual returns (uint256) {\\n        uint256 _totalSupply = totalSupply;\\n        if (_totalSupply == 0) {\\n            /*\\n             * If there are no tokens minted:\\n             *  exchangeRate = initialExchangeRate\\n             */\\n            return initialExchangeRateMantissa;\\n        }\\n        /*\\n         * Otherwise:\\n         *  exchangeRate = (totalCash + totalBorrows + badDebt - totalReserves) / totalSupply\\n         */\\n        uint256 totalCash = _getCashPrior();\\n        uint256 cashPlusBorrowsMinusReserves = totalCash + totalBorrows + badDebt - totalReserves;\\n        uint256 exchangeRate = (cashPlusBorrowsMinusReserves * EXP_SCALE) / _totalSupply;\\n\\n        return exchangeRate;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/VTokenInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.13;\\n\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport { ResilientOracleInterface } from \\\"@venusprotocol/oracle/contracts/interfaces/OracleInterface.sol\\\";\\n\\nimport { ComptrollerInterface } from \\\"./ComptrollerInterface.sol\\\";\\nimport { InterestRateModel } from \\\"./InterestRateModel.sol\\\";\\n\\n/**\\n * @title VTokenStorage\\n * @author Venus\\n * @notice Storage layout used by the `VToken` contract\\n */\\n// solhint-disable-next-line max-states-count\\ncontract VTokenStorage {\\n    /**\\n     * @notice Container for borrow balance information\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n     */\\n    struct BorrowSnapshot {\\n        uint256 principal;\\n        uint256 interestIndex;\\n    }\\n\\n    /**\\n     * @dev Guard variable for re-entrancy checks\\n     */\\n    bool internal _notEntered;\\n\\n    /**\\n     * @notice Underlying asset for this VToken\\n     */\\n    address public underlying;\\n\\n    /**\\n     * @notice EIP-20 token name for this token\\n     */\\n    string public name;\\n\\n    /**\\n     * @notice EIP-20 token symbol for this token\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @notice EIP-20 token decimals for this token\\n     */\\n    uint8 public decimals;\\n\\n    /**\\n     * @notice Protocol share Reserve contract address\\n     */\\n    address payable public protocolShareReserve;\\n\\n    // Maximum borrow rate that can ever be applied (.0005% / block)\\n    uint256 internal constant MAX_BORROW_RATE_MANTISSA = 0.0005e16;\\n\\n    // Maximum fraction of interest that can be set aside for reserves\\n    uint256 internal constant MAX_RESERVE_FACTOR_MANTISSA = 1e18;\\n\\n    /**\\n     * @notice Contract which oversees inter-vToken operations\\n     */\\n    ComptrollerInterface public comptroller;\\n\\n    /**\\n     * @notice Model which tells what the current interest rate should be\\n     */\\n    InterestRateModel public interestRateModel;\\n\\n    // Initial exchange rate used when minting the first VTokens (used when totalSupply = 0)\\n    uint256 internal initialExchangeRateMantissa;\\n\\n    /**\\n     * @notice Fraction of interest currently set aside for reserves\\n     */\\n    uint256 public reserveFactorMantissa;\\n\\n    /**\\n     * @notice Block number that interest was last accrued at\\n     */\\n    uint256 public accrualBlockNumber;\\n\\n    /**\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\n     */\\n    uint256 public borrowIndex;\\n\\n    /**\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\n     */\\n    uint256 public totalBorrows;\\n\\n    /**\\n     * @notice Total amount of reserves of the underlying held in this market\\n     */\\n    uint256 public totalReserves;\\n\\n    /**\\n     * @notice Total number of tokens in circulation\\n     */\\n    uint256 public totalSupply;\\n\\n    /**\\n     * @notice Total bad debt of the market\\n     */\\n    uint256 public badDebt;\\n\\n    // Official record of token balances for each account\\n    mapping(address => uint256) internal accountTokens;\\n\\n    // Approved token transfer amounts on behalf of others\\n    mapping(address => mapping(address => uint256)) internal transferAllowances;\\n\\n    // Mapping of account addresses to outstanding borrow balances\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\n\\n    /**\\n     * @notice Share of seized collateral that is added to reserves\\n     */\\n    uint256 public protocolSeizeShareMantissa;\\n\\n    /**\\n     * @notice Storage of Shortfall contract address\\n     */\\n    address public shortfall;\\n\\n    /**\\n     * @notice delta block after which reserves will be reduced\\n     */\\n    uint256 public reduceReservesBlockDelta;\\n\\n    /**\\n     * @notice last block number at which reserves were reduced\\n     */\\n    uint256 public reduceReservesBlockNumber;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[48] private __gap;\\n}\\n\\n/**\\n * @title VTokenInterface\\n * @author Venus\\n * @notice Interface implemented by the `VToken` contract\\n */\\nabstract contract VTokenInterface is VTokenStorage {\\n    struct RiskManagementInit {\\n        address shortfall;\\n        address payable protocolShareReserve;\\n    }\\n\\n    /*** Market Events ***/\\n\\n    /**\\n     * @notice Event emitted when interest is accrued\\n     */\\n    event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when tokens are minted\\n     */\\n    event Mint(address indexed minter, uint256 mintAmount, uint256 mintTokens, uint256 accountBalance);\\n\\n    /**\\n     * @notice Event emitted when tokens are redeemed\\n     */\\n    event Redeem(address indexed redeemer, uint256 redeemAmount, uint256 redeemTokens, uint256 accountBalance);\\n\\n    /**\\n     * @notice Event emitted when underlying is borrowed\\n     */\\n    event Borrow(address indexed borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is repaid\\n     */\\n    event RepayBorrow(\\n        address indexed payer,\\n        address indexed borrower,\\n        uint256 repayAmount,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n\\n    /**\\n     * @notice Event emitted when bad debt is accumulated on a market\\n     * @param borrower borrower to \\\"forgive\\\"\\n     * @param badDebtDelta amount of new bad debt recorded\\n     * @param badDebtOld previous bad debt value\\n     * @param badDebtNew new bad debt value\\n     */\\n    event BadDebtIncreased(address indexed borrower, uint256 badDebtDelta, uint256 badDebtOld, uint256 badDebtNew);\\n\\n    /**\\n     * @notice Event emitted when bad debt is recovered via an auction\\n     * @param badDebtOld previous bad debt value\\n     * @param badDebtNew new bad debt value\\n     */\\n    event BadDebtRecovered(uint256 badDebtOld, uint256 badDebtNew);\\n\\n    /**\\n     * @notice Event emitted when a borrow is liquidated\\n     */\\n    event LiquidateBorrow(\\n        address indexed liquidator,\\n        address indexed borrower,\\n        uint256 repayAmount,\\n        address indexed vTokenCollateral,\\n        uint256 seizeTokens\\n    );\\n\\n    /*** Admin Events ***/\\n\\n    /**\\n     * @notice Event emitted when comptroller is changed\\n     */\\n    event NewComptroller(ComptrollerInterface indexed oldComptroller, ComptrollerInterface indexed newComptroller);\\n\\n    /**\\n     * @notice Event emitted when shortfall contract address is changed\\n     */\\n    event NewShortfallContract(address indexed oldShortfall, address indexed newShortfall);\\n\\n    /**\\n     * @notice Event emitted when protocol share reserve contract address is changed\\n     */\\n    event NewProtocolShareReserve(address indexed oldProtocolShareReserve, address indexed newProtocolShareReserve);\\n\\n    /**\\n     * @notice Event emitted when interestRateModel is changed\\n     */\\n    event NewMarketInterestRateModel(\\n        InterestRateModel indexed oldInterestRateModel,\\n        InterestRateModel indexed newInterestRateModel\\n    );\\n\\n    /**\\n     * @notice Event emitted when protocol seize share is changed\\n     */\\n    event NewProtocolSeizeShare(uint256 oldProtocolSeizeShareMantissa, uint256 newProtocolSeizeShareMantissa);\\n\\n    /**\\n     * @notice Event emitted when the reserve factor is changed\\n     */\\n    event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\\n\\n    /**\\n     * @notice Event emitted when the reserves are added\\n     */\\n    event ReservesAdded(address indexed benefactor, uint256 addAmount, uint256 newTotalReserves);\\n\\n    /**\\n     * @notice Event emitted when the spread reserves are reduced\\n     */\\n    event SpreadReservesReduced(address indexed protocolShareReserve, uint256 reduceAmount, uint256 newTotalReserves);\\n\\n    /**\\n     * @notice EIP20 Transfer event\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /**\\n     * @notice EIP20 Approval event\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /**\\n     * @notice Event emitted when healing the borrow\\n     */\\n    event HealBorrow(address indexed payer, address indexed borrower, uint256 repayAmount);\\n\\n    /**\\n     * @notice Event emitted when tokens are swept\\n     */\\n    event SweepToken(address indexed token);\\n\\n    /**\\n     * @notice Event emitted when reduce reserves block delta is changed\\n     */\\n    event NewReduceReservesBlockDelta(uint256 oldReduceReservesBlockDelta, uint256 newReduceReservesBlockDelta);\\n\\n    /**\\n     * @notice Event emitted when liquidation reserves are reduced\\n     */\\n    event ProtocolSeize(address indexed from, address indexed to, uint256 amount);\\n\\n    /*** User Interface ***/\\n\\n    function mint(uint256 mintAmount) external virtual returns (uint256);\\n\\n    function mintBehalf(address minter, uint256 mintAllowed) external virtual returns (uint256);\\n\\n    function redeem(uint256 redeemTokens) external virtual returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\\n\\n    function borrow(uint256 borrowAmount) external virtual returns (uint256);\\n\\n    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\\n\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral\\n    ) external virtual returns (uint256);\\n\\n    function healBorrow(address payer, address borrower, uint256 repayAmount) external virtual;\\n\\n    function forceLiquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        VTokenInterface vTokenCollateral,\\n        bool skipCloseFactorCheck\\n    ) external virtual;\\n\\n    function seize(address liquidator, address borrower, uint256 seizeTokens) external virtual;\\n\\n    function transfer(address dst, uint256 amount) external virtual returns (bool);\\n\\n    function transferFrom(address src, address dst, uint256 amount) external virtual returns (bool);\\n\\n    function accrueInterest() external virtual returns (uint256);\\n\\n    function sweepToken(IERC20Upgradeable token) external virtual;\\n\\n    /*** Admin Functions ***/\\n\\n    function setReserveFactor(uint256 newReserveFactorMantissa) external virtual;\\n\\n    function reduceReserves(uint256 reduceAmount) external virtual;\\n\\n    function exchangeRateCurrent() external virtual returns (uint256);\\n\\n    function borrowBalanceCurrent(address account) external virtual returns (uint256);\\n\\n    function setInterestRateModel(InterestRateModel newInterestRateModel) external virtual;\\n\\n    function addReserves(uint256 addAmount) external virtual;\\n\\n    function totalBorrowsCurrent() external virtual returns (uint256);\\n\\n    function balanceOfUnderlying(address owner) external virtual returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external virtual returns (bool);\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool);\\n\\n    function allowance(address owner, address spender) external view virtual returns (uint256);\\n\\n    function balanceOf(address owner) external view virtual returns (uint256);\\n\\n    function getAccountSnapshot(address account) external view virtual returns (uint256, uint256, uint256, uint256);\\n\\n    function borrowRatePerBlock() external view virtual returns (uint256);\\n\\n    function supplyRatePerBlock() external view virtual returns (uint256);\\n\\n    function borrowBalanceStored(address account) external view virtual returns (uint256);\\n\\n    function exchangeRateStored() external view virtual returns (uint256);\\n\\n    function getCash() external view virtual returns (uint256);\\n\\n    /**\\n     * @notice Indicator that this is a VToken contract (for inspection)\\n     * @return Always true\\n     */\\n    function isVToken() external pure virtual returns (bool) {\\n        return true;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualAddAmount\",\"type\":\"uint256\"}],\"name\":\"AddReservesFactorFreshCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowCashNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ForceLiquidateBorrowUnauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HealBorrowUnauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"LiquidateAccrueCollateralInterestFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateCloseAmountIsUintMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateCloseAmountIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateCollateralFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateLiquidatorIsBorrower\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateSeizeLiquidatorIsBorrower\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolSeizeShareTooBig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedeemFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RedeemTransferOutNotPossible\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReduceReservesCashNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReduceReservesCashValidation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReduceReservesFreshCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RepayBorrowFreshnessCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetInterestRateModelFreshCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetReserveFactorBoundsCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetReserveFactorFreshCheck\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"calledContract\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"methodSignature\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cashPrior\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestAccumulated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"AccrueInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"badDebtDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"badDebtOld\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"badDebtNew\",\"type\":\"uint256\"}],\"name\":\"BadDebtIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"badDebtOld\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"badDebtNew\",\"type\":\"uint256\"}],\"name\":\"BadDebtRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"HealBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vTokenCollateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"LiquidateBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBalance\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAccessControlManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAccessControlManager\",\"type\":\"address\"}],\"name\":\"NewAccessControlManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ComptrollerInterface\",\"name\":\"oldComptroller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract ComptrollerInterface\",\"name\":\"newComptroller\",\"type\":\"address\"}],\"name\":\"NewComptroller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract InterestRateModel\",\"name\":\"oldInterestRateModel\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract InterestRateModel\",\"name\":\"newInterestRateModel\",\"type\":\"address\"}],\"name\":\"NewMarketInterestRateModel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldProtocolSeizeShareMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProtocolSeizeShareMantissa\",\"type\":\"uint256\"}],\"name\":\"NewProtocolSeizeShare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldProtocolShareReserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newProtocolShareReserve\",\"type\":\"address\"}],\"name\":\"NewProtocolShareReserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldReduceReservesBlockDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReduceReservesBlockDelta\",\"type\":\"uint256\"}],\"name\":\"NewReduceReservesBlockDelta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldReserveFactorMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReserveFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"NewReserveFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldShortfall\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newShortfall\",\"type\":\"address\"}],\"name\":\"NewShortfallContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProtocolSeize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBalance\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"RepayBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"benefactor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"addAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalReserves\",\"type\":\"uint256\"}],\"name\":\"ReservesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocolShareReserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalReserves\",\"type\":\"uint256\"}],\"name\":\"SpreadReservesReduced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SweepToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NO_ERROR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessControlManager\",\"outputs\":[{\"internalType\":\"contract IAccessControlManagerV8\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrueInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"addAmount\",\"type\":\"uint256\"}],\"name\":\"addReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"badDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recoveredAmount_\",\"type\":\"uint256\"}],\"name\":\"badDebtRecovered\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"borrowBalanceCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"borrowBalanceStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"comptroller\",\"outputs\":[{\"internalType\":\"contract ComptrollerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract VTokenInterface\",\"name\":\"vTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"skipLiquidityCheck\",\"type\":\"bool\"}],\"name\":\"forceLiquidateBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"healBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"contract ComptrollerInterface\",\"name\":\"comptroller_\",\"type\":\"address\"},{\"internalType\":\"contract InterestRateModel\",\"name\":\"interestRateModel_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accessControlManager_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"shortfall\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"protocolShareReserve\",\"type\":\"address\"}],\"internalType\":\"struct VTokenInterface.RiskManagementInit\",\"name\":\"riskManagement\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactorMantissa_\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"contract InterestRateModel\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isVToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract VTokenInterface\",\"name\":\"vTokenCollateral\",\"type\":\"address\"}],\"name\":\"liquidateBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mintBehalf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolSeizeShareMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolShareReserve\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"}],\"name\":\"reduceReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reduceReservesBlockDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reduceReservesBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrowBehalf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"name\":\"seize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accessControlManager_\",\"type\":\"address\"}],\"name\":\"setAccessControlManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract InterestRateModel\",\"name\":\"newInterestRateModel\",\"type\":\"address\"}],\"name\":\"setInterestRateModel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newProtocolSeizeShareMantissa_\",\"type\":\"uint256\"}],\"name\":\"setProtocolSeizeShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"protocolShareReserve_\",\"type\":\"address\"}],\"name\":\"setProtocolShareReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newReduceReservesBlockDelta\",\"type\":\"uint256\"}],\"name\":\"setReduceReservesBlockDelta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReserveFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"setReserveFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shortfall_\",\"type\":\"address\"}],\"name\":\"setShortfallContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shortfall\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrowsCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VToken", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}