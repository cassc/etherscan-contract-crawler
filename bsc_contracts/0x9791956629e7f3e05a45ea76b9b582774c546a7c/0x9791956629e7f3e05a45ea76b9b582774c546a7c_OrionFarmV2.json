{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/base/StakingRewardProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\nimport \\\"../interfaces/IOrionFarmV2.sol\\\";\\n\\ncontract StakingRewardProxy is  Proxy\\n{\\n    address public immutable parentSmart;\\n\\n    constructor()\\n    {\\n        parentSmart=msg.sender;\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n\\n        impl=IOrionFarmV2(parentSmart).libStakingReward();\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20Minimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Minimal ERC20 interface for Uniswap\\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\\ninterface IERC20Minimal {\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals used to get its user representation.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\\n    /// @param recipient The account that will receive the amount transferred\\n    /// @param amount The number of tokens to send from the sender to the recipient\\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the current allowance given to a spender by an owner\\n    /// @param owner The account of the token owner\\n    /// @param spender The account of the token spender\\n    /// @return The current allowance granted by `owner` to `spender`\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\\n    /// @param amount The amount of tokens allowed to be used by `spender`\\n    /// @return Returns true for a successful approval, false for unsuccessful\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\\n    /// @param sender The account from which the transfer will be initiated\\n    /// @param recipient The recipient of the transfer\\n    /// @param amount The amount of the transfer\\n    /// @return Returns true for a successful transfer, false for unsuccessful\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\\n    /// @param value The amount of tokens that were transferred\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\\n    /// @param owner The account that approved spending of its tokens\\n    /// @param spender The account for which the spending allowance was modified\\n    /// @param value The new allowance from the owner to the spender\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOrionFarmV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n\\ninterface IOrionFarmV2\\n{\\n    //Action\\n    function create_lock_period(address pool, uint256 amount, uint256 lock_period) external;\\n    function increase_amount(address pool, uint256 amount) external;\\n    function increase_lock_period(address pool, uint256 new_lock_period) external;\\n    function withdraw(address pool) external;\\n    function claimReward(address pool) external;\\n\\n    function createSmartReward(address pool) external;\\n\\n    //View\\n    function getReward(address pool, address account) external view returns (uint256);\\n    function getBoost(address pool, address account) external view returns (uint256);\\n    function getStake(address pool, address account) external view returns (uint256);\\n    function allStake(address pool) external view returns (uint256);\\n    function lockTimeStart(address pool, address account) external view returns (uint48);\\n    function lockTimePeriod(address pool, address account) external view returns (uint48);\\n\\n    function libStakingReward() external view returns(address);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IOrionVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface IOrionVoting is IStaking\\n{\\n\\n    //admin\\n    function setSmart(address addr, bool bUse) external;\\n    function setRewards(uint64 rewards, uint64 duration) external;\\n    function addPool(address pool) external;\\n    function deletePool(address pool) external;\\n\\n\\n    //user\\n    function vote(address pool, uint256 amount) external;\\n    function voteArr(address[] calldata pools, uint256[] calldata amounts) external;\\n    function unvote(address pool, uint256 amount) external;\\n    function unvoteAll(address account) external;\\n\\n    //smart\\n    function claimReward(address pool, address to, uint256 amount) external;\\n\\n    //vew\\n    function countPool() external view returns (uint256);//number of pools\\n    function poolList(uint256) external view returns (address);//list of pools\\n    function poolIndex(address pool) external view returns (uint256);//whether there is a pool in the list (index numbers starting from 1)\\n    function users(address user) external view returns (uint256);//user votes across all pools\\n    function usersPool(address user,address pool) external view returns (uint256);//user votes by pool\\n    function smarts(address smart) external view returns (bool);//white list of trusted farm contracts\\n\\n    function veORN() external view returns (address);\\n    function ORN() external view returns (address);\\n\\n    function havePool(address account) external view returns (bool);\\n\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n\\ninterface IStaking\\n{\\n    //staking\\n    function getReward(address account) external view returns (uint256);\\n    function getStake(address account) external view returns (uint256);\\n    function allStake() external view returns (uint256);\\n    function rewardRate() external view returns (uint256);\\n    function rateCumulative() external view returns (uint256);\\n    function rateTime() external view returns (uint256);\\n\\n\\n    function getRewardWithdraw(address account) external view returns (uint256);\\n    function getRewardCumulative(address account) external view returns (uint256);\\n    function getRewardCumulativeAll() external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IStakingReward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface IStakingReward is IStaking\\n{\\n    //Action\\n    function stake(address account, uint256 amount, uint256 lock_period) external returns(uint256 reward);\\n    function withdraw(address account) external returns(uint256 reward, uint256 amount);\\n    function claimReward(address account) external returns(uint256 reward);\\n    \\n    function init(address _token) external;\\n\\n    //View\\n    function lockTimeStart(address account) external view returns (uint48);\\n    function lockTimePeriod(address account) external view returns (uint48);\\n    function getBoost(address account) external view returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITWBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface ITWBalance\\n{\\n    struct TWItem\\n    {\\n        // the block timestamp\\n        uint48  timestamp;        \\n        // the amount accumulator, i.e. amount * time elapsed\\n        uint208 amountTW;\\n    }\\n\\n    /// @notice Returns the time weight (TW) amount of tokens in existence.\\n    function totalSupplyTW() external view returns (TWItem memory);\\n\\n    /// @notice Calculates the average aamount of tokens in existence from the specified TW period\\n    function totalSupplyAvg(TWItem memory itemStart) view external returns (uint256);\\n\\n    /// @notice Returns the time weight (TW) balance of a token\\n    /// @param user The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOfTW(address user) external view returns (TWItem memory);\\n    \\n    /// @notice Calculates the average address balance from the specified TW period\\n    function balanceOfAvg(address user, TWItem memory itemStart) view external returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IveORN.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./ITWBalance.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\n\\ninterface IveORN is ITWBalance,IStaking\\n{\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n    function totalSupply(uint256 ts) external view returns (uint256);\\n    function totalSupply0() external view returns (uint256);//balance on start timestamp\\n\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n    function balanceOf(address account, uint256 ts) external view returns (uint256);\\n    function balanceOf0(address account) external view returns (uint256);//balance on start timestamp\\n\\n    function balanceTokenOf(address account) external view  returns (uint256);\\n\\n    /// @notice Returns the number of decimals used to get its user representation.\\n    function decimals() external view returns (uint8);\\n    \\n    function name() pure external returns(string memory);\\n    function symbol() pure external returns(string memory);\\n \\n\\n    function ORN() external view returns (address);\\n\\n    function lockTime(address account) external view returns (uint48);\\n\\n    \\n    //staking ORN\\n    function create_lock(uint256 _value, uint256 _unlock_time) external;\\n    //function deposit_for(address _addr, uint256 _value) external;\\n    function increase_amount(uint256 _value) external;\\n    function increase_unlock_time(uint256 _unlock_time) external;\\n    function increase_unlock_period(uint256 unlock_period) external;\\n    function create_lock_period(uint256 _value, uint256 unlock_period) external;\\n\\n    function withdraw() external;\\n    function claimReward() external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.7;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OrionFarmV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./base/StakingRewardProxy.sol\\\";\\nimport \\\"./interfaces/IStakingReward.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./interfaces/IOrionVoting.sol\\\";\\nimport \\\"./interfaces/IveORN.sol\\\";\\nimport \\\"./interfaces/IOrionFarmV2.sol\\\";\\nimport \\\"./interfaces/IERC20Minimal.sol\\\";\\n\\n\\ncontract OrionFarmV2 is IOrionFarmV2\\n{\\n    using TransferHelper for address;\\n\\n    address public immutable smartVote;\\n    address public immutable libStakingReward;\\n    mapping (address => IStakingReward) public listSmartReward;\\n\\n    event CreateSmartReward(address indexed pool,address smart, uint8 decimals);\\n\\n    constructor(address _smartVote, address _libStakingReward)\\n    {\\n        smartVote=_smartVote;\\n        libStakingReward=_libStakingReward;\\n    }\\n\\n    //external\\n    function createSmartReward(address pool) public\\n    {\\n        if(address(listSmartReward[pool])==address(0))\\n        {\\n            IStakingReward smart = IStakingReward(address(new StakingRewardProxy()));\\n            smart.init(pool);\\n            listSmartReward[pool]=smart;\\n\\n            emit CreateSmartReward(pool, address(smart), IERC20Minimal(pool).decimals());            \\n        }\\n    }\\n\\n\\n    //external by pools\\n    function create_lock_period(address pool, uint256 amount, uint256 lock_period) external\\n    {\\n        _stake(pool, amount, lock_period);\\n    }\\n    \\n    function increase_amount(address pool, uint256 amount) external\\n    {\\n        _stake(pool, amount, 0);\\n    }\\n\\n    function increase_lock_period(address pool, uint256 new_lock_period) external\\n    {\\n        _stake(pool, 0, new_lock_period);\\n    }\\n\\n    function withdraw(address pool) external\\n    {\\n        require(address(listSmartReward[pool]) != address(0),\\\"The pool smart reward has not been created\\\");\\n\\n        (uint256 reward, uint256 amount) = listSmartReward[pool].withdraw(msg.sender);\\n        _sendReward(pool, reward);\\n        if(amount>0)\\n        {\\n            pool.safeTransfer(msg.sender, amount);\\n        }\\n    }\\n\\n    function claimReward(address pool) external\\n    {\\n        require(address(listSmartReward[pool]) != address(0),\\\"The pool smart reward has not been created\\\");\\n\\n        uint256 reward=listSmartReward[pool].claimReward(msg.sender);\\n        _sendReward(pool, reward);\\n    }\\n\\n    //internal\\n    function _stake(address pool, uint256 amount, uint256 lock_period) internal\\n    {\\n        if(address(listSmartReward[pool])==address(0))\\n            createSmartReward(pool);\\n        //require(address(listSmartReward[pool]) != address(0),\\\"The pool smart reward has not been created\\\");\\n\\n        uint256 reward=listSmartReward[pool].stake(msg.sender, amount, lock_period);\\n        _sendReward(pool, reward);\\n        if(amount>0)\\n        {\\n            pool.safeTransferFrom(msg.sender, address(this), amount);\\n        }\\n    }\\n\\n    function _sendReward(address pool, uint256 reward) internal\\n    {\\n        if(reward>0)\\n        {\\n            IOrionVoting(smartVote).claimReward(pool, msg.sender, reward);\\n        }\\n    }\\n\\n    //View\\n    function getReward(address pool, address account) external view returns (uint256)\\n    {\\n        if(address(listSmartReward[pool])==address(0))\\n            return 0;\\n        return listSmartReward[pool].getReward(account);\\n    }\\n\\n    function getBoost(address pool, address account) external view returns (uint256)\\n    {\\n        if(address(listSmartReward[pool])==address(0))\\n            return 0;\\n        return listSmartReward[pool].getBoost(account);\\n    }\\n\\n    function getStake(address pool, address account) external view returns (uint256)\\n    {\\n        if(address(listSmartReward[pool])==address(0))\\n            return 0;\\n        return listSmartReward[pool].getStake(account);\\n    }\\n\\n    function allStake(address pool) external view returns (uint256)\\n    {\\n        if(address(listSmartReward[pool])==address(0))\\n            return 0;\\n        return listSmartReward[pool].allStake();\\n    }\\n\\n    function lockTimeStart(address pool, address account) external view returns (uint48)\\n    {\\n        if(address(listSmartReward[pool])==address(0))\\n            return 0;\\n        return listSmartReward[pool].lockTimeStart(account);\\n    }\\n\\n    function lockTimePeriod(address pool, address account) external view returns (uint48)\\n    {\\n        if(address(listSmartReward[pool])==address(0))\\n            return 0;\\n        return listSmartReward[pool].lockTimePeriod(account);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartVote\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_libStakingReward\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"smart\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"CreateSmartReward\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"allStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"createSmartReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lock_period\",\"type\":\"uint256\"}],\"name\":\"create_lock_period\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increase_amount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"new_lock_period\",\"type\":\"uint256\"}],\"name\":\"increase_lock_period\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libStakingReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"listSmartReward\",\"outputs\":[{\"internalType\":\"contract IStakingReward\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"lockTimePeriod\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"lockTimeStart\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartVote\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OrionFarmV2", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000465f42eedd6471e38695362b3b43516f079f23c10000000000000000000000009d9e5a6043d0635f8d454fc8aefa005a9df5cfac", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}