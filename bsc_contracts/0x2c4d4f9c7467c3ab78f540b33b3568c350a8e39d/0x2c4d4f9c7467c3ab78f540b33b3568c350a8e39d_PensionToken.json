{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.15;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}\r\n\r\ninterface InterfaceLP {\r\n    function sync() external;\r\n}\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\nabstract contract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor(\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        uint8 _tokenDecimals\r\n    ) {\r\n        _name = _tokenName;\r\n        _symbol = _tokenSymbol;\r\n        _decimals = _tokenDecimals;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB)\r\n    external\r\n    returns (address pair);\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(_owner);\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\ncontract WhitelistedRole is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(msg.sender), \"WhitelistedRole: caller does not have the Whitelisted role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyOwner {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyOwner {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(msg.sender);\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n}\r\n\r\ncontract TokenHandler is Ownable {\r\n    function sendTokenToOwner(address token) external onlyOwner {\r\n        if(IERC20(token).balanceOf(address(this)) > 0){\r\n            IERC20(token).transfer(owner(), IERC20(token).balanceOf(address(this)));\r\n        }\r\n    }\r\n}\r\n\r\ncontract PensionToken is ERC20Detailed, Ownable, WhitelistedRole {\r\n\r\n    bool public initialDistributionFinished = false;\r\n    bool public swapEnabled = true;\r\n    bool public isLiquidityInBnb = true;\r\n\r\n    uint256 public rewardYield = 4126398;\r\n    uint256 public rewardYieldDenominator = 10000000000;\r\n\r\n    uint256 public rebaseFrequency = 1800;\r\n    uint256 public nextRebase = block.timestamp + 604800;\r\n\r\n    mapping(address => bool) _isFeeExempt;\r\n    address[] public _makerPairs;\r\n    mapping (address => bool) public automatedMarketMakerPairs;\r\n\r\n    uint256 public constant MAX_FEE_RATE = 20;\r\n    uint256 private constant MAX_REBASE_FREQUENCY = 1800;\r\n    uint256 private constant DECIMALS = 18;\r\n    uint256 private constant MAX_UINT256 = type(uint256).max;\r\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 4000 * 10**DECIMALS;\r\n    uint256 private constant TOTAL_GONS = type(uint256).max - (type(uint256).max % INITIAL_FRAGMENTS_SUPPLY);\r\n    uint256 private constant MAX_SUPPLY = ~uint128(0);\r\n\r\n    event SwapBack(uint256 contractTokenBalance,uint256 amountToLiquify,uint256 amountToRFV,uint256 amountToTreasury);\r\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 bnbReceived, uint256 tokensIntoLiqudity);\r\n    event SwapAndLiquifyBusd(uint256 tokensSwapped, uint256 busdReceived, uint256 tokensIntoLiqudity);\r\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\r\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    address public marketingAddress;\r\n    address public liquidityAddress;\r\n    address public developmentAddress;\r\n    address public teamAddress1;\r\n    address public teamAddress2;\r\n    address public teamAddress3;\r\n    address public teamAddress4;\r\n    address public buybackAddress;\r\n    address public immutable BUSD;  // testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7, mainnet: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 \r\n\r\n    IDEXRouter public immutable router;\r\n    address public immutable pair;\r\n\r\n    TokenHandler public tokenHandler;\r\n\r\n    uint256 public liquidityFee = 3;\r\n    uint256 public marketingFee = 3;\r\n    uint256 public developmentFee = 2;\r\n    uint256 public teamFee = 2;\r\n    uint256 public buybackFee = 0;\r\n    uint256 public totalFee = liquidityFee+(marketingFee)+(developmentFee)+teamFee + buybackFee;\r\n    uint256 public feeDenominator = 100;\r\n\r\n    bool inSwap;\r\n\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n    \r\n    uint256 private _totalSupply;\r\n    uint256 private _gonsPerFragment;\r\n    uint256 private gonSwapThreshold = (TOTAL_GONS / 10000 * 10);\r\n\r\n    mapping(address => uint256) private _gonBalances;\r\n    mapping(address => mapping(address => uint256)) private _allowedFragments;\r\n\r\n    modifier validRecipient(address to) {\r\n        require(to != address(0x0));\r\n        _;\r\n    }\r\n\r\n    constructor() ERC20Detailed(\"Pension Token\", \"Pension\", 18) {\r\n        address dexAddress;\r\n        address busdAddress;\r\n        if(block.chainid == 56){\r\n            dexAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n            busdAddress = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n        } else if (block.chainid == 97){\r\n            dexAddress = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\r\n            busdAddress  = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7;\r\n        } else {\r\n            revert(\"Chain not configured\");\r\n        }\r\n\r\n        marketingAddress = address(0xf03fDDE9162bEEc6b6735883a461dD751691d1b9);\r\n        liquidityAddress = address(msg.sender);\r\n        developmentAddress = address(0xaF7d033A858ce2C4891c8778B314D7a7a7bD9D40);\r\n        teamAddress1 = address(0xBb6da379Ed680839c4E1Eb7fE49814cD6e7Cbf8a);\r\n        teamAddress2 = address(0xC1c891711d3c927dce98055bA3a0735974817d62);\r\n        teamAddress3 = address(0xA916350b5eA41aec0FF4d4D6Ce5eFBC1fd832C98);\r\n        teamAddress4 = address(0x70Ac5F87B991209e26a60195dD6876aAd237239b);\r\n        buybackAddress = address(msg.sender);\r\n\r\n        router = IDEXRouter(dexAddress);\r\n        BUSD = busdAddress;\r\n        pair = IDEXFactory(router.factory()).createPair(address(this), BUSD);\r\n\r\n        tokenHandler = new TokenHandler();\r\n\r\n        _allowedFragments[address(this)][address(router)] = ~uint256(0);\r\n        _allowedFragments[address(this)][pair] = ~uint256(0);\r\n        _allowedFragments[address(this)][address(this)] = ~uint256(0);\r\n\r\n        setAutomatedMarketMakerPair(pair, true);\r\n\r\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\r\n        _gonBalances[msg.sender] = TOTAL_GONS;\r\n        _gonsPerFragment = TOTAL_GONS/(_totalSupply);\r\n\r\n        addWhitelisted(address(this));\r\n        addWhitelisted(msg.sender);\r\n        addWhitelisted(dexAddress);\r\n        addWhitelisted(address(0xdead));\r\n        \r\n        _isFeeExempt[address(this)] = true;\r\n        _isFeeExempt[address(msg.sender)] = true;\r\n        _isFeeExempt[address(dexAddress)] = true;\r\n        _isFeeExempt[address(0xdead)] = true;\r\n\r\n        emit Transfer(address(0x0), msg.sender, _totalSupply);  \r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function allowance(address owner_, address spender) external view override returns (uint256){\r\n        return _allowedFragments[owner_][spender];\r\n    }\r\n\r\n    function balanceOf(address who) public view override returns (uint256) {\r\n        return _gonBalances[who]/(_gonsPerFragment);\r\n    }\r\n\r\n    function checkFeeExempt(address _addr) external view returns (bool) {\r\n        return _isFeeExempt[_addr];\r\n    }\r\n\r\n    function checkSwapThreshold() external view returns (uint256) {\r\n        return gonSwapThreshold/(_gonsPerFragment);\r\n    }\r\n\r\n    function shouldRebase() public view returns (bool) {\r\n        return nextRebase <= block.timestamp;\r\n    }\r\n\r\n    function shouldTakeFee(address from, address to) internal view returns (bool) {\r\n        if(_isFeeExempt[from] || _isFeeExempt[to]){\r\n            return false;\r\n        } else {\r\n            return (automatedMarketMakerPairs[from] || automatedMarketMakerPairs[to]);\r\n        }\r\n    }\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return\r\n        !inSwap &&\r\n        swapEnabled &&\r\n        totalFee > 0 &&\r\n        _gonBalances[address(this)] >= gonSwapThreshold;\r\n    }\r\n\r\n    function manualSync() public {\r\n        for(uint i = 0; i < _makerPairs.length; i++){\r\n            InterfaceLP(_makerPairs[i]).sync();\r\n        }\r\n    }\r\n\r\n    function transfer(address to, uint256 value) external override validRecipient(to) returns (bool){\r\n        _transferFrom(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        bool excludedAccount = inSwap || _isFeeExempt[sender] || _isFeeExempt[recipient] || automatedMarketMakerPairs[sender] || isWhitelisted(sender) || isWhitelisted(recipient);\r\n\r\n        require(excludedAccount, \"Only Exempt Contracts or Wallets may transfer tokens\");\r\n\r\n        if(!initialDistributionFinished){\r\n            require(_isFeeExempt[sender] || _isFeeExempt[recipient], \"Trading is paused\");\r\n        }\r\n\r\n        uint256 gonAmount = amount*(_gonsPerFragment);\r\n\r\n        _gonBalances[sender] = _gonBalances[sender]-(gonAmount);\r\n\r\n        uint256 gonAmountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, gonAmount) : gonAmount;\r\n        _gonBalances[recipient] = _gonBalances[recipient]+(gonAmountReceived);\r\n\r\n        emit Transfer(sender, recipient, gonAmountReceived/(_gonsPerFragment));\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to,  uint256 value) external override validRecipient(to) returns (bool) {\r\n        if (_allowedFragments[from][msg.sender] != MAX_UINT256) {\r\n            require(_allowedFragments[from][msg.sender] >= value,\"Insufficient Allowance\");\r\n            _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender]-(value);\r\n        }\r\n        _transferFrom(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function swapBack() public onlyWhitelisted {\r\n\r\n        if(!shouldSwapBack()){return;}\r\n\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        \r\n        // Halve the amount of liquidity tokens\r\n        uint256 liquidityTokens = contractBalance * liquidityFee / totalFee / 2;\r\n        \r\n        swapTokensForBUSD(contractBalance - liquidityTokens);\r\n\r\n        tokenHandler.sendTokenToOwner(address(BUSD));\r\n        \r\n        uint256 busdBalance = IERC20(BUSD).balanceOf(address(this));\r\n        uint256 busdForLiquidity = busdBalance;\r\n\r\n        uint256 busdForMarketing = busdBalance * marketingFee / (totalFee - (liquidityFee / 2));\r\n        uint256 busdForDevelopment = busdBalance * developmentFee / (totalFee - (liquidityFee / 2));\r\n        uint256 busdForTeam = busdBalance * teamFee / (totalFee - (liquidityFee / 2));\r\n        uint256 busdForBuyback = busdBalance * buybackFee / (totalFee - (liquidityFee /2));\r\n\r\n        busdForLiquidity -= busdForMarketing + busdForDevelopment + busdForTeam + busdForBuyback;\r\n        \r\n        if(liquidityTokens > 0 && busdForLiquidity > 0){\r\n            addLiquidity(liquidityTokens, busdForLiquidity);\r\n        }\r\n\r\n        if(busdForTeam > 0){\r\n            IERC20(BUSD).transfer(teamAddress1, busdForTeam/4);\r\n            IERC20(BUSD).transfer(teamAddress2, busdForTeam/4);\r\n            IERC20(BUSD).transfer(teamAddress3, busdForTeam/4);\r\n            IERC20(BUSD).transfer(teamAddress4, busdForTeam/4);\r\n        }\r\n\r\n        if(busdForDevelopment > 0){\r\n            IERC20(BUSD).transfer(developmentAddress, busdForDevelopment);\r\n        }\r\n\r\n        if(busdForBuyback> 0){\r\n            IERC20(BUSD).transfer(buybackAddress, busdForBuyback);\r\n        }\r\n\r\n        if(busdForMarketing > 0){\r\n            IERC20(BUSD).transfer(marketingAddress, IERC20(BUSD).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    function swapTokensForBUSD(uint256 tokenAmount) private {\r\n\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = address(BUSD);\r\n\r\n        approve(address(router), tokenAmount);\r\n\r\n        // make the swap\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(tokenHandler),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 busdAmount) private {\r\n        // approve token transfer to cover all possible scenarios\r\n        approve(address(router), tokenAmount);\r\n        IERC20(BUSD).approve(address(router), busdAmount);\r\n\r\n        // add the liquidity\r\n        router.addLiquidity(address(this), address(BUSD), tokenAmount, busdAmount, 0,  0,  address(liquidityAddress), block.timestamp);\r\n    }\r\n\r\n    function takeFee(address sender, uint256 gonAmount) internal returns (uint256){\r\n        uint256 _realFee = totalFee;\r\n\r\n        uint256 feeAmount = gonAmount*(_realFee)/(feeDenominator);\r\n\r\n        _gonBalances[address(this)] = _gonBalances[address(this)]+(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount/(_gonsPerFragment));\r\n\r\n        return gonAmount-(feeAmount);\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool){\r\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\r\n        if (subtractedValue >= oldValue) {\r\n            _allowedFragments[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowedFragments[msg.sender][spender] = oldValue-(\r\n                subtractedValue\r\n            );\r\n        }\r\n        emit Approval(\r\n            msg.sender,\r\n            spender,\r\n            _allowedFragments[msg.sender][spender]\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool){\r\n        _allowedFragments[msg.sender][spender] = _allowedFragments[msg.sender][\r\n        spender\r\n        ]+(addedValue);\r\n        emit Approval(\r\n            msg.sender,\r\n            spender,\r\n            _allowedFragments[msg.sender][spender]\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public override returns (bool){\r\n        _allowedFragments[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function coreRebase(int256 supplyDelta) private returns (uint256) {\r\n        uint256 epoch = block.timestamp;\r\n\r\n        if (supplyDelta == 0) {\r\n            emit LogRebase(epoch, _totalSupply);\r\n            return _totalSupply;\r\n        }\r\n\r\n        if (supplyDelta < 0) {\r\n            _totalSupply = _totalSupply-(uint256(-supplyDelta));\r\n        } else {\r\n            _totalSupply = _totalSupply+(uint256(supplyDelta));\r\n        }\r\n\r\n        if (_totalSupply > MAX_SUPPLY) {\r\n            _totalSupply = MAX_SUPPLY;\r\n        }\r\n\r\n        _gonsPerFragment = TOTAL_GONS/(_totalSupply);\r\n\r\n        nextRebase = epoch + rebaseFrequency;\r\n\r\n        emit LogRebase(epoch, _totalSupply);\r\n        return _totalSupply;\r\n    }\r\n\r\n    function manualRebase() external onlyWhitelisted {\r\n        require(!inSwap, \"Try again\");\r\n        require(nextRebase <= block.timestamp, \"Not in time\");\r\n\r\n        int256 supplyDelta = int256(_totalSupply*(rewardYield)/(rewardYieldDenominator));\r\n\r\n        coreRebase(supplyDelta);\r\n        manualSync();\r\n    }\r\n    \r\n    function setAutomatedMarketMakerPair(address _pair, bool _value) public onlyOwner {\r\n        require(automatedMarketMakerPairs[_pair] != _value, \"Value already set\");\r\n\r\n        automatedMarketMakerPairs[_pair] = _value;\r\n\r\n        if(_value){\r\n            _makerPairs.push(_pair);\r\n        }else{\r\n            require(_makerPairs.length > 1, \"Required 1 pair\");\r\n            for (uint256 i = 0; i < _makerPairs.length; i++) {\r\n                if (_makerPairs[i] == _pair) {\r\n                    _makerPairs[i] = _makerPairs[_makerPairs.length - 1];\r\n                    _makerPairs.pop();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit SetAutomatedMarketMakerPair(_pair, _value);\r\n    }\r\n\r\n    function enableTrading(bool _value) external onlyOwner {\r\n        require(initialDistributionFinished != _value, \"Not changed\");\r\n        initialDistributionFinished = _value;\r\n        nextRebase = block.timestamp + rebaseFrequency;\r\n    }\r\n\r\n    function setFeeExempt(address _addr, bool _value) external onlyOwner {\r\n        require(_isFeeExempt[_addr] != _value, \"Not changed\");\r\n        _isFeeExempt[_addr] = _value;\r\n    }\r\n\r\n    function setFeeReceivers(address _liquidityReceiver, address _marketingReceiver, address _developmentReceiver, address _buybackReceiver) external onlyOwner {\r\n        liquidityAddress = _liquidityReceiver;\r\n        marketingAddress = _marketingReceiver;\r\n        developmentAddress = _developmentReceiver;\r\n        buybackAddress = _buybackReceiver;\r\n    }\r\n\r\n    function setTeamReceivers(address _team1, address _team2, address _team3, address _team4) external onlyOwner {\r\n        teamAddress1 = _team1;\r\n        teamAddress2 = _team2;\r\n        teamAddress3 = _team3;\r\n        teamAddress4 = _team4;\r\n    }\r\n\r\n    function setFees(uint256 _liquidityFee, uint256 _marketingFee, uint256 _developmentFee, uint256 _teamFee, uint256 _buybackFee) external onlyOwner {\r\n        liquidityFee = _liquidityFee;\r\n        marketingFee = _marketingFee;\r\n        developmentFee = _developmentFee;\r\n        teamFee = _teamFee;\r\n        buybackFee = _buybackFee;\r\n        totalFee = liquidityFee + marketingFee + developmentFee + teamFee + buybackFee;\r\n        require(totalFee <= 15, \"Fees set too high\");\r\n    }\r\n\r\n    function clearStuckBalance(address _receiver) external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        payable(_receiver).transfer(balance);\r\n    }\r\n\r\n    function rescueToken(address tokenAddress, uint256 tokens, address destination) external onlyOwner returns (bool success){\r\n        require(tokenAddress != address(this), \"Cannot take native tokens\");\r\n        return ERC20Detailed(tokenAddress).transfer(destination, tokens);\r\n    }\r\n\r\n    function setRebaseFrequency(uint256 _rebaseFrequency) external onlyOwner {\r\n        require(_rebaseFrequency <= MAX_REBASE_FREQUENCY, \"Too high\");\r\n        rebaseFrequency = _rebaseFrequency;\r\n    }\r\n\r\n    function setRewardYield(uint256 _rewardYield, uint256 _rewardYieldDenominator) external onlyOwner {\r\n        rewardYield = _rewardYield;\r\n        rewardYieldDenominator = _rewardYieldDenominator;\r\n    }\r\n\r\n    function setNextRebase(uint256 _nextRebase) external onlyOwner {\r\n        require(nextRebase > block.timestamp, \"Must set rebase in the future\");\r\n        nextRebase = _nextRebase;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"busdReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquifyBusd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contractTokenBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToLiquify\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToRFV\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToTreasury\",\"type\":\"uint256\"}],\"name\":\"SwapBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_makerPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"clearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developmentAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developmentFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialDistributionFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLiquidityInBnb\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextRebase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardYieldDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_developmentReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buybackReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_developmentFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_teamFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buybackFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nextRebase\",\"type\":\"uint256\"}],\"name\":\"setNextRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rebaseFrequency\",\"type\":\"uint256\"}],\"name\":\"setRebaseFrequency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardYield\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardYieldDenominator\",\"type\":\"uint256\"}],\"name\":\"setRewardYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_team1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_team2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_team3\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_team4\",\"type\":\"address\"}],\"name\":\"setTeamReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldRebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAddress1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAddress2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAddress3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAddress4\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenHandler\",\"outputs\":[{\"internalType\":\"contract TokenHandler\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PensionToken", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9512acef497d0a2557633d64673a5f08785e504b3ba5af1f22e1688a50462ac4"}