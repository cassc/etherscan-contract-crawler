{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.4;\r\n\r\ninterface IBEP20 {\r\n    /**\r\n    * @dev Returns the token name.\r\n    */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeBEP20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IBEP20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeBEP20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IBEP20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the initial owner.\r\n     */\r\n    function initializeOwnable(address ownerAddr_) internal {\r\n        _setOwner(ownerAddr_);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) external virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IWrappedToken {\r\n    function initialize(string calldata name, string calldata symbol, uint8 decimals, address owner, address admin) external;\r\n    function mintTo(address recipient, uint256 amount) external returns (bool);\r\n    function burnFrom(address account, uint256 amount) external returns (bool);\r\n}\r\n\r\nstruct OriginalToken {\r\n    uint256 chainId;\r\n    address addr;\r\n}\r\n\r\ncontract BscTeleportAgent is Ownable, Initializable {\r\n    using SafeBEP20 for IBEP20;\r\n    using Address for address;\r\n\r\n    mapping(uint256/*fromChainId*/ => mapping(uint256/*fromChainTeleportId*/ => bool/*finished*/)) public finishedTeleports;\r\n    mapping(uint256/*original chain id*/ => mapping(address/*original token address*/ => address/*wrapped token address*/)) public originalToWrappedTokens;\r\n    mapping(address/*wrapped token address*/ => OriginalToken) public wrappedToOriginalTokens;\r\n    \r\n    address public signOwner;\r\n    address public feeOwner;\r\n    address public wrappedTokenImplementation;\r\n    address public wrappedTokenAdmin;\r\n    \r\n    uint256 public teleportIdGenerator;\r\n    uint256 public teleportFee;\r\n    \r\n    string private constant ERROR_ALREADY_EXECUTED = \"already executed\";\r\n    string private constant ERROR_MINT_FAILED = \"mint failed\";\r\n    \r\n    event SetSignOwner(\r\n        address indexed oldValue,\r\n        address indexed newValue);\r\n        \r\n    event SetFeeOwner(\r\n        address indexed oldValue,\r\n        address indexed newValue);\r\n        \r\n    event SetTeleportFee(\r\n        uint256 oldValue,\r\n        uint256 newValue);\r\n        \r\n    event SetWrappedTokenAdmin(\r\n        address indexed oldValue,\r\n        address indexed newValue);\r\n    \r\n    event WrappedTokenCreated(\r\n        address indexed sponsor,\r\n        uint256 originalTokenChainId,\r\n        address indexed originalTokenAddr,\r\n        address indexed wrappedTokenAddr,\r\n        string name,\r\n        string symbol,\r\n        uint8 decimals);\r\n\r\n    event TeleportStarted(\r\n        uint256 teleportId,\r\n        address indexed sender,\r\n        uint256 originalTokenChainId,\r\n        address indexed originalTokenAddr,\r\n        address indexed tokenAddr,\r\n        uint256 amount,\r\n        uint256 toChainId,\r\n        address recipient,\r\n        uint256 feeAmount);\r\n\r\n    event TeleportFinished(\r\n        address indexed recipient,\r\n        uint256 fromChainId,\r\n        uint256 fromChainTeleportId,\r\n        uint256 originalTokenChainId,\r\n        address indexed originalTokenAddr,\r\n        address indexed tokenAddr,\r\n        uint256 amount);\r\n        \r\n    event TeleportCancelStarted(\r\n        uint256 fromChainId,\r\n        uint256 fromChainTeleportId);\r\n        \r\n    event TeleportCancelFinished(\r\n        uint256 teleportId,\r\n        address tokenAddr,\r\n        uint256 amount,\r\n        address recipient);\r\n\r\n    function initialize(\r\n        address payable _ownerAddr,\r\n        address _signOwner,\r\n        address _feeOwner,\r\n        uint256 _teleportFee,\r\n        address _wrappedTokenImpl,\r\n        address _wrappedTokenAdmin) external virtual initializer {\r\n            \r\n        _ensureNotZeroAddress(_ownerAddr);\r\n        _ensureNotZeroAddress(_signOwner);\r\n        _ensureNotZeroAddress(_feeOwner);\r\n        _ensureNotZeroAddress(_wrappedTokenImpl);\r\n\r\n        initializeOwnable(_ownerAddr);\r\n\r\n        signOwner = _signOwner;\r\n        emit SetSignOwner(address(0), _signOwner);\r\n        \r\n        feeOwner = _feeOwner;\r\n        emit SetFeeOwner(address(0), _feeOwner);\r\n        \r\n        teleportFee = _teleportFee;\r\n        emit SetTeleportFee(0, _teleportFee);\r\n        \r\n        wrappedTokenImplementation = _wrappedTokenImpl;\r\n        \r\n        wrappedTokenAdmin = _wrappedTokenAdmin;\r\n        emit SetWrappedTokenAdmin(address(0), _wrappedTokenAdmin);\r\n    }\r\n    \r\n    function setSignOwner(address _signOwner) onlyOwner external {\r\n        _ensureNotZeroAddress(_signOwner);\r\n        require(signOwner != _signOwner, ERROR_ALREADY_EXECUTED);\r\n        emit SetSignOwner(signOwner, _signOwner);\r\n        signOwner = _signOwner;\r\n    }\r\n    \r\n    function setFeeOwner(address _feeOwner) onlyOwner external {\r\n        _ensureNotZeroAddress(_feeOwner);\r\n        require(feeOwner != _feeOwner, ERROR_ALREADY_EXECUTED);\r\n        emit SetFeeOwner(feeOwner, _feeOwner);\r\n        feeOwner = _feeOwner;\r\n    }\r\n\r\n    function setTeleportFee(uint256 _teleportFee) onlyOwner external {\r\n        require(teleportFee != _teleportFee, ERROR_ALREADY_EXECUTED);\r\n        emit SetTeleportFee(teleportFee, _teleportFee);\r\n        teleportFee = _teleportFee;\r\n    }\r\n    \r\n    function setWrappedTokenAdmin(address _wrappedTokenAdmin) onlyOwner external {\r\n        _ensureNotZeroAddress(_wrappedTokenAdmin);\r\n        require(wrappedTokenAdmin != _wrappedTokenAdmin, ERROR_ALREADY_EXECUTED);\r\n        emit SetWrappedTokenAdmin(wrappedTokenAdmin, _wrappedTokenAdmin);\r\n        wrappedTokenAdmin = _wrappedTokenAdmin;\r\n    }\r\n    \r\n    function createWrappedToken(\r\n        uint256 _originalTokenChainId,\r\n        address _originalTokenAddr,\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        uint8 _decimals) onlyOwner external {\r\n        \r\n        _createWrappedToken(\r\n            _originalTokenChainId,\r\n            _originalTokenAddr,\r\n            _name,\r\n            _symbol,\r\n            _decimals);\r\n    }\r\n    \r\n    function createWrappedToken(\r\n        uint256 _originalTokenChainId,\r\n        address _originalTokenAddr,\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        uint8 _decimals,\r\n        bytes calldata _signature) external {\r\n        \r\n        string memory message = string(abi.encodePacked(\r\n            _toAsciiString(_msgSender()), \";\",\r\n            _uintToString(_originalTokenChainId), \";\",\r\n            _toAsciiString(_originalTokenAddr), \";\",\r\n            _name, \";\",\r\n            _symbol, \";\",\r\n            _uintToString(_decimals)));\r\n            \r\n        _verify(message, _signature);\r\n        \r\n        _createWrappedToken(\r\n            _originalTokenChainId,\r\n            _originalTokenAddr,\r\n            _name,\r\n            _symbol,\r\n            _decimals);\r\n    }\r\n    \r\n    function _createWrappedToken(\r\n        uint256 _originalTokenChainId,\r\n        address _originalTokenAddr,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals) private returns (address) {\r\n            \r\n        _ensureNotZeroAddress(_originalTokenAddr);\r\n        require(block.chainid != _originalTokenChainId, \"can't create wrapped token in original chain\");\r\n        require(originalToWrappedTokens[_originalTokenChainId][_originalTokenAddr] == address(0), \"already created\");\r\n        \r\n        address msgSender = _msgSender();\r\n\r\n        address wrappedToken = _deployMinimalProxy(wrappedTokenImplementation);\r\n        IWrappedToken(wrappedToken).initialize(_name, _symbol, _decimals, address(this), wrappedTokenAdmin);\r\n        \r\n        originalToWrappedTokens[_originalTokenChainId][_originalTokenAddr] = wrappedToken;\r\n        wrappedToOriginalTokens[wrappedToken] = OriginalToken({chainId: _originalTokenChainId, addr: _originalTokenAddr});\r\n        \r\n        emit WrappedTokenCreated(\r\n            msgSender,\r\n            _originalTokenChainId,\r\n            _originalTokenAddr,\r\n            wrappedToken,\r\n            _name,\r\n            _symbol,\r\n            _decimals);\r\n            \r\n        return wrappedToken;\r\n    }\r\n    \r\n    function teleportStart(address _tokenAddr, uint256 _amount, uint256 _toChainId, address _recipient) payable external {\r\n        _ensureNotZeroAddress(_tokenAddr);\r\n        _ensureNotZeroAddress(_recipient);\r\n        require(_amount > 0, \"zero amount\");\r\n        require(msg.value >= teleportFee, \"fee mismatch\");\r\n\r\n        if (msg.value != 0) {\r\n            (bool sent, ) = feeOwner.call{value: msg.value}(\"\");\r\n            require(sent, \"fee send failed\");\r\n        }\r\n        \r\n        address msgSender = _msgSender();\r\n        \r\n        OriginalToken storage originalToken = wrappedToOriginalTokens[_tokenAddr];\r\n        \r\n        if (originalToken.addr == address(0)) { // teleportable token {_tokenAddr} is original token\r\n            IBEP20(_tokenAddr).safeTransferFrom(msgSender, address(this), _amount);\r\n        \r\n            emit TeleportStarted(\r\n                ++teleportIdGenerator,\r\n                msgSender,\r\n                block.chainid,\r\n                _tokenAddr,\r\n                _tokenAddr,\r\n                _amount,\r\n                _toChainId,\r\n                _recipient,\r\n                msg.value);\r\n            \r\n            return;\r\n        }\r\n        \r\n        // teleportable token {_tokenAddr} is wrapped token\r\n            \r\n        require(IWrappedToken(_tokenAddr).burnFrom(msgSender, _amount), \"burn failed\");\r\n        \r\n        emit TeleportStarted(\r\n            ++teleportIdGenerator,\r\n            msgSender,\r\n            originalToken.chainId,\r\n            originalToken.addr,\r\n            _tokenAddr,\r\n            _amount,\r\n            _toChainId,\r\n            _recipient,\r\n            msg.value);\r\n    }\r\n    \r\n    function teleportFinish(\r\n        uint256 _fromChainId,\r\n        uint256 _fromChainTeleportId,\r\n        uint256 _originalTokenChainId,\r\n        address _originalTokenAddr,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        address _recipient,\r\n        uint256 _amount) onlyOwner external {\r\n            \r\n        _teleportFinish(\r\n            _fromChainId,\r\n            _fromChainTeleportId,\r\n            _originalTokenChainId,\r\n            _originalTokenAddr,\r\n            _name,\r\n            _symbol,\r\n            _decimals,\r\n            _recipient,\r\n            _amount);\r\n    }\r\n    \r\n    function teleportFinish(\r\n        uint256 _fromChainId,\r\n        uint256 _fromChainTeleportId,\r\n        uint256 _originalTokenChainId,\r\n        address _originalTokenAddr,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        uint256 _amount,\r\n        bytes memory _signature) external {\r\n        \r\n        address recipient = _msgSender();\r\n        \r\n        string memory message = string(abi.encodePacked(\r\n            _toAsciiString(recipient), \";\",\r\n            _uintToString(_fromChainId), \";\",\r\n            _uintToString(_fromChainTeleportId), \";\",\r\n            _uintToString(_originalTokenChainId), \";\",\r\n            _toAsciiString(_originalTokenAddr), \";\",\r\n            _name, \";\",\r\n            _symbol, \";\",\r\n            _uintToString(_decimals), \";\",\r\n            _uintToString(_amount)));\r\n            \r\n        _verify(message, _signature);\r\n        \r\n        _teleportFinish(\r\n            _fromChainId,\r\n            _fromChainTeleportId,\r\n            _originalTokenChainId,\r\n            _originalTokenAddr,\r\n            _name,\r\n            _symbol,\r\n            _decimals,\r\n            recipient,\r\n            _amount);\r\n    }\r\n    \r\n    function _teleportFinish(\r\n        uint256 _fromChainId,\r\n        uint256 _fromChainTeleportId,\r\n        uint256 _originalTokenChainId,\r\n        address _originalTokenAddr,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        address _recipient,\r\n        uint256 _amount) private {\r\n            \r\n        _ensureNotZeroAddress(_originalTokenAddr);\r\n        _ensureNotZeroAddress(_recipient);\r\n            \r\n        require(!finishedTeleports[_fromChainId][_fromChainTeleportId], ERROR_ALREADY_EXECUTED);\r\n        finishedTeleports[_fromChainId][_fromChainTeleportId] = true;\r\n            \r\n        address tokenAddr;\r\n    \r\n        if (_originalTokenChainId == block.chainid) {\r\n            IBEP20(_originalTokenAddr).safeTransfer(_recipient, _amount);\r\n            tokenAddr = _originalTokenAddr;\r\n        } else {\r\n            tokenAddr = originalToWrappedTokens[_originalTokenChainId][_originalTokenAddr];\r\n            \r\n            if (tokenAddr == address(0)) {\r\n                tokenAddr = _createWrappedToken(\r\n                    _originalTokenChainId,\r\n                    _originalTokenAddr,\r\n                    _name,\r\n                    _symbol,\r\n                    _decimals);\r\n            }\r\n            \r\n            require(IWrappedToken(tokenAddr).mintTo(_recipient, _amount), ERROR_MINT_FAILED);\r\n        }\r\n        \r\n        emit TeleportFinished(\r\n            _recipient,\r\n            _fromChainId,\r\n            _fromChainTeleportId,\r\n            _originalTokenChainId,\r\n            _originalTokenAddr,\r\n            tokenAddr,\r\n            _amount);\r\n    }\r\n    \r\n    function teleportCancelStart(uint256 _fromChainId, uint256 _fromChainTeleportId) onlyOwner external {\r\n        require(!finishedTeleports[_fromChainId][_fromChainTeleportId], ERROR_ALREADY_EXECUTED);\r\n        finishedTeleports[_fromChainId][_fromChainTeleportId] = true;\r\n        \r\n        emit TeleportCancelStarted(_fromChainId, _fromChainTeleportId);\r\n    }\r\n    \r\n    function teleportCancelFinish(\r\n        uint256 _teleportId,\r\n        address _tokenAddr,\r\n        uint256 _amount,\r\n        address _recipient) onlyOwner external {\r\n            \r\n        OriginalToken storage originalToken = wrappedToOriginalTokens[_tokenAddr];\r\n        \r\n        if (originalToken.addr == address(0)) { // {_tokenAddr} is original token\r\n            IBEP20(_tokenAddr).safeTransfer(_recipient, _amount);\r\n        } else { // {_tokenAddr} is wrapped token\r\n            require(IWrappedToken(_tokenAddr).mintTo(_recipient, _amount), ERROR_MINT_FAILED);\r\n        }\r\n\r\n        emit TeleportCancelFinished(_teleportId, _tokenAddr, _amount, _recipient);\r\n    }\r\n\r\n    function _deployMinimalProxy(address _logic) private returns (address proxy) {\r\n        // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\r\n        bytes20 targetBytes = bytes20(_logic);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            proxy := create(0, clone, 0x37)\r\n        }\r\n    }\r\n    \r\n    function _verify(string memory _message, bytes memory _sig) private view {\r\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(abi.encodePacked(_message))));\r\n        address messageSigner = _recover(messageHash, _sig);\r\n\r\n        require(messageSigner == signOwner, \"verification failed\");\r\n    }\r\n\r\n    function _recover(bytes32 _hash, bytes memory _sig) private pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        require(_sig.length == 65, \"_recover: invalid sig size\");\r\n\r\n        assembly {\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            v := byte(0, mload(add(_sig, 96)))\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        require(v == 27 || v == 28, \"_recover: invalid sig\");\r\n\r\n        return ecrecover(_hash, v, r, s);\r\n    }\r\n\r\n    function _uintToString(uint _i) private pure returns (string memory) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k - 1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function _toAsciiString(address _addr) private pure returns (string memory) {\r\n        bytes memory s = new bytes(40);\r\n        for (uint i = 0; i < 20; i++) {\r\n            bytes1 b = bytes1(uint8(uint(uint160(_addr)) / (2 ** (8 * (19 - i)))));\r\n            bytes1 hi = bytes1(uint8(b) / 16);\r\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n            s[2 * i] = _char(hi);\r\n            s[2 * i + 1] = _char(lo);\r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    function _char(bytes1 value) private pure returns (bytes1) {\r\n        return (uint8(value) < 10) ? bytes1(uint8(value) + 0x30) : bytes1(uint8(value) + 0x57);\r\n    }\r\n    \r\n    function _ensureNotZeroAddress(address _address) private pure {\r\n        require(_address != address(0), \"zero address\");\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"SetFeeOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"SetSignOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"SetTeleportFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"SetWrappedTokenAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"teleportId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"TeleportCancelFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromChainTeleportId\",\"type\":\"uint256\"}],\"name\":\"TeleportCancelStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromChainTeleportId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originalTokenChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originalTokenAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TeleportFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"teleportId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originalTokenChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originalTokenAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"TeleportStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originalTokenChainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originalTokenAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wrappedTokenAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"WrappedTokenCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_originalTokenChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_originalTokenAddr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"createWrappedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_originalTokenChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_originalTokenAddr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"name\":\"createWrappedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"finishedTeleports\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_ownerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_teleportFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wrappedTokenImpl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wrappedTokenAdmin\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"originalToWrappedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeOwner\",\"type\":\"address\"}],\"name\":\"setFeeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signOwner\",\"type\":\"address\"}],\"name\":\"setSignOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_teleportFee\",\"type\":\"uint256\"}],\"name\":\"setTeleportFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrappedTokenAdmin\",\"type\":\"address\"}],\"name\":\"setWrappedTokenAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_teleportId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"teleportCancelFinish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fromChainTeleportId\",\"type\":\"uint256\"}],\"name\":\"teleportCancelStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teleportFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fromChainTeleportId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_originalTokenChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_originalTokenAddr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"teleportFinish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fromChainTeleportId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_originalTokenChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_originalTokenAddr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"teleportFinish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teleportIdGenerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"teleportStart\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wrappedToOriginalTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedTokenAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedTokenImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BscTeleportAgent", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4f8d365821d56319c0eb4cb78e058d5a9427fa39ddc3e2b164362346c33d9d50"}