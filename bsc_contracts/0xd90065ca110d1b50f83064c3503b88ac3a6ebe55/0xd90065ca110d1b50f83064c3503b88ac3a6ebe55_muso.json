{"SourceCode": "//  SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.18;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}\r\n \r\n\r\ninterface IPancakeFactory {\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function mint(uint256 amount) external returns (uint256);\r\n\r\n    function destroy(uint256 amount) external returns (uint256);\r\n\r\n    function getPrice() external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n    bool public  _OPEN = true;\r\n    address internal Operator = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    modifier open() {\r\n        require(_OPEN  , \"!o\");\r\n        _;\r\n    }\r\n     modifier onlyOperator() {\r\n        require(Operator == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n\r\n    function openorclose() public virtual onlyOwner {\r\n        _OPEN = !_OPEN;\r\n    }\r\n\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"n0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n\r\n      function transferOperatorShip(address _Operator) public virtual onlyOwner {\r\n        require(_Operator != address(0), \"n0\");\r\n        Operator = _Operator;\r\n    }\r\n}\r\n\r\ncontract PublicReward {\r\n    constructor(address USDT, address HD) {\r\n        IERC20(USDT).approve(msg.sender, ~uint256(0));\r\n        IERC20(HD).approve(msg.sender, ~uint256(0));\r\n    }\r\n}\r\n\r\ncontract muso is Ownable, ReentrancyGuard {\r\n\r\n \r\n    PublicReward public publicReward;\r\n    ISwapRouter router;\r\n    IUniswapV2Pair pair;\r\n    mapping(uint256 => mapping(uint256 => address)) public floorUsers;\r\n    mapping(address => User) users;\r\n    mapping(bytes32 => bool) verifiedMessage;\r\n    uint256 public  Lprice;\r\n    uint256[] public levelPrice = [\r\n        0,\r\n        20000000000000000000,\r\n        50000000000000000000,\r\n        100000000000000000000,\r\n        200000000000000000000,\r\n        500000000000000000000\r\n    ];\r\n\r\n\r\n    uint256[] public limitUSDT = [\r\n        0,\r\n        500000000000000000000,\r\n        2000000000000000000000,\r\n        5000000000000000000000,\r\n        10000000000000000000000\r\n    ];\r\n \r\n    IERC20 USDT;\r\n    IERC20 MUSO;\r\n    IERC20 MUSOL;\r\n\r\n\r\n\r\n    address deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n    address public LPfh = 0xeF56780eb0c6fdCC37063d48c92e10b54fa17D1c;\r\n    address public PTAddress= 0xA711e250B1A4D1Ccae33C489253F80c01F4dC28E;\r\n    address public PTUAddress= 0x1B4F6f43860905BE4a3e357b1FE889802F1a8bE5;\r\n \r\n\r\n    event Buy(  uint256 amount);\r\n    event Sell(  uint256 amount);\r\n    event Upgrade(  uint256 amount);\r\n     constructor(\r\n    ) {\r\n        USDT  = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n        MUSO  = IERC20(0x36493f18b658F44359A1C809205ACaEC268268c8);\r\n        MUSOL = IERC20(0x6d0e5E0b9d716dE44DacD9E62386D91095A36c02);\r\n        \r\n        router = ISwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        pair = IUniswapV2Pair(\r\n            IPancakeFactory(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73).getPair(0x55d398326f99059fF775485246999027B3197955, 0x36493f18b658F44359A1C809205ACaEC268268c8)\r\n        );\r\n        publicReward = new PublicReward(address(USDT), address(MUSO));\r\n        Team storage topUser = users[deadAddress].team;\r\n        topUser.floor = 1;\r\n        topUser.index = 1;\r\n        topUser.add = deadAddress;\r\n        topUser.initTime = _getTs();\r\n        floorUsers[1][1] = deadAddress;\r\n        \r\n        MUSO.approve(address(router), ~uint256(0));\r\n        USDT.approve(address(router), ~uint256(0));\r\n        pair.approve(address(router), ~uint256(0));\r\n      \r\n    }\r\n\r\n\r\n    modifier noContract() {\r\n        require(tx.origin == msg.sender, \"contract not allowed\");\r\n        uint256 size;\r\n        address addr = msg.sender;\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n\r\n        require(!(size > 0), \"contract not allowed\");\r\n        _;\r\n    }\r\n\r\n\r\n    function _invite(address add, address _leader) private {\r\n        inviteProxy(add,_leader);\r\n    }\r\n     \r\n    function getVIPprice() public view  returns(uint256[] memory ){\r\n        uint256[] memory V2 = new uint256[](6);\r\n            V2[0] = levelPrice[1];\r\n            V2[1] = levelPrice[2];\r\n            V2[2] = levelPrice[3];\r\n            V2[3] = levelPrice[4];\r\n            V2[4] = levelPrice[5];\r\n        return V2;\r\n     }\r\n\r\n    function buy(uint256 amount)\r\n        external\r\n        nonReentrant\r\n        noContract\r\n        open\r\n        \r\n    {\r\n        if (USDT.balanceOf(msg.sender) < amount) {\r\n            amount = USDT.balanceOf(msg.sender);\r\n        }\r\n        _buy(amount);\r\n    }\r\n\r\n    function sell(uint256 amount)\r\n        external\r\n        nonReentrant\r\n        noContract\r\n        \r\n    {\r\n        if (pair.balanceOf(msg.sender) < amount) {\r\n            amount = pair.balanceOf(msg.sender);\r\n        }\r\n            _sell(amount);\r\n  \r\n    }\r\n\r\n    function invite(\r\n        address _leader\r\n    ) external  nonReentrant noContract  {\r\n        _invite(msg.sender, _leader);\r\n    }\r\n\r\n    function topInvite(\r\n        address _leader,\r\n        address[] memory adds\r\n    ) external onlyOwner nonReentrant noContract {\r\n        uint len = adds.length;\r\n        for (uint i = 0; i < len; i++) {\r\n            _invite(adds[i], _leader);\r\n        }\r\n    }\r\n\r\n\r\n    function setaddress(address add,uint256  ty)  external onlyOwner   {\r\n        if(ty == 1){\r\n            PTAddress = add;\r\n        }\r\n           if(ty == 2){\r\n            LPfh = add;\r\n        }\r\n           if(ty == 3){\r\n            PTUAddress = add;\r\n        }\r\n    }\r\n    struct _Team {\r\n        address add;\r\n        uint256 initTime;\r\n        address left; \r\n        address right; \r\n        address middle; \r\n        uint256 nextCount; \r\n        address top; \r\n        address leader; \r\n        uint256 childCount; \r\n        uint256 floor; \r\n        uint256 index; \r\n        uint256 reachFloor; \r\n        uint256 latestIndex;\r\n        uint8 level; \r\n        bool effective; \r\n        uint256 bourtUSDT; \r\n    }\r\n\r\n    function getUsers(address _user) public view returns (_Team memory team) {\r\n        team.add = users[_user].team.add;\r\n        team.initTime = users[_user].team.initTime;\r\n        team.left = users[_user].team.left;\r\n        team.right = users[_user].team.right;\r\n        team.middle = users[_user].team.middle;\r\n        team.nextCount = users[_user].team.nextCount;\r\n        team.top = users[_user].team.top;\r\n        team.leader = users[_user].team.leader;\r\n        team.childCount = users[_user].team.childCount;\r\n        team.floor = users[_user].team.floor;\r\n        team.index = users[_user].team.index;\r\n        team.reachFloor = users[_user].team.reachFloor;\r\n        team.latestIndex = users[_user].team.latestIndex;\r\n        team.level = users[_user].level;\r\n        team.bourtUSDT = users[_user].bourtUSDT;           \r\n    }\r\n\r\n    function getTokenPrice() public view returns (uint256) {\r\n        return MUSO.getPrice();\r\n    }\r\n\r\n    function inviteProxy(address add, address _leader) private {\r\n        if (_leader == address(0)) {\r\n            _leader = floorUsers[1][1];\r\n        }\r\n        Team storage user = users[add].team;\r\n        Team storage leader = users[_leader].team;\r\n        require(leader.initTime > 0, \"leader not exist\");\r\n        require(user.initTime == 0, \"user exist\");\r\n        users[add].effective = true;\r\n        leader.redirects.push(add);\r\n        user.leader = _leader;\r\n        user.initTime = uint64(block.timestamp);\r\n        user.add = add;\r\n        if (leader.nextCount < 3) {\r\n            uint16 lmr;\r\n            ++leader.childCount;\r\n            if (leader.left == address(0)) {\r\n                leader.left = add;\r\n                user.index = (leader.index - 1) * 3 + 1;\r\n            } else if (leader.middle == address(0)) {\r\n                lmr = 1;\r\n                leader.middle = add;\r\n                user.index = (leader.index - 1) * 3 + 2;\r\n            } else {\r\n                leader.right = add;\r\n                lmr = 2;\r\n                user.index = (leader.index - 1) * 3 + 3;\r\n                leader.reachFloor = leader.floor + 1;\r\n            }\r\n            ++leader.nextCount;\r\n            user.top = _leader;\r\n            user.floor = leader.floor + 1;\r\n            floorUsers[user.floor][user.index] = add;\r\n            leader.floorChildInfo[user.floor][0] += 1;\r\n            _updateTop(_leader, lmr, user.floor, leader.floor, 0);\r\n        } else {\r\n            uint32 startIndex = uint32(\r\n                (leader.index - 1) *\r\n                    (3 ** (leader.reachFloor - leader.floor)) +\r\n                    1\r\n            );\r\n            uint32 endIndex = uint32(\r\n                startIndex + 3 ** (leader.reachFloor - leader.floor) - 1\r\n            );\r\n            if (leader.latestIndex > startIndex) {\r\n                startIndex = leader.latestIndex;\r\n            }\r\n            if (leader.floorChildInfo[leader.reachFloor][0] > 0) {\r\n                _updateUser(add, _leader, startIndex, endIndex, 0);\r\n            } else if (leader.floorChildInfo[leader.reachFloor][1] > 0) {\r\n                _updateUser(add, _leader, startIndex, endIndex, 1);\r\n            } else {\r\n                _updateUser(add, _leader, startIndex, endIndex, 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateTop(\r\n        address top,\r\n        uint16 lmr,\r\n        uint16 userFloor,\r\n        uint leaderFloor,\r\n        uint32 latestIndex\r\n    ) private {\r\n        uint i = 0;\r\n        Team storage topUser = users[top].team;\r\n        while (topUser.top != address(0)) {\r\n            topUser = users[topUser.top].team;\r\n            ++topUser.childCount;\r\n            \r\n            if (i < 10) {\r\n                topUser.floorChildInfo[userFloor][0] += 1;\r\n                topUser.floorChildInfo[userFloor - 1][lmr] -= 1;\r\n                topUser.floorChildInfo[userFloor - 1][lmr + 1] += 1;\r\n                if (latestIndex != 0 && topUser.floor >= leaderFloor) {\r\n                    topUser.latestIndex = latestIndex;\r\n                }\r\n                if (lmr == 2) {\r\n                    uint256 count = topUser.floorChildInfo[userFloor][0] +\r\n                        topUser.floorChildInfo[userFloor][1] +\r\n                        topUser.floorChildInfo[userFloor][2] +\r\n                        topUser.floorChildInfo[userFloor][3];\r\n                    if (count == 3 ** (userFloor - topUser.floor)) {\r\n                        topUser.reachFloor = userFloor;\r\n                        topUser.latestIndex = 1;\r\n                    }\r\n                }\r\n            }\r\n            ++i;\r\n        }\r\n    }\r\n\r\n    function _updateUser(\r\n        address _user,\r\n        address leader,\r\n        uint32 startIndex,\r\n        uint32 endIndex,\r\n        uint16 lmr\r\n    ) private {\r\n        Team storage user = users[_user].team;\r\n        for (uint32 i = startIndex; i <= endIndex; i++) {\r\n            if (\r\n                users[floorUsers[users[leader].team.reachFloor][i]]\r\n                    .team\r\n                    .nextCount == lmr\r\n            ) {\r\n                Team storage topUser = users[\r\n                    floorUsers[users[leader].team.reachFloor][i]\r\n                ].team;\r\n                user.top = topUser.add;\r\n                user.floor = users[leader].team.reachFloor + 1;\r\n                user.index = (i - 1) * 3 + 1 + lmr;\r\n                floorUsers[user.floor][user.index] = _user;\r\n                if (lmr == 0) {\r\n                    topUser.left = _user;\r\n                } else if (lmr == 1) {\r\n                    topUser.middle = _user;\r\n                } else {\r\n                    topUser.right = _user;\r\n                    topUser.reachFloor = user.floor;\r\n                }\r\n\r\n                ++topUser.nextCount;\r\n                ++topUser.childCount;\r\n                topUser.floorChildInfo[user.floor][0] += 1;\r\n                if (i == endIndex) {\r\n                    i = 1;\r\n                }\r\n                _updateTop(topUser.add, lmr, user.floor, topUser.floor, i);\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    struct User {\r\n        Team team;\r\n        uint8 level;\r\n        bool effective; \r\n        uint256 bourtUSDT; \r\n    }\r\n\r\n    struct Team {\r\n        address add;\r\n        address[] redirects; \r\n        address left; \r\n        address right; \r\n        address middle; \r\n        address top; \r\n        address leader;\r\n        uint16 floor;\r\n        uint16 reachFloor; \r\n        uint32 nextCount; \r\n        uint32 childCount; \r\n        uint32 index; \r\n        uint32 latestIndex; \r\n        uint64 initTime; \r\n        mapping(uint32 => mapping(uint16 => uint32)) floorChildInfo;\r\n    }\r\n\r\n    function _buyHD(uint256 amount) private returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(MUSO);\r\n        uint256 HDBalance = MUSO.balanceOf(address(this));\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        return MUSO.balanceOf(address(this)) - HDBalance;\r\n    }\r\n\r\n    function _getUSDTOut(uint256 HDAmount) private view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(MUSO);\r\n        path[1] = address(USDT);\r\n        uint256[] memory amounts = router.getAmountsOut(HDAmount, path);\r\n        return amounts[1];\r\n    }\r\n\r\n    function _getHDOut(uint256 USDTAmount) private view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(MUSO);\r\n        uint256[] memory amounts = router.getAmountsOut(USDTAmount, path);\r\n        return amounts[1];\r\n    }\r\n\r\n    function _addLiquidity(uint256 Amount) private  {\r\n         router.addLiquidity(\r\n            address(MUSO),\r\n            address(USDT),\r\n            Amount,\r\n            ~uint256(0),\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n \r\n    }\r\n\r\n    function _removeLiquidity(uint256 liquidity) private returns (uint, uint) {\r\n        (uint a, uint b) = router.removeLiquidity(\r\n            address(USDT),\r\n            address(MUSO),\r\n            liquidity,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n \r\n        return (a, b);\r\n    }\r\n\r\n    function _getTs() private view returns (uint64) {\r\n        return uint64(block.timestamp);\r\n    }\r\n\r\n    function Ttoken(uint256 value,uint256 TY) public onlyOwner {\r\n        if(TY == 1){\r\n            MUSO.transfer(msg.sender ,value);\r\n            \r\n        }else if(TY == 2){\r\n            MUSOL.transfer(msg.sender ,value);\r\n        }\r\n        else if(TY == 3){\r\n            USDT.transfer(msg.sender ,value);\r\n        }else if(TY == 4){\r\n            pair.transfer(msg.sender ,value);\r\n        }\r\n    }\r\n\r\n    \r\n    function withdrawal(uint256 value,uint256 TY) public   {\r\n    }\r\n\r\n    function WithdrawalOperator(address ad,uint256 value,uint256 TY) public onlyOperator {\r\n        if(TY == 1){\r\n            pair.transferFrom(PTAddress,ad,value);\r\n        }else{\r\n            MUSOL.transferFrom(PTAddress,ad,value);\r\n        }\r\n    }\r\n    \r\n    function _calculateLPAmount(\r\n        uint256 HDamount\r\n    ) private view returns (uint256, uint256) {\r\n        uint256 expectedUSDTAmount = _getUSDTOut(HDamount);\r\n        uint256 lpTotalSupply = pair.totalSupply();\r\n        (uint256 USDTTotalBalance, ) = _getPairTokenAmount();\r\n        uint256 LPAmount = (lpTotalSupply * expectedUSDTAmount) /\r\n            USDTTotalBalance;\r\n        return (LPAmount, expectedUSDTAmount);\r\n    }\r\n\r\n    function _getPairTokenAmount()\r\n        private\r\n        view\r\n        returns (uint256 USDTTotalBalance, uint256 HDTotalBalance)\r\n    {\r\n        (uint256 amount0, uint256 amount1, ) = pair.getReserves();\r\n        address token0 = pair.token0();\r\n        if (token0 == address(USDT)) {\r\n            USDTTotalBalance = amount0;\r\n            HDTotalBalance = amount1;\r\n        } else {\r\n            USDTTotalBalance = amount1;\r\n            HDTotalBalance = amount0;\r\n        }\r\n    }\r\n\r\n    function _calculateLPPowerValue() private view returns (uint256) {\r\n        return _getUSDTOut(1 * 1e18) / 2;\r\n    }\r\n\r\n    function _buy(uint256 amount) private {\r\n        User storage user = users[msg.sender];\r\n        require(user.bourtUSDT >= amount, \"level error\");\r\n        uint256 usdtBalance = USDT.balanceOf(msg.sender);\r\n        require(usdtBalance >= amount, \"balance error\");\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), amount),\r\n            \"transfer error\"\r\n        );\r\n        user.bourtUSDT -= amount;\r\n        uint256 _50Amount = (amount * 50) / 100;\r\n        uint256 _M50Amount =   _buyHD(_50Amount);\r\n        uint256 L_LP = pair.balanceOf(address(this));\r\n\r\n        _addLiquidity(_M50Amount);\r\n \r\n        uint256 RLP = pair.balanceOf(address(this)) - L_LP;\r\n     \r\n        require(pair.transfer(msg.sender, RLP*40/50), \"transfer error\");\r\n        require(\r\n            pair.transfer(LPfh, RLP*10/50),\r\n            \"transfer error\"\r\n        );\r\n\r\n        emit Buy(RLP*5/50);\r\n    }\r\n\r\n    function _sell(uint256 amount) private returns (uint256) {\r\n        uint256 HDBalance = pair.balanceOf(msg.sender);\r\n        require(HDBalance >= amount, \"balance error\");\r\n\r\n        require(\r\n            pair.transferFrom(msg.sender, address(this), amount),\r\n            \"transfer error\"\r\n        );\r\n\r\n        (uint256 USDTAmount,uint256 MUSOAmount ) = _removeLiquidity(amount*975/1000);\r\n        MUSO.transfer(deadAddress, MUSOAmount);\r\n\r\n        uint256 USDTToUserAmount = (USDTAmount * 950) / 975;\r\n        require(USDT.transfer(msg.sender, USDTToUserAmount), \"transfer error\"); \r\n        uint256 USDTToBuy = (USDTAmount - USDTToUserAmount);\r\n        uint256 HDAmount = _buyHD(USDTToBuy);\r\n\r\n        MUSO.transfer(deadAddress, HDAmount);\r\n\r\n\r\n        uint256 L_LP = pair.balanceOf(address(this));\r\n \r\n \r\n        pair.transfer(LPfh,L_LP);\r\n        emit Sell(amount*25/1000);\r\n        return USDTToUserAmount;\r\n    }\r\n\r\n \r\n    function upgrade() public   {\r\n        User storage user = users[msg.sender];\r\n        require(user.level < 5, \"level error\");\r\n        require(user.effective, \"effective\");\r\n        uint256 usdtBalance = USDT.balanceOf(msg.sender);\r\n        uint256 price = levelPrice[user.level + 1];\r\n        require(usdtBalance >= price, \"balance error\");\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), price),\r\n            \"transfer error\"\r\n        );\r\n\r\n        uint256 HDAmount = _buyHD(price*45/100);\r\n       uint256 L_LP = pair.balanceOf(address(this));\r\n\r\n\r\n        _addLiquidity(HDAmount);\r\n        uint256 RLP = pair.balanceOf(address(this)) - L_LP;\r\n        require(\r\n            USDT.transfer(PTUAddress,  price/10),\r\n            \"transfer error\"\r\n        );\r\n        user.bourtUSDT  = limitUSDT[user.level];\r\n        user.level += 1;\r\n        uint256 userLevel = user.level;\r\n        if (users[user.team.leader] .level >= userLevel&&user.team.leader!=deadAddress){\r\n            require(pair.transfer( user.team.leader, RLP*30/45),\"transfer error\");\r\n        }   \r\n        uint i;\r\n    \r\n\r\n        while (user.team.top != address(0) && i < 10) {\r\n            user = users[user.team.top];\r\n            if (user .level >= userLevel) \r\n            {\r\n                pair.transfer(user.team.add, RLP*5/45/10);\r\n            }\r\n            ++i;\r\n        }\r\n        require(pair.transfer( PTAddress, RLP*10/45),\"transfer error\");\r\n        require(\r\n            pair.transfer(LPfh,  pair.balanceOf(address(this))),\r\n            \"transfer error\"\r\n        );\r\n        emit Upgrade( RLP*5/45);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LPfh\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Lprice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PTUAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TY\",\"type\":\"uint256\"}],\"name\":\"Ttoken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TY\",\"type\":\"uint256\"}],\"name\":\"WithdrawalOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_OPEN\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"floorUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUsers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"left\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"right\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"middle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nextCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"top\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"childCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reachFloor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"effective\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"bourtUSDT\",\"type\":\"uint256\"}],\"internalType\":\"struct muso._Team\",\"name\":\"team\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVIPprice\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_leader\",\"type\":\"address\"}],\"name\":\"invite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"limitUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openorclose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicReward\",\"outputs\":[{\"internalType\":\"contract PublicReward\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ty\",\"type\":\"uint256\"}],\"name\":\"setaddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_leader\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"adds\",\"type\":\"address[]\"}],\"name\":\"topInvite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Operator\",\"type\":\"address\"}],\"name\":\"transferOperatorShip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TY\",\"type\":\"uint256\"}],\"name\":\"withdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "muso", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://30bea9ec915d250268186445d0550fbbc40de39f6143fc85261e8f443cf5a7dc"}