{"SourceCode": "pragma solidity 0.8.13;\r\n// SPDX-License-Identifier: MIT\r\n// https://fairtoken.info\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface ProcessingRouter {\r\n    function addToLottery(address _tokenAddress, uint256 _amount) external returns(bool);\r\n    function addToLotteryAfterSwap(address _tokenAddress) external returns(bool);\r\n    function addToClaimable(address _tokenAddress, uint256 _amount) external returns(bool);\r\n    function addToClaimableAfterSwap(address _tokenAddress) external returns(bool);\r\n    function claim(address account) external;\r\n}\r\n\r\ninterface PancakeSwapFactoryV2 {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface PancakeSwapRouterV2 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n    function factory() external pure returns (address);\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) \r\n        external \r\n        returns (uint256[] memory amounts);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        _owner = msg.sender;\r\n    }\r\n    \r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract FAIRTOKEN is Ownable {\r\n    using SafeMath for uint256;\r\n    string public name = \"FairToken\";\r\n    string public symbol = \"FRT\";\r\n    uint256 public totalSupply = 1000000000e18;\r\n    uint256 private dividendTokens = 0;\r\n    uint8 public decimals = 18;\r\n    uint256 public deadBlocks = 2;\r\n    bool public isTradingEnabled = false;\r\n    bool public lockIsEnabled = true;\r\n    bool public lotteryIsEnabled = true;\r\n    bool public antibot = true;\r\n    uint256 private startBlock;\r\n    uint256 public burnFee = 500; // 5% OR M\r\n    uint256 public marketingFee = 500; // 5% OR B\r\n    uint256 public lotteryFee = 500; // 5%\r\n    uint256 public holderFee = 1000; // 10%\r\n    uint256 public buyLimitLiquidity = 100; // 1%\r\n    uint256 public blockTimeout = 10; // Blocks transaction interval for user\r\n    uint256 public maxTxAmount = totalSupply;\r\n    uint256 public lockReleaseTime = 259200; // 259200\r\n    uint256 public lockReleasePercent = 1000; // 10%\r\n    uint public holders;\r\n    PancakeSwapRouterV2 private _pancakeRouterV2 = PancakeSwapRouterV2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    address public _dead = 0x000000000000000000000000000000000000dEaD;\r\n    address public _marketing = 0x41ACf4c87319b48b85aC41bb577D57FF7976fbCc;\r\n    ProcessingRouter private _processingRouter = ProcessingRouter(0x0000000000000000000000000000000000000000);\r\n    IERC20 private _busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n    address public pair;\r\n\r\n    event Unlock(address indexed _from, uint256 _value);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    struct lockStructure {\r\n        uint256 startLockTimestamp;\r\n        uint256 unlockInterval;\r\n        uint256 unlocksNum;\r\n        uint256 percentUnlock;\r\n        uint256 allLockedAmount;\r\n        uint256 countUnlocks;\r\n        uint256 UnLockedAmount;\r\n    }\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => uint256) public lockedBalanceOf;\r\n    mapping(address => uint256) public userUnlocks;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    mapping(address => bool) public isBlacklisted;\r\n    mapping(address => bool) public isWhitelisted;\r\n    mapping(address => bool) public isDisabledFee;\r\n    mapping(address => bool) public isDisabledDividends;\r\n    mapping(uint256 => address) public HolderList;\r\n    mapping(address => uint256) public HolderID;\r\n    mapping(address => uint256) public lastTransfer;\r\n    mapping(address => lockStructure[]) userLockList;\r\n\r\n    constructor() {\r\n        balanceOf[msg.sender] = totalSupply;\r\n        isWhitelisted[msg.sender] = true;\r\n        isWhitelisted[address(this)] = true;\r\n        isWhitelisted[_marketing] = true;\r\n        isDisabledDividends[address(this)] = true;\r\n        isDisabledDividends[_dead] = true;\r\n        isDisabledDividends[msg.sender] = true;\r\n        HolderList[holders] = msg.sender;\r\n        HolderID[msg.sender] = holders;\r\n        holders++;\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    function _burn(address _from, uint256 _amount) internal returns (bool success) {\r\n        _checkDividends(_from, _dead, _amount);\r\n        balanceOf[_from] -= _amount;\r\n        balanceOf[_dead] += _amount;\r\n        emit Transfer(_from, _dead, _amount);\r\n        return true;\r\n    }\r\n\r\n    function _toMarketing(address _from, uint256 _amount) private returns (bool success) {\r\n        _checkDividends(_from, _marketing, _amount);\r\n        balanceOf[_from] -= _amount;\r\n        balanceOf[_marketing] += _amount;\r\n        emit Transfer(_from, _marketing, _amount);\r\n        return true;\r\n    }\r\n    function _toTokenAddress(address _from, uint256 _amount) private returns (bool success) {\r\n        _checkDividends(_from, address(this), _amount);\r\n        balanceOf[_from] -= _amount;\r\n        balanceOf[address(this)] += _amount;\r\n        emit Transfer(_from, address(this), _amount);\r\n        return true;\r\n    }\r\n    function _toProcessing(address _from, uint256 _amount) private returns (bool success) {\r\n        _checkDividends(_from, address(_processingRouter), _amount);\r\n        balanceOf[_from] -= _amount;\r\n        balanceOf[address(_processingRouter)] += _amount;\r\n        emit Transfer(_from, address(_processingRouter), _amount);\r\n        return true;\r\n    }\r\n    function _toSwapAndProcessing(address _from, uint256 _amount) private returns (bool success) {\r\n        if(address(_processingRouter) == address(0)) return false;\r\n        _toTokenAddress(_from, _amount);\r\n        swapTokenForBusd(_amount, address(_processingRouter));\r\n        return true;\r\n    }\r\n    function _getPathForSwap() private view returns (address[] memory) {\r\n    address[] memory path = new address[](2);\r\n    path[0] = address(this);\r\n    path[1] = address(_busd);\r\n    return path;\r\n    }\r\n    function swapTokenForBusd(uint256 _amount, address _to) private returns(bool) {\r\n    _pancakeRouterV2.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                       _amount,\r\n                       0,\r\n                       _getPathForSwap(),\r\n                       _to,\r\n                       block.timestamp\r\n                       );\r\n     return true;\r\n    }\r\n    function _toProcessingClaimable(address _from, uint256 _amount) private returns (bool success) {\r\n        if(address(_processingRouter) == address(0)) return false;\r\n        _toProcessing(_from, _amount);\r\n        _processingRouter.addToClaimable(address(this), _amount);\r\n        return true;\r\n    }\r\n    function _toSwapAndProcessingClaimable(address _from, uint256 _amount) private returns (bool success) {\r\n        if(address(_processingRouter) == address(0)) return false;\r\n        _toSwapAndProcessing(_from, _amount);\r\n        _processingRouter.addToClaimableAfterSwap(address(_busd));\r\n        return true;\r\n    }\r\n\r\n    function _toProcessingLottery(address _from, uint256 _amount) private returns (bool success) {\r\n        if(address(_processingRouter) == address(0)) return false;\r\n        _toProcessing(_from, _amount);\r\n        _processingRouter.addToLottery(address(this), _amount);\r\n        return true;\r\n    }\r\n    function _toSwapAndProcessingLottery(address _from, uint256 _amount) private returns (bool success) {\r\n        if(address(_processingRouter) == address(0)) return false;\r\n        _toSwapAndProcessing(_from, _amount);\r\n        _processingRouter.addToLotteryAfterSwap(address(_busd));\r\n        return true;\r\n    }\r\n    function getTokenPricePair(uint256 _amount) public view returns (uint256 _tokenPrice) {\r\n        if(pair == address(0)) return 0;\r\n         uint256[] memory price = _pancakeRouterV2.getAmountsOut(_amount, _getPathForSwap());\r\n      return price[price.length-1];\r\n    }\r\n    function getLiquidity() public view returns (uint256[] memory) {\r\n    uint256[] memory liquidity = new uint256[](2);\r\n    if(pair == address(0)) {\r\n    liquidity[0] = 0;\r\n    liquidity[1] = 0;\r\n    } else {\r\n    liquidity[0] = balanceOf[pair];\r\n    liquidity[1] = _busd.balanceOf(pair);\r\n    }\r\n    return liquidity;\r\n    }\r\n    function checkBuylimitLiquidity() public view returns (uint256 _limitVal) {\r\n        if(pair == address(0))  return totalSupply;\r\n        if(buyLimitLiquidity == 0)  return totalSupply;\r\n         uint256 tokenLiquidity = balanceOf[pair];\r\n         uint256 buyLimitLiq = tokenLiquidity.mul(buyLimitLiquidity).div(10000);\r\n      return buyLimitLiq;\r\n    }\r\n    function storeLocker(address _to, uint256 holdTimeInterval, uint256 _percentUnlock, uint256 _amount) internal returns (bool success) {\r\n        uint256 _unlocksNum = uint256(100).mul(_percentUnlock).div(10000);\r\n        lockStructure memory lockstructure = lockStructure(block.timestamp, holdTimeInterval, _unlocksNum, _percentUnlock, _amount, uint256(0), uint256(0));\r\n        userLockList[_to].push(lockstructure);\r\n        return true;\r\n    }\r\n    function getUnlockedTokens() public view returns (uint256 _unlockedValue) {\r\n      lockStructure[] storage lockstructure = userLockList[msg.sender];\r\n      uint256 unlockedSum = 0;\r\n      for (uint256 i = userUnlocks[msg.sender]; i < lockstructure.length; i++) {\r\n        if (lockstructure[i].startLockTimestamp.add(lockstructure[i].unlockInterval.mul(lockstructure[i].countUnlocks.add(1))) < block.timestamp) {\r\n          uint256 countUnlocks = block.timestamp.sub(lockstructure[i].startLockTimestamp).div(lockstructure[i].unlockInterval).sub(lockstructure[i].countUnlocks);\r\n          if(countUnlocks >= lockstructure[i].unlocksNum.sub(lockstructure[i].countUnlocks)) {\r\n              countUnlocks = lockstructure[i].unlocksNum.sub(lockstructure[i].countUnlocks);\r\n          }\r\n          if(countUnlocks > 0) {\r\n          uint256 percentUnlocks = lockstructure[i].percentUnlock.mul(countUnlocks);\r\n          uint256 balanceToUnlock = lockstructure[i].allLockedAmount.mul(percentUnlocks).div(10000);\r\n          if(lockstructure[i].countUnlocks.add(countUnlocks) == lockstructure[i].unlocksNum) {\r\n              balanceToUnlock = lockstructure[i].allLockedAmount.sub(lockstructure[i].UnLockedAmount);\r\n          }\r\n          if(balanceToUnlock > lockedBalanceOf[msg.sender]) { balanceToUnlock = lockedBalanceOf[msg.sender]; }\r\n          unlockedSum += balanceToUnlock;\r\n          }\r\n        }\r\n      }\r\n      return unlockedSum;\r\n    }\r\n\r\n    function unlockTokens() external {\r\n      lockStructure[] storage lockstructure = userLockList[msg.sender];\r\n      uint256 unlockedSum = 0;\r\n      for (uint256 i = userUnlocks[msg.sender]; i < lockstructure.length; i++) {\r\n        if (lockstructure[i].startLockTimestamp.add(lockstructure[i].unlockInterval.mul(lockstructure[i].countUnlocks.add(1))) < block.timestamp && lockstructure[i].countUnlocks < lockstructure[i].unlocksNum) {\r\n          uint256 countUnlocks = block.timestamp.sub(lockstructure[i].startLockTimestamp).div(lockstructure[i].unlockInterval).sub(lockstructure[i].countUnlocks);\r\n          if(countUnlocks >= lockstructure[i].unlocksNum.sub(lockstructure[i].countUnlocks)) {\r\n              countUnlocks = lockstructure[i].unlocksNum.sub(lockstructure[i].countUnlocks);\r\n          }\r\n          if(countUnlocks > 0) {\r\n          uint256 percentUnlocks = lockstructure[i].percentUnlock.mul(countUnlocks);\r\n          uint256 balanceToUnlock = lockstructure[i].allLockedAmount.mul(percentUnlocks).div(10000);\r\n          if(lockstructure[i].countUnlocks.add(countUnlocks) == lockstructure[i].unlocksNum) {\r\n              balanceToUnlock = lockstructure[i].allLockedAmount.sub(lockstructure[i].UnLockedAmount);\r\n          }\r\n          if(balanceToUnlock > lockedBalanceOf[msg.sender]) { balanceToUnlock = lockedBalanceOf[msg.sender]; }\r\n          lockedBalanceOf[msg.sender] -= balanceToUnlock;\r\n          lockstructure[i].UnLockedAmount += balanceToUnlock;\r\n          lockstructure[i].countUnlocks += countUnlocks;\r\n          unlockedSum += balanceToUnlock;\r\n          if(lockstructure[i].allLockedAmount <= lockstructure[i].UnLockedAmount || lockstructure[i].countUnlocks >= lockstructure[i].unlocksNum) {\r\n          userUnlocks[msg.sender]++;\r\n          }\r\n          emit Unlock(msg.sender, balanceToUnlock);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    function getUserLockers() external view returns(uint256 _locksCount) {\r\n        return userLockList[msg.sender].length;\r\n    }\r\n    function getLockerDetails(address _owner, uint256 _index) external view returns(uint256 startLockTimestamp, uint256 unlockInterval, uint256 percentUnlock, uint256 allLockedAmount, uint256 UnLockedAmount, uint256 unlocksNum, uint256 countUnlocks) {\r\n        if(msg.sender != owner()) {\r\n            require(_owner == msg.sender, \"You don't have permission to view this lockup\");\r\n        }\r\n        lockStructure memory lockstructure = userLockList[_owner][_index];\r\n        startLockTimestamp = lockstructure.startLockTimestamp;\r\n        unlockInterval = lockstructure.unlockInterval;\r\n        percentUnlock = lockstructure.percentUnlock;\r\n        allLockedAmount = lockstructure.allLockedAmount;\r\n        unlocksNum = lockstructure.unlocksNum;\r\n        countUnlocks = lockstructure.countUnlocks;\r\n        UnLockedAmount = lockstructure.UnLockedAmount;\r\n    }\r\n\r\n    function _checkDividends(address _from, address _to, uint256 _value) private {\r\n       if(isDisabledDividends[_from] && isDisabledDividends[_to]) {\r\n           return;\r\n       }\r\n       if(!isDisabledDividends[_from] && isDisabledDividends[_to]) {\r\n           if(address(_processingRouter) != address(0) && address(_processingRouter) != _from && address(_processingRouter) != _to) _processingRouter.claim(_from);\r\n           if(dividendTokens >= _value) dividendTokens -= _value;\r\n           return;\r\n       }\r\n       if(isDisabledDividends[_from] && !isDisabledDividends[_to]) {\r\n           if(address(_processingRouter) != address(0) && address(_processingRouter) != _from && address(_processingRouter) != _to) _processingRouter.claim(_to);\r\n           if(dividendTokens.add(_value) <= totalSupply) dividendTokens += _value;\r\n           return;\r\n       }\r\n       if(!isDisabledDividends[_from] && !isDisabledDividends[_to]) {\r\n            if(address(_processingRouter) != address(0) && address(_processingRouter) != _from && address(_processingRouter) != _to) { \r\n            _processingRouter.claim(_from);\r\n            _processingRouter.claim(_to); \r\n            }\r\n           return;\r\n       }\r\n    }\r\n\r\n    function _beforeTransfer(address _from, address _to, uint256 _value) internal returns (uint256 _newValue) {\r\n\r\n        if (!isWhitelisted[_from] && !isWhitelisted[_to]) {\r\n            require(isTradingEnabled, \"Trading is disabled\");\r\n            require(!isBlacklisted[_from] && !isBlacklisted[_to], \"Blacklisted address\");\r\n            require(balanceOf[_from].sub(lockedBalanceOf[_from]) > _value, \"Not enought on balance, or some value in locked\");\r\n            require(_value <= maxTxAmount, \"amount must be lower maxTxAmount\");\r\n            \r\n            if (_from == pair) { \r\n                require(balanceOf[_to].add(_value) <= checkBuylimitLiquidity(), \"amount must be lower than buy Limit Liquidity\");\r\n                lastTransfer[_to] = block.number;\r\n            }\r\n            if (_to == pair) {\r\n                 require(lastTransfer[_from].add(blockTimeout) <= block.number, \"not time yet\");\r\n            }\r\n            if (antibot) {\r\n                if (startBlock.add(deadBlocks) >= block.number) {\r\n                    isBlacklisted[_to] = true;\r\n                } else {\r\n                    antibot = false;\r\n                }\r\n            }\r\n            if(!isDisabledFee[_from]) {\r\n                uint256 feeAmount = 0;\r\n                if (_from == pair && marketingFee > 0) {\r\n                feeAmount = _value.mul(marketingFee).div(10000);\r\n                _toMarketing(_from, feeAmount);\r\n                } else if (burnFee > 0) { \r\n                feeAmount = _value.mul(burnFee).div(10000);\r\n                _burn(_from, feeAmount);\r\n                }\r\n                if(address(_processingRouter) != address(0)) {\r\n                 if(lotteryFee > 0) { \r\n                    if (_to == pair) {\r\n                    feeAmount += _value.mul(lotteryFee).div(10000); \r\n                     _toSwapAndProcessingLottery(_from, _value.mul(lotteryFee).div(10000));\r\n                    } else { \r\n                    feeAmount += _value.mul(lotteryFee).div(10000);\r\n                     _toProcessingLottery(_from, _value.mul(lotteryFee).div(10000));\r\n                    }\r\n                 }\r\n                 if(holderFee > 0) { \r\n                  feeAmount += _value.mul(holderFee).div(10000);\r\n                  if (_to == pair) {\r\n                  _toSwapAndProcessingClaimable(_from, _value.mul(holderFee).div(10000));\r\n                  } else { \r\n                  _toProcessingClaimable(_from, _value.mul(holderFee).div(10000));\r\n                  }\r\n                 }\r\n                }\r\n                uint256 newAmount = _value - feeAmount;\r\n                _checkDividends(_from, _to, newAmount);\r\n                return newAmount;\r\n            } else {\r\n                _checkDividends(_from, _to, _value);\r\n                return _value;\r\n            }\r\n        }\r\n        _checkDividends(_from, _to, _value);\r\n        return _value;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool success) {\r\n        uint256 _newValue = _beforeTransfer(_from, _to, _value);\r\n        if (_from == pair && lockIsEnabled) { \r\n                storeLocker(_to, lockReleaseTime, lockReleasePercent, _newValue); // lock with unlock 10%\r\n                lockedBalanceOf[_to] += _newValue;\r\n        }\r\n        balanceOf[_from] -= _newValue;\r\n        balanceOf[_to] += _newValue;\r\n        \r\n        if(balanceOf[_to] - _newValue == 0 && HolderID[_to] == 0 && _to != owner()) { HolderList[holders] = _to; HolderID[_to] = holders; holders++; }\r\n       // if(balanceOf[_from] == 0) holders--;\r\n        emit Transfer(_from, _to, _newValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    function getDividendTokens() public view returns (uint256 _DividendTokens) {\r\n        return dividendTokens;\r\n    }\r\n    function getHolders() public view returns (uint256 _Holders) {\r\n        return holders;\r\n    }\r\n    function getHolder(uint256 _index) public view returns (address _HolderAddress) {\r\n        return HolderList[_index];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        _transfer(_from, _to, _value);\r\n        allowance[_from][msg.sender] -= _value;\r\n        return true;\r\n    }\r\n\r\n    function setDeadBlocks(uint256 _deadBlocks) public onlyOwner {\r\n        deadBlocks = _deadBlocks;\r\n    }\r\n\r\n    function setisBlacklisted(address account, bool value) public onlyOwner {\r\n        isBlacklisted[account] = value;\r\n    }\r\n\r\n    function setisDisabledFee(address account, bool value) public onlyOwner {\r\n        isDisabledFee[account] = value;\r\n    }\r\n\r\n    function _setisDisabledDividends(address account, bool value) private {\r\n     if(isDisabledDividends[account] != value) {\r\n        if(balanceOf[account] > 0 && value) { \r\n          dividendTokens -= balanceOf[account];\r\n        } else if(balanceOf[account] > 0 && !value) {\r\n          dividendTokens += balanceOf[account];\r\n        }\r\n     }\r\n        isDisabledDividends[account] = value;\r\n    }\r\n    function setisDisabledDividends(address account, bool value) public onlyOwner {\r\n        return _setisDisabledDividends(account, value);\r\n    }\r\n\r\n    function multisetisBlacklisted(address[] calldata accounts, bool value) public onlyOwner {\r\n        for (uint256 i = 0; i < accounts.length; i++) {\r\n            isBlacklisted[accounts[i]] = value;\r\n        }\r\n    }\r\n\r\n    function setisWhitelisted(address account, bool value) public onlyOwner {\r\n        isWhitelisted[account] = value;\r\n    }\r\n\r\n    function setBurnFee(uint256 value) public onlyOwner {\r\n        require(value <= 5, \"must be lower 5\");\r\n        marketingFee = value*100;\r\n    }\r\n\r\n    function setMarketingFee(uint256 value) public onlyOwner {\r\n        require(value <= 5, \"must be lower 5\");\r\n        marketingFee = value*100;\r\n    }\r\n\r\n    function setLotteryFee(uint256 value) public onlyOwner {\r\n        require(value <= 5, \"must be lower 5\");\r\n        lotteryFee = value*100;\r\n    }\r\n\r\n    function setHolderFee(uint256 value) public onlyOwner {\r\n        require(value <= 10, \"must be lower 10\");\r\n        holderFee = value*100;\r\n    }\r\n\r\n    function setbuyLimitLiquidity(uint256 value) public onlyOwner {\r\n        require(value >= 0);\r\n        buyLimitLiquidity = value;\r\n    }\r\n\r\n    function setAntibot(bool value) public onlyOwner {\r\n        antibot = value;\r\n    }\r\n\r\n    function setLocksWhenBuy(bool value) public onlyOwner {\r\n        lockIsEnabled = value;\r\n    }\r\n\r\n    function setLotteryIsEnabled(bool value) public onlyOwner {\r\n        lotteryIsEnabled = value;\r\n    }\r\n\r\n    function openTrade(uint256 _amountTokens) external onlyOwner {\r\n        require(!isTradingEnabled, \"Trading is already enabled!\");\r\n        allowance[address(this)][address(_pancakeRouterV2)] = totalSupply;\r\n        uint256 _busdAmount = _busd.balanceOf(address(this));\r\n        require(_busdAmount > 0, \"Zero Amount of pair token on contract\");\r\n        _busd.approve(address(_pancakeRouterV2), ~uint256(0));\r\n        uint256 _tokenAmount = _amountTokens.mul(1e18);\r\n        pair = PancakeSwapFactoryV2(_pancakeRouterV2.factory()).createPair(address(this), address(_busd));\r\n        _pancakeRouterV2.addLiquidity(address(this),address(_busd),_tokenAmount,_busdAmount,_tokenAmount,_busdAmount,owner(),block.timestamp);\r\n        IERC20(pair).approve(address(_pancakeRouterV2), ~uint256(0));\r\n        isTradingEnabled = true;\r\n        _setisDisabledDividends(pair, true);\r\n        startBlock = block.number;\r\n    }\r\n\r\n    function openTradeManual(address _pairSet) external onlyOwner {\r\n        require(!isTradingEnabled, \"Trading is already enabled!\");\r\n        require(_busd.balanceOf(_pairSet) > 0 && balanceOf[_pairSet] > 0, \"Pair of tokens has Zero liquidity\");\r\n        allowance[address(this)][address(_pancakeRouterV2)] = totalSupply;\r\n        _busd.approve(address(_pancakeRouterV2), ~uint256(0));\r\n        pair = _pairSet;\r\n        IERC20(pair).approve(address(_pancakeRouterV2), ~uint256(0));\r\n        isTradingEnabled = true;\r\n        _setisDisabledDividends(pair, true);\r\n        startBlock = block.number;\r\n    }\r\n\r\n    function setRouter(address newRouter) public onlyOwner returns (bool success) {\r\n        _pancakeRouterV2 = PancakeSwapRouterV2(newRouter);\r\n        return true;\r\n    }\r\n\r\n    function setBUSD(address newBusd) public onlyOwner returns (bool success) {\r\n        _busd = IERC20(newBusd);\r\n        return true;\r\n    }\r\n\r\n    function setMaxTxAmount(uint256 amount) public onlyOwner returns (bool success) {\r\n        require(amount <= totalSupply, \"cant be more than totalSupply\");\r\n        require(amount > 0, \"cant be zero!\");\r\n        maxTxAmount = amount;\r\n        return true;\r\n    }\r\n\r\n    function setBlockTimeout(uint256 newBlockTimeout) public onlyOwner returns (bool success) {\r\n        require(newBlockTimeout <= 28800, \"cant be more when 1 day!\");\r\n        blockTimeout = newBlockTimeout;\r\n        return true;\r\n    }\r\n\r\n    function setDead(address newDead) public onlyOwner returns (bool success) {\r\n        _dead = newDead;\r\n        return true;\r\n    }\r\n    function setMarketing(address newMarketing) public onlyOwner returns (bool success) {\r\n        _marketing = newMarketing;\r\n        return true;\r\n    }\r\n    function setLockReleaseTime(uint256 _newLockReleaseTime) public onlyOwner returns (bool success) {\r\n        require(_newLockReleaseTime <= 2592000, \"cant be more when 30 days!\");\r\n        lockReleaseTime = _newLockReleaseTime;\r\n        return true;\r\n    }\r\n    function setLockReleasePercent(uint256 _newLockReleasePercent) public onlyOwner returns (bool success) {\r\n        require(_newLockReleasePercent <= 100 && _newLockReleasePercent > 1, \"Lock must be from 1 to 100\");\r\n        lockReleasePercent = _newLockReleasePercent*100;\r\n        return true;\r\n    }\r\n    \r\n    function setProcessingRouter(address newProcessing) public onlyOwner returns (bool success) {\r\n       if(address(_processingRouter) != address(0)) {  \r\n        isWhitelisted[address(_processingRouter)] = false;\r\n        _setisDisabledDividends(address(_processingRouter), false);\r\n       }\r\n       if(newProcessing != address(0)) {  \r\n       isWhitelisted[newProcessing] = true;\r\n        _setisDisabledDividends(newProcessing, true);\r\n       }\r\n        _processingRouter = ProcessingRouter(newProcessing);\r\n        \r\n        return true;\r\n    }\r\n\r\n    function setPair(address newPair) public onlyOwner returns (bool success) {\r\n        _setisDisabledDividends(pair, false);\r\n        _setisDisabledDividends(newPair, true);\r\n        pair = newPair;\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Unlock\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"HolderID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"HolderList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_dead\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketing\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antibot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLimitLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkBuylimitLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_limitVal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDividendTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_DividendTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getHolder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_HolderAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_Holders\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLockerDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startLockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentUnlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allLockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"UnLockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlocksNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"countUnlocks\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getTokenPricePair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_unlockedValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserLockers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_locksCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holderFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDisabledDividends\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDisabledFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockIsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockReleasePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockReleaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryIsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"multisetisBlacklisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountTokens\",\"type\":\"uint256\"}],\"name\":\"openTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pairSet\",\"type\":\"address\"}],\"name\":\"openTradeManual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAntibot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBusd\",\"type\":\"address\"}],\"name\":\"setBUSD\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBlockTimeout\",\"type\":\"uint256\"}],\"name\":\"setBlockTimeout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setBurnFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDead\",\"type\":\"address\"}],\"name\":\"setDead\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deadBlocks\",\"type\":\"uint256\"}],\"name\":\"setDeadBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setHolderFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLockReleasePercent\",\"type\":\"uint256\"}],\"name\":\"setLockReleasePercent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLockReleaseTime\",\"type\":\"uint256\"}],\"name\":\"setLockReleaseTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setLocksWhenBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setLotteryFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setLotteryIsEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMarketing\",\"type\":\"address\"}],\"name\":\"setMarketing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMarketingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPair\",\"type\":\"address\"}],\"name\":\"setPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newProcessing\",\"type\":\"address\"}],\"name\":\"setProcessingRouter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setbuyLimitLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setisBlacklisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setisDisabledDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setisDisabledFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setisWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userUnlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FAIRTOKEN", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ca24b76c668e0376eddae9f9407462fde3879286ad4b7f0149a8ebc2648aeeab"}