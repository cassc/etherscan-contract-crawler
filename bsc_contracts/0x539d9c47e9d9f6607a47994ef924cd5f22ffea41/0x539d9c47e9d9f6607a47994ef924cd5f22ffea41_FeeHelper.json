{"SourceCode": "{\"AntiBot.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Storage.sol\\\";\\r\\n\\r\\nimport \\\"./IMintFactory.sol\\\";\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract AntiBotFacet is Storage, Ownable {\\r\\n\\r\\n    // AntiBot\\r\\n\\r\\n    function antiBotIsActiveModifier() view internal {\\r\\n        require(antiBotSettings.isActive, \\\"ABD\\\");\\r\\n    }\\r\\n\\r\\n    modifier antiBotIsActive() {\\r\\n        antiBotIsActiveModifier();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setIncrement(uint256 _updatedIncrement) public onlyOwner antiBotIsActive {\\r\\n        antiBotSettings.increment = _updatedIncrement;\\r\\n        emit UpdatedAntiBotIncrement(_updatedIncrement);\\r\\n    }\\r\\n\\r\\n    function setEndDate( uint256 _updatedEndDate) public onlyOwner antiBotIsActive {\\r\\n        require(_updatedEndDate \\u003c= 48, \\\"ED\\\");\\r\\n        antiBotSettings.endDate = _updatedEndDate;\\r\\n        emit UpdatedAntiBotEndDate(_updatedEndDate);\\r\\n    }\\r\\n\\r\\n    function setInitialMaxHold( uint256 _updatedInitialMaxHold) public onlyOwner antiBotIsActive {\\r\\n        antiBotSettings.initialMaxHold = _updatedInitialMaxHold;\\r\\n        emit UpdatedAntiBotInitialMaxHold(_updatedInitialMaxHold);\\r\\n    }\\r\\n\\r\\n    function updateAntiBot(bool _isActive) public onlyOwner {\\r\\n        require(!marketInit, \\\"AMIE\\\");\\r\\n        antiBotSettings.isActive = _isActive;\\r\\n        emit UpdatedAntiBotActiveStatus(_isActive);\\r\\n    }\\r\\n\\r\\n    function antiBotCheck(uint256 amount, address receiver) public returns(bool) {\\r\\n        // restrict it to being only called by registered tokens\\r\\n        require(IMintFactory(factory).tokenIsRegistered(address(this)));\\r\\n        require(marketInit, \\\"AMIE\\\");\\r\\n        if(block.timestamp \\u003e marketInitBlockTime + (antiBotSettings.endDate * 1 hours)) {\\r\\n            antiBotSettings.isActive = false;\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        antiBotBalanceTracker[receiver] += amount;\\r\\n        uint256 userAntiBotBalance = antiBotBalanceTracker[receiver];\\r\\n        uint256 maxAntiBotBalance = ((block.number - antiBotSettings.startBlock) * antiBotSettings.increment) + antiBotSettings.initialMaxHold;\\r\\n\\r\\n        require((userAntiBotBalance \\u003c= maxAntiBotBalance), \\\"ABMSA\\\");\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // MaxBalanceAfterBuy\\r\\n   \\r\\n    function addMaxBalanceWhitelistedAddress(address _address) public onlyOwner {\\r\\n        require(taxSettings.maxBalanceAfterBuy, \\\"AMBABD\\\");\\r\\n        maxBalanceWhitelist[_address] = true;\\r\\n        emit AddedMaxBalanceWhitelistAddress(_address);\\r\\n    }\\r\\n\\r\\n    function removeMaxBalanceWhitelistedAddress(address _address) public onlyOwner {\\r\\n        require(taxSettings.maxBalanceAfterBuy, \\\"AMBABD\\\");\\r\\n        maxBalanceWhitelist[_address] = false;\\r\\n        emit RemovedMaxBalanceWhitelistAddress(_address);\\r\\n    }\\r\\n\\r\\n    function updateMaxBalanceWhitelistBatch(address[] calldata _updatedAddresses, bool _isMaxBalanceWhitelisted) public onlyOwner {\\r\\n        require(taxSettings.maxBalanceAfterBuy, \\\"AMBABD\\\");\\r\\n        for(uint i = 0; i \\u003c _updatedAddresses.length; i++) {\\r\\n            maxBalanceWhitelist[_updatedAddresses[i]] = _isMaxBalanceWhitelisted;\\r\\n            if(_isMaxBalanceWhitelisted) {\\r\\n                emit AddedMaxBalanceWhitelistAddress(_updatedAddresses[i]);\\r\\n            } else {\\r\\n                emit RemovedMaxBalanceWhitelistAddress(_updatedAddresses[i]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isMaxBalanceWhitelisted(address _address) public view returns (bool) {\\r\\n        return maxBalanceWhitelist[_address];\\r\\n    }\\r\\n\\r\\n    function updateMaxBalanceAfterBuy(uint256 _updatedMaxBalanceAfterBuy) public onlyOwner {\\r\\n        require(taxSettings.maxBalanceAfterBuy, \\\"AMBABD\\\");\\r\\n        maxBalanceAfterBuy = _updatedMaxBalanceAfterBuy;\\r\\n        emit UpdatedMaxBalanceAfterBuy(_updatedMaxBalanceAfterBuy);\\r\\n    }\\r\\n\\r\\n    function maxBalanceAfterBuyCheck(uint256 amount, address receiver) public view returns(bool) {\\r\\n        if(maxBalanceWhitelist[receiver]) {\\r\\n            return true;\\r\\n        }\\r\\n        require(taxSettings.maxBalanceAfterBuy);\\r\\n        uint256 receiverBalance;\\r\\n        if(taxSettings.holderTax) {\\r\\n            receiverBalance = _rOwned[receiver];\\r\\n        } else {\\r\\n            receiverBalance = _tOwned[receiver];\\r\\n        }\\r\\n        receiverBalance += amount;\\r\\n        require(receiverBalance \\u003c= maxBalanceAfterBuy, \\\"MBAB\\\");\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // SwapWhitelist\\r\\n\\r\\n    function addSwapWhitelistedAddress(address _address) public onlyOwner {\\r\\n        require(swapWhitelistingSettings.isActive, \\\"ASWD\\\");\\r\\n        swapWhitelist[_address] = true;\\r\\n        emit AddedSwapWhitelistAddress(_address);\\r\\n    }\\r\\n\\r\\n    function removeSwapWhitelistedAddress(address _address) public onlyOwner {\\r\\n        require(swapWhitelistingSettings.isActive, \\\"ASWD\\\");\\r\\n        swapWhitelist[_address] = false;\\r\\n        emit RemovedSwapWhitelistAddress(_address);\\r\\n    }\\r\\n\\r\\n    function updateSwapWhitelistBatch(address[] calldata _updatedAddresses, bool _isSwapWhitelisted) public onlyOwner {\\r\\n        require(swapWhitelistingSettings.isActive, \\\"ASWD\\\");\\r\\n        for(uint i = 0; i \\u003c _updatedAddresses.length; i++) {\\r\\n            swapWhitelist[_updatedAddresses[i]] = _isSwapWhitelisted;\\r\\n            if(_isSwapWhitelisted) {\\r\\n                emit AddedSwapWhitelistAddress(_updatedAddresses[i]);\\r\\n            } else {\\r\\n                emit RemovedSwapWhitelistAddress(_updatedAddresses[i]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isSwapWhitelisted(address _address) public view returns (bool) {\\r\\n        return swapWhitelist[_address];\\r\\n    }\\r\\n\\r\\n    function setSwapWhitelistEndDate( uint256 _updatedEndDate) public onlyOwner {\\r\\n        require(swapWhitelistingSettings.isActive, \\\"ASWD\\\");\\r\\n        require(_updatedEndDate \\u003c= 48, \\\"ED\\\");\\r\\n        swapWhitelistingSettings.endDate = _updatedEndDate;\\r\\n        emit UpdatedSwapWhitelistingEndDate(_updatedEndDate);\\r\\n    }\\r\\n\\r\\n    function updateSwapWhitelisting(bool _isActive) public onlyOwner {\\r\\n        require(!marketInit, \\\"AMIE\\\");\\r\\n        swapWhitelistingSettings.isActive = _isActive;\\r\\n        emit UpdatedSwapWhitelistingActiveStatus(_isActive);\\r\\n    }\\r\\n\\r\\n    function swapWhitelistingCheck(address receiver) public returns(bool) {\\r\\n        require(marketInit, \\\"AMIE\\\");\\r\\n        if(block.timestamp \\u003e marketInitBlockTime + (swapWhitelistingSettings.endDate * 1 hours)) {\\r\\n            swapWhitelistingSettings.isActive = false;\\r\\n            return true;\\r\\n        }\\r\\n        require(swapWhitelist[receiver], \\\"SWL\\\");\\r\\n        return true;\\r\\n    }\\r\\n}\"},\"BuyBackWallet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\nimport \\\"./ITaxToken.sol\\\";\\r\\nimport \\\"./ITaxHelper.sol\\\";\\r\\n\\r\\nimport \\\"./IMintFactory.sol\\\";\\r\\n\\r\\ncontract BuyBackWallet is Ownable{\\r\\n    \\r\\n\\r\\n    ITaxToken public token; \\r\\n    IMintFactory public factory;\\r\\n    uint256 private threshold;\\r\\n\\r\\n    event UpdatedThreshold(uint256 _newThreshold);\\r\\n    event ETHtoTaxHelper(uint256 amount);\\r\\n\\r\\n\\r\\n    constructor(address _factory, address _token, uint256 _newThreshold) {\\r\\n        token = ITaxToken(_token);\\r\\n        factory = IMintFactory(_factory);\\r\\n        threshold = _newThreshold;\\r\\n        emit UpdatedThreshold(_newThreshold);\\r\\n        transferOwnership(_token);\\r\\n    }\\r\\n    \\r\\n    function checkBuyBackTrigger() public view returns (bool) {\\r\\n        return address(this).balance \\u003e threshold;\\r\\n    }\\r\\n\\r\\n    function getBalance() public view returns (uint256) {\\r\\n        return address(this).balance;\\r\\n    }\\r\\n\\r\\n    function sendEthToTaxHelper() external returns (uint256) {\\r\\n        uint index = token.taxHelperIndex();\\r\\n        require(msg.sender == factory.getTaxHelperAddress(index), \\\"RA\\\");\\r\\n        uint256 amount = address(this).balance;\\r\\n        (bool sent,) = msg.sender.call{value: amount}(\\\"\\\");\\r\\n        require(sent, \\\"Failed to send Ether\\\");\\r\\n        emit ETHtoTaxHelper(amount);\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function updateThreshold(uint256 _newThreshold) external onlyOwner {\\r\\n        threshold = _newThreshold;\\r\\n        emit UpdatedThreshold(_newThreshold);\\r\\n    }\\r\\n\\r\\n    function getThreshold() external view returns (uint256) {\\r\\n        return threshold;\\r\\n    }\\r\\n\\r\\n    receive() payable external {\\r\\n    }\\r\\n} \"},\"Constructor.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./ITaxHelper.sol\\\";\\r\\nimport \\\"./IMintFactory.sol\\\";\\r\\nimport \\\"./IFacetHelper.sol\\\";\\r\\nimport \\\"./IBuyBackWallet.sol\\\";\\r\\nimport \\\"./ILPWallet.sol\\\";\\r\\nimport \\\"./ISettings.sol\\\";\\r\\nimport \\\"./IWallets.sol\\\";\\r\\n\\r\\nimport \\\"./Storage.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract ConstructorFacet is Storage, Ownable {\\r\\n    \\r\\n    struct ConstructorParams {\\r\\n        string name_; \\r\\n        string symbol_; \\r\\n        uint8 decimals_; \\r\\n        address creator_; \\r\\n        uint256 tTotal_;\\r\\n        uint256 _maxTax;\\r\\n        TaxSettings _settings;\\r\\n        TaxSettings _lockedSettings;\\r\\n        Fees _fees;\\r\\n        address _transactionTaxWallet;\\r\\n        CustomTax[] _customTaxes;\\r\\n        uint256 lpWalletThreshold;\\r\\n        uint256 buyBackWalletThreshold;\\r\\n        uint256 _taxHelperIndex;\\r\\n        address admin_; \\r\\n        address recoveryAdmin_; \\r\\n        bool isLossless_;\\r\\n        AntiBotSettings _antiBotSettings;\\r\\n        uint256 _maxBalanceAfterBuy;\\r\\n        SwapWhitelistingSettings _swapWhitelistingSettings;\\r\\n    }\\r\\n\\r\\n    function constructorHandler(ConstructorParams calldata params, address _factory) external {\\r\\n        require(IMintFactory(_factory).tokenGeneratorIsAllowed(msg.sender), \\\"RA\\\");\\r\\n        require(params.creator_ != address(0), \\\"ZA\\\");\\r\\n        require(params._transactionTaxWallet != address(0), \\\"ZA\\\");\\r\\n        require(params.admin_ != address(0), \\\"ZA\\\");\\r\\n        require(params.recoveryAdmin_ != address(0), \\\"ZA\\\");\\r\\n        require(_factory != address(0), \\\"ZA\\\");\\r\\n\\r\\n        _name = params.name_;\\r\\n        _symbol = params.symbol_;\\r\\n        _decimals = params.decimals_;\\r\\n        _creator = params.creator_;\\r\\n        _isExcluded[params.creator_] = true;\\r\\n        _excluded.push(params.creator_);\\r\\n        emit ExcludedAccount(_creator);\\r\\n        // Lossless\\r\\n        isLosslessOn = params.isLossless_;\\r\\n        admin = params.admin_;\\r\\n        emit AdminChanged(address(0), admin);\\r\\n        recoveryAdmin = params.recoveryAdmin_;\\r\\n        emit RecoveryAdminChanged(address(0), recoveryAdmin);\\r\\n        timelockPeriod = 7 days;\\r\\n        lossless = ILosslessController(IMintFactory(_factory).getLosslessController());\\r\\n        _isExcluded[address(lossless)] = true;\\r\\n        _excluded.push(address(lossless));\\r\\n        emit ExcludedAccount(address(lossless));\\r\\n        // Tax Settings\\r\\n        require(params._maxTax \\u003c= MaxTax, \\\"MT\\\");\\r\\n        MaxTax = params._maxTax;\\r\\n        taxSettings = params._settings;\\r\\n        emit UpdatedSettings(taxSettings);\\r\\n        isLocked = params._lockedSettings;\\r\\n        isLocked.holderTax = true;\\r\\n        if(taxSettings.holderTax) {\\r\\n            taxSettings.canMint = false;\\r\\n            isLocked.canMint = true;\\r\\n        }\\r\\n        emit UpdatedLockedSettings(isLocked);\\r\\n        fees = params._fees;\\r\\n        emit UpdatedTaxFees(fees);\\r\\n        require(params._customTaxes.length \\u003c MaxCustom + 1, \\\"MCT\\\");\\r\\n        for(uint i = 0; i \\u003c params._customTaxes.length; i++) {\\r\\n            require(params._customTaxes[i].wallet != address(0));\\r\\n            customTaxes.push(params._customTaxes[i]);\\r\\n        }\\r\\n        emit UpdatedCustomTaxes(customTaxes);\\r\\n        customTaxLength = params._customTaxes.length;\\r\\n        transactionTaxWallet = params._transactionTaxWallet;\\r\\n        emit UpdatedTransactionTaxAddress(transactionTaxWallet);\\r\\n        // Factory, Wallets, Pair Address\\r\\n        factory = _factory;\\r\\n        taxHelperIndex = params._taxHelperIndex;\\r\\n        emit UpdatedTaxHelperIndex(taxHelperIndex);\\r\\n        address taxHelper = IMintFactory(factory).getTaxHelperAddress(taxHelperIndex);\\r\\n        pairAddress = ITaxHelper(taxHelper).createLPToken();\\r\\n        addLPToken(pairAddress);\\r\\n        address wallets = IFacetHelper(IMintFactory(factory).getFacetHelper()).getWalletsFacet(); \\r\\n        buyBackWallet = IWalletsFacet(wallets).createBuyBackWallet(factory, address(this), params.buyBackWalletThreshold);\\r\\n        lpWallet = IWalletsFacet(wallets).createLPWallet(factory, address(this), params.lpWalletThreshold);\\r\\n        // Total Supply and other info\\r\\n        _rTotal = (MAX - (MAX % params.tTotal_));\\r\\n        _rOwned[params.creator_] = _rTotal;\\r\\n        DENOMINATOR = 10000;\\r\\n        _isExcluded[taxHelper] = true;\\r\\n        _excluded.push(taxHelper);\\r\\n        emit ExcludedAccount(taxHelper);\\r\\n        require(checkMaxTax(true), \\\"BF\\\");\\r\\n        require(checkMaxTax(false), \\\"SF\\\");\\r\\n        transferOwnership(params.creator_);\\r\\n        _mintInitial(params.creator_, params.tTotal_);\\r\\n        // AntiBot Settings\\r\\n        require(params._antiBotSettings.endDate \\u003c= 48, \\\"ED\\\");\\r\\n        require(params._swapWhitelistingSettings.endDate \\u003c= 48, \\\"ED\\\");\\r\\n        antiBotSettings = params._antiBotSettings;\\r\\n        emit UpdatedAntiBotSettings(antiBotSettings);\\r\\n        maxBalanceAfterBuy = params._maxBalanceAfterBuy;\\r\\n        emit UpdatedMaxBalanceAfterBuy(maxBalanceAfterBuy);\\r\\n        swapWhitelistingSettings = params._swapWhitelistingSettings;\\r\\n        emit UpdatedSwapWhitelistingSettings(swapWhitelistingSettings);\\r\\n        emit TokenCreated(_name, _symbol, _decimals, _tTotal, _rTotal);\\r\\n    }\\r\\n\\r\\n    function _mintInitial(address account, uint256 amount) internal virtual {\\r\\n        _tTotal += amount;\\r\\n        _tOwned[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function checkMaxTax(bool isBuy) internal view returns (bool) {\\r\\n        uint256 totalTaxes;\\r\\n        if(isBuy) {\\r\\n            totalTaxes += fees.transactionTax.buy;\\r\\n            totalTaxes += fees.holderTax;\\r\\n            for(uint i = 0; i \\u003c customTaxes.length; i++) {\\r\\n                totalTaxes += customTaxes[i].fee.buy;\\r\\n            }\\r\\n        } else {\\r\\n            totalTaxes += fees.transactionTax.sell;\\r\\n            totalTaxes += fees.lpTax;\\r\\n            totalTaxes += fees.holderTax;\\r\\n            totalTaxes += fees.buyBackTax;\\r\\n            for(uint i = 0; i \\u003c customTaxes.length; i++) {\\r\\n                totalTaxes += customTaxes[i].fee.sell;\\r\\n            }\\r\\n        }\\r\\n        if(totalTaxes \\u003c= MaxTax) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n\\r\\n    function addLPToken(address _newLPToken) internal {\\r\\n        lpTokens[_newLPToken] = true;\\r\\n        emit AddedLPToken(_newLPToken);\\r\\n    }\\r\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n// File @openzeppelin/contracts/utils/Context.sol@v4.0.0\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"},\"EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Library for managing\\r\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\r\\n * types.\\r\\n *\\r\\n * Sets have the following properties:\\r\\n *\\r\\n * - Elements are added, removed, and checked for existence in constant time\\r\\n * (O(1)).\\r\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\r\\n *\\r\\n * ```\\r\\n * contract Example {\\r\\n *     // Add the library methods\\r\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\r\\n *\\r\\n *     // Declare a set state variable\\r\\n *     EnumerableSet.AddressSet private mySet;\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\r\\n * and `uint256` (`UintSet`) are supported.\\r\\n */\\r\\nlibrary EnumerableSet {\\r\\n    // To implement this library for multiple types with as little code\\r\\n    // repetition as possible, we write it in terms of a generic Set type with\\r\\n    // bytes32 values.\\r\\n    // The Set implementation uses private functions, and user-facing\\r\\n    // implementations (such as AddressSet) are just wrappers around the\\r\\n    // underlying Set.\\r\\n    // This means that we can only create new EnumerableSets for types that fit\\r\\n    // in bytes32.\\r\\n\\r\\n    struct Set {\\r\\n        // Storage of set values\\r\\n        bytes32[] _values;\\r\\n        // Position of the value in the `values` array, plus 1 because index 0\\r\\n        // means a value is not in the set.\\r\\n        mapping(bytes32 =\\u003e uint256) _indexes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\r\\n        if (!_contains(set, value)) {\\r\\n            set._values.push(value);\\r\\n            // The value is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            set._indexes[value] = set._values.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\r\\n        // We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\r\\n        uint256 valueIndex = set._indexes[value];\\r\\n\\r\\n        if (valueIndex != 0) {\\r\\n            // Equivalent to contains(set, value)\\r\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\r\\n            // the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 toDeleteIndex = valueIndex - 1;\\r\\n            uint256 lastIndex = set._values.length - 1;\\r\\n\\r\\n            if (lastIndex != toDeleteIndex) {\\r\\n                bytes32 lastvalue = set._values[lastIndex];\\r\\n\\r\\n                // Move the last value to the index where the value to delete is\\r\\n                set._values[toDeleteIndex] = lastvalue;\\r\\n                // Update the index for the moved value\\r\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue\\u0027s index to valueIndex\\r\\n            }\\r\\n\\r\\n            // Delete the slot where the moved value was stored\\r\\n            set._values.pop();\\r\\n\\r\\n            // Delete the index for the deleted slot\\r\\n            delete set._indexes[value];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\r\\n        return set._indexes[value] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function _length(Set storage set) private view returns (uint256) {\\r\\n        return set._values.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\r\\n        return set._values[index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\r\\n        return set._values;\\r\\n    }\\r\\n\\r\\n    // Bytes32Set\\r\\n\\r\\n    struct Bytes32Set {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\r\\n        return _add(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\r\\n        return _remove(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\r\\n        return _contains(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\r\\n        return _at(set._inner, index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\r\\n        return _values(set._inner);\\r\\n    }\\r\\n\\r\\n    // AddressSet\\r\\n\\r\\n    struct AddressSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(AddressSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\r\\n        return address(uint160(uint256(_at(set._inner, index))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\r\\n        bytes32[] memory store = _values(set._inner);\\r\\n        address[] memory result;\\r\\n\\r\\n        assembly {\\r\\n            result := store\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    // UintSet\\r\\n\\r\\n    struct UintSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function length(UintSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\r\\n        return uint256(_at(set._inner, index));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the entire set in an array\\r\\n     *\\r\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\r\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\r\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\r\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\r\\n     */\\r\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\r\\n        bytes32[] memory store = _values(set._inner);\\r\\n        uint256[] memory result;\\r\\n\\r\\n        assembly {\\r\\n            result := store\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n}\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n// File @openzeppelin/contracts/token/ERC20/ERC20.sol@v4.0.0\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn\\u0027t required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20 is Context, IERC20 {\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The defaut value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All three of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor (string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overloaded;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``\\u0027s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\r\\n        require(currentAllowance \\u003e= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\r\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\r\\n        require(currentAllowance \\u003e= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 senderBalance = _balances[sender];\\r\\n        require(senderBalance \\u003e= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[sender] = senderBalance - amount;\\r\\n        _balances[recipient] += amount;\\r\\n\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance \\u003e= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _balances[account] = accountBalance - amount;\\r\\n        _totalSupply -= amount;\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\r\\n}\\r\\n\"},\"FacetHelper.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract FacetHelper is Ownable{\\r\\n\\r\\n    event AddedFacet(address _newFacet);\\r\\n    event AddedSelector(address _facet, bytes4 _sig);\\r\\n    event RemovedSelector(bytes4 _sig);\\r\\n    event ResetStorage();\\r\\n\\r\\n    event UpdatedSettingsFacet(address _newAddress);\\r\\n    event UpdatedLosslessFacet(address _newAddress);\\r\\n    event UpdatedTaxFacet(address _newAddress);\\r\\n    event UpdatedConstructorFacet(address _newAddress);\\r\\n    event UpdatedWalletsFacet(address _newAddress);\\r\\n    event UpdatedAntiBotFacet(address _newAddress);\\r\\n    event UpdatedMulticallFacet(address _newAddress);\\r\\n\\r\\n    struct Facets {\\r\\n        address Settings;\\r\\n        address Lossless;\\r\\n        address Tax;\\r\\n        address Constructor;\\r\\n        address Wallets;\\r\\n        address AntiBot;\\r\\n        address Multicall;\\r\\n    }\\r\\n\\r\\n    Facets public facets;\\r\\n\\r\\n    mapping(bytes4 =\\u003e address) public selectorToFacet;\\r\\n    bytes4[] public selectorsList;\\r\\n    mapping(address =\\u003e bool) public isFacet;\\r\\n    address[] public facetsList;\\r\\n\\r\\n    function addFacet(address _newFacet) public onlyOwner {\\r\\n        isFacet[_newFacet] = true;\\r\\n        facetsList.push(_newFacet);\\r\\n        emit AddedFacet(_newFacet);\\r\\n    }\\r\\n\\r\\n    function addSelector(address _facet, bytes4 _sig) public onlyOwner {\\r\\n        require(selectorToFacet[_sig] == address(0));\\r\\n        // require(isFacet[_facet]);\\r\\n        selectorToFacet[_sig] = _facet;\\r\\n        selectorsList.push(_sig);\\r\\n        emit AddedSelector(_facet, _sig);\\r\\n    }\\r\\n\\r\\n    // Removing of the selectors occurs during resetFacetStorage();\\r\\n    // it is easier to reset and rebuild using the script when deploying and updating the facets\\r\\n    // function removeSelector(bytes4 _sig) public onlyOwner {\\r\\n    //     selectorToFacet[_sig] = address(0);\\r\\n    //     emit RemovedSelector(_sig);\\r\\n    // }    \\r\\n\\r\\n    function getFacetAddressFromSelector(bytes4 _sig) public view returns (address) {\\r\\n        return selectorToFacet[_sig];\\r\\n    }\\r\\n\\r\\n    function getFacetByIndex(uint256 _index) public view returns(address) {\\r\\n        return facetsList[_index];\\r\\n    }\\r\\n\\r\\n    function resetFacetStorage() public onlyOwner {\\r\\n        for(uint i = 0; i \\u003c selectorsList.length; i++) {\\r\\n            bytes4 sig = selectorsList[i];\\r\\n            selectorToFacet[sig] = address(0);\\r\\n        }\\r\\n        delete selectorsList;\\r\\n\\r\\n        for(uint i = 0; i \\u003c facetsList.length; i++) {\\r\\n            address facet = facetsList[i];\\r\\n            isFacet[facet] = false;\\r\\n        }\\r\\n        delete facetsList;\\r\\n\\r\\n        emit ResetStorage();\\r\\n    }\\r\\n\\r\\n        // Facet getters and setters\\r\\n\\r\\n    function getSettingsFacet() public view returns (address) {\\r\\n        return facets.Settings;\\r\\n    }\\r\\n\\r\\n    function updateSettingsFacet(address _newSettingsAddress) public onlyOwner {\\r\\n        facets.Settings = _newSettingsAddress;\\r\\n        emit UpdatedSettingsFacet(_newSettingsAddress);\\r\\n    }\\r\\n\\r\\n    function getLosslessFacet() public view returns (address) {\\r\\n        return facets.Lossless;\\r\\n    }\\r\\n\\r\\n    function updateLosslessFacet(address _newLosslessAddress) public onlyOwner {\\r\\n        facets.Lossless = _newLosslessAddress;\\r\\n        emit UpdatedLosslessFacet(_newLosslessAddress);\\r\\n    }\\r\\n\\r\\n    function getTaxFacet() public view returns (address) {\\r\\n        return facets.Tax;\\r\\n    }\\r\\n\\r\\n    function updateTaxFacet(address _newTaxAddress) public onlyOwner {\\r\\n        facets.Tax = _newTaxAddress;\\r\\n        emit UpdatedTaxFacet(_newTaxAddress);\\r\\n    }\\r\\n\\r\\n    function getConstructorFacet() public view returns (address) {\\r\\n        return facets.Constructor;\\r\\n    }\\r\\n\\r\\n    function updateConstructorFacet(address _newConstructorAddress) public onlyOwner {\\r\\n        facets.Constructor = _newConstructorAddress;\\r\\n        emit UpdatedConstructorFacet(_newConstructorAddress);\\r\\n    }\\r\\n\\r\\n    function getWalletsFacet() public view returns (address) {\\r\\n        return facets.Wallets;\\r\\n    }\\r\\n\\r\\n    function updateWalletsFacet(address _newWalletsAddress) public onlyOwner {\\r\\n        facets.Wallets = _newWalletsAddress;\\r\\n        emit UpdatedWalletsFacet(_newWalletsAddress);\\r\\n    }\\r\\n\\r\\n    function getAntiBotFacet() public view returns (address) {\\r\\n        return facets.AntiBot;\\r\\n    }\\r\\n\\r\\n    function updateAntiBotFacet(address _newAntiBotAddress) public onlyOwner {\\r\\n        facets.AntiBot = _newAntiBotAddress;\\r\\n        emit UpdatedAntiBotFacet(_newAntiBotAddress);\\r\\n    }\\r\\n\\r\\n    function getMulticallFacet() public view returns (address) {\\r\\n        return facets.Multicall;\\r\\n    }\\r\\n\\r\\n    function updateMulticallFacet(address _newWalletsAddress) public onlyOwner {\\r\\n        facets.Multicall = _newWalletsAddress;\\r\\n        emit UpdatedMulticallFacet(_newWalletsAddress);\\r\\n    }\\r\\n} \"},\"FeeHelper.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract FeeHelper is Ownable{\\r\\n    \\r\\n    struct Settings {\\r\\n        uint256 GENERATOR_FEE;\\r\\n        uint256 FEE; \\r\\n        uint256 DENOMINATOR;\\r\\n        address payable FEE_ADDRESS;\\r\\n    }\\r\\n    \\r\\n    Settings public SETTINGS;\\r\\n    \\r\\n    constructor() {\\r\\n        SETTINGS.GENERATOR_FEE = 0;\\r\\n        SETTINGS.FEE = 100;\\r\\n        SETTINGS.DENOMINATOR = 10000;\\r\\n        SETTINGS.FEE_ADDRESS = payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function getGeneratorFee() external view returns(uint256) {\\r\\n        return SETTINGS.GENERATOR_FEE;\\r\\n    }\\r\\n    \\r\\n    function getFee() external view returns(uint256) {\\r\\n        return SETTINGS.FEE;\\r\\n    }\\r\\n\\r\\n    function getFeeDenominator() external view returns(uint256) {\\r\\n        return SETTINGS.DENOMINATOR;\\r\\n    }\\r\\n\\r\\n    function setGeneratorFee(uint256 _fee) external onlyOwner {\\r\\n        SETTINGS.GENERATOR_FEE = _fee;\\r\\n    }\\r\\n    \\r\\n    function setFee(uint _fee) external onlyOwner {\\r\\n        SETTINGS.FEE = _fee;\\r\\n    }\\r\\n    \\r\\n    function getFeeAddress() external view returns(address) {\\r\\n        return SETTINGS.FEE_ADDRESS;\\r\\n    }\\r\\n    \\r\\n    function setFeeAddress(address payable _feeAddress) external onlyOwner {\\r\\n        SETTINGS.FEE_ADDRESS = _feeAddress;\\r\\n    }\\r\\n} \"},\"FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/// @title Contains 512-bit math functions\\r\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\r\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\r\\nlibrary FullMath {\\r\\n   /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n/// @param a The multiplicand\\r\\n/// @param b The multiplier\\r\\n/// @param denominator The divisor\\r\\n/// @return result The 256-bit result\\r\\n/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\r\\nfunction mulDiv(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    uint256 denominator\\r\\n) internal pure returns (uint256 result) {\\r\\n    // 512-bit multiply [prod1 prod0] = a * b\\r\\n    // Compute the product mod 2**256 and mod 2**256 - 1\\r\\n    // then use the Chinese Remainder Theorem to reconstruct\\r\\n    // the 512 bit result. The result is stored in two 256\\r\\n    // variables such that product = prod1 * 2**256 + prod0\\r\\n    uint256 prod0; // Least significant 256 bits of the product\\r\\n    uint256 prod1; // Most significant 256 bits of the product\\r\\n    assembly {\\r\\n        let mm := mulmod(a, b, not(0))\\r\\n        prod0 := mul(a, b)\\r\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n    }\\r\\n\\r\\n    // Handle non-overflow cases, 256 by 256 division\\r\\n    if (prod1 == 0) {\\r\\n        require(denominator \\u003e 0);\\r\\n        assembly {\\r\\n            result := div(prod0, denominator)\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    // Make sure the result is less than 2**256.\\r\\n    // Also prevents denominator == 0\\r\\n    require(denominator \\u003e prod1);\\r\\n\\r\\n    ///////////////////////////////////////////////\\r\\n    // 512 by 256 division.\\r\\n    ///////////////////////////////////////////////\\r\\n\\r\\n    // Make division exact by subtracting the remainder from [prod1 prod0]\\r\\n    // Compute remainder using mulmod\\r\\n    uint256 remainder;\\r\\n    assembly {\\r\\n        remainder := mulmod(a, b, denominator)\\r\\n    }\\r\\n    // Subtract 256 bit number from 512 bit number\\r\\n    assembly {\\r\\n        prod1 := sub(prod1, gt(remainder, prod0))\\r\\n        prod0 := sub(prod0, remainder)\\r\\n    }\\r\\n\\r\\n    // Factor powers of two out of denominator\\r\\n    // Compute largest power of two divisor of denominator.\\r\\n    // Always \\u003e= 1.\\r\\n    unchecked {\\r\\n        uint256 twos = (type(uint256).max - denominator + 1) \\u0026 denominator;\\r\\n        // Divide denominator by power of two\\r\\n        assembly {\\r\\n            denominator := div(denominator, twos)\\r\\n        }\\r\\n\\r\\n        // Divide [prod1 prod0] by the factors of two\\r\\n        assembly {\\r\\n            prod0 := div(prod0, twos)\\r\\n        }\\r\\n        // Shift in bits from prod1 into prod0. For this we need\\r\\n        // to flip `twos` such that it is 2**256 / twos.\\r\\n        // If twos is zero, then it becomes one\\r\\n        assembly {\\r\\n            twos := add(div(sub(0, twos), twos), 1)\\r\\n        }\\r\\n        prod0 |= prod1 * twos;\\r\\n\\r\\n        // Invert denominator mod 2**256\\r\\n        // Now that denominator is an odd number, it has an inverse\\r\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\r\\n        // Compute the inverse by starting with a seed that is correct\\r\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\r\\n        uint256 inv = (3 * denominator) ^ 2;\\r\\n        // Now use Newton-Raphson iteration to improve the precision.\\r\\n        // Thanks to Hensel\\u0027s lifting lemma, this also works in modular\\r\\n        // arithmetic, doubling the correct bits in each step.\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\r\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\r\\n\\r\\n        // Because the division is now exact we can divide by multiplying\\r\\n        // with the modular inverse of denominator. This will give us the\\r\\n        // correct result modulo 2**256. Since the precoditions guarantee\\r\\n        // that the outcome is less than 2**256, this is the final result.\\r\\n        // We don\\u0027t need to compute the high bits of the result and prod1\\r\\n        // is no longer required.\\r\\n        result = prod0 * inv;\\r\\n        return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n    /// @param a The multiplicand\\r\\n    /// @param b The multiplier\\r\\n    /// @param denominator The divisor\\r\\n    /// @return result The 256-bit result\\r\\n    function mulDivRoundingUp(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        uint256 denominator\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        result = mulDiv(a, b, denominator);\\r\\n        if (mulmod(a, b, denominator) \\u003e 0) {\\r\\n            require(result \\u003c type(uint256).max);\\r\\n            result++;\\r\\n        }\\r\\n    }\\r\\n}\"},\"IBuyBackWallet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IBuyBackWallet {\\r\\n\\r\\n    function checkBuyBackTrigger() external view returns (bool);\\r\\n\\r\\n    function getBalance() external view returns (uint256);\\r\\n\\r\\n    function sendEthToTaxHelper() external returns(uint256);\\r\\n\\r\\n    function updateThreshold(uint256 _newThreshold) external;\\r\\n\\r\\n    function getThreshold() external view returns (uint256);\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.0.0\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"IFacetHelper.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IFacetHelper {\\r\\n\\r\\n    function addFacet(address _newFacet) external;\\r\\n\\r\\n    function addSelector(address _facet, bytes4 _sig) external;\\r\\n\\r\\n    function removeSelector(bytes4 _sig) external;\\r\\n\\r\\n    function getFacetAddressFromSelector(bytes4 _sig) external view returns (address);\\r\\n\\r\\n    function getSettingsFacet() external view returns (address);\\r\\n\\r\\n    function updateSettingsFacet(address _newSettingsAddress) external;\\r\\n\\r\\n    function getTaxFacet() external view returns (address);\\r\\n\\r\\n    function updateTaxFacet(address _newTaxesAddress) external;\\r\\n\\r\\n    function getLosslessFacet() external view returns (address);\\r\\n\\r\\n    function updateLosslessFacet(address _newLosslessAddress) external;\\r\\n\\r\\n    function getConstructorFacet() external view returns (address);\\r\\n\\r\\n    function updateConstructorFacet(address _newConstructorAddress) external;\\r\\n\\r\\n    function getWalletsFacet() external view returns (address);\\r\\n\\r\\n    function updateWalletsFacet(address _newWalletsAddress) external;\\r\\n\\r\\n    function getAntiBotFacet() external view returns (address);\\r\\n\\r\\n    function updateAntiBotFacet(address _newWalletsAddress) external;\\r\\n\\r\\n    function getMulticallFacet() external view returns (address);\\r\\n\\r\\n    function updateMulticallFacet(address _newWalletsAddress) external;\\r\\n    \\r\\n}\"},\"IFeeHelper.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IFeeHelper {\\r\\n    function getFee() view external returns(uint256);\\r\\n    \\r\\n    function getFeeDenominator() view external returns(uint256);\\r\\n    \\r\\n    function setFee(uint _fee) external;\\r\\n    \\r\\n    function getFeeAddress() view external returns(address);\\r\\n    \\r\\n    function setFeeAddress(address payable _feeAddress) external;\\r\\n\\r\\n    function getGeneratorFee() view external returns(uint256);\\r\\n\\r\\n    function setGeneratorFee(uint256 _fee) external;\\r\\n}\"},\"ILosslessController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n\\r\\ninterface ILosslessController {\\r\\n    \\r\\n    function pause() external;\\r\\n    function unpause() external;\\r\\n    function setAdmin(address _newAdmin) external;\\r\\n    function setRecoveryAdmin(address _newRecoveryAdmin) external;\\r\\n\\r\\n    function beforeTransfer(address _sender, address _recipient, uint256 _amount) external;\\r\\n    function beforeTransferFrom(address _msgSender, address _sender, address _recipient, uint256 _amount) external;\\r\\n    function beforeApprove(address _sender, address _spender, uint256 _amount) external;\\r\\n    function beforeIncreaseAllowance(address _msgSender, address _spender, uint256 _addedValue) external;\\r\\n    function beforeDecreaseAllowance(address _msgSender, address _spender, uint256 _subtractedValue) external;\\r\\n    function beforeMint(address _to, uint256 _amount) external;\\r\\n    function beforeBurn(address _account, uint256 _amount) external;\\r\\n    function afterTransfer(address _sender, address _recipient, uint256 _amount) external;\\r\\n\\r\\n\\r\\n    event AdminChange(address indexed _newAdmin);\\r\\n    event RecoveryAdminChange(address indexed _newAdmin);\\r\\n}\\r\\n\"},\"ILPWallet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface ILPWallet {\\r\\n\\r\\n    function checkLPTrigger() external view returns (bool);\\r\\n\\r\\n    function getBalance() external view returns (uint256);\\r\\n\\r\\n    function sendEthToTaxHelper() external returns(uint256);\\r\\n\\r\\n    function transferBalanceToTaxHelper() external;\\r\\n\\r\\n    function updateThreshold(uint256 _newThreshold) external;\\r\\n\\r\\n    function getThreshold() external view returns (uint256);\\r\\n}\"},\"IMintFactory.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IMintFactory {\\r\\n\\r\\n    struct TaxHelper {\\r\\n        string Name;\\r\\n        address Address;\\r\\n        uint Index;\\r\\n    }\\r\\n\\r\\n    function addTaxHelper(string calldata _name, address _address) external;\\r\\n\\r\\n    function updateTaxHelper(uint _index, address _address) external;\\r\\n\\r\\n    function getTaxHelperAddress(uint _index) external view returns(address);\\r\\n\\r\\n    function getTaxHelpersDataByIndex(uint _index) external view returns(TaxHelper memory);\\r\\n\\r\\n    function registerToken (address _tokenOwner, address _tokenAddress) external;\\r\\n\\r\\n    function tokenIsRegistered(address _tokenAddress) external view returns (bool);\\r\\n\\r\\n    function tokenGeneratorsLength() external view returns (uint256);\\r\\n\\r\\n    function tokenGeneratorIsAllowed(address _tokenGenerator) external view returns (bool);\\r\\n\\r\\n    function getFacetHelper() external view returns (address);\\r\\n\\r\\n    function updateFacetHelper(address _newFacetHelperAddress) external;\\r\\n\\r\\n    function getFeeHelper() external view returns (address);\\r\\n\\r\\n    function updateFeeHelper(address _newFeeHelperAddress) external;\\r\\n    \\r\\n    function getLosslessController() external view returns (address);\\r\\n\\r\\n    function updateLosslessController(address _newLosslessControllerAddress) external;\\r\\n}\"},\"ISettings.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface ISettingsFacet {\\r\\n\\r\\n    function getFacetAddressFromSelector(bytes4 _sig) external view returns (address);\\r\\n    function createBuyBackWallet(address _factory, address _token) external returns (address);\\r\\n    function createLPWallet(address _factory, address _token) external returns (address);\\r\\n}\"},\"ITaxHelper.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface ITaxHelper {\\r\\n\\r\\n    function initiateBuyBackTax(\\r\\n        address _token,\\r\\n        address _wallet\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function initiateLPTokenTax(        \\r\\n        address _token,\\r\\n        address _wallet\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function lpTokenHasReserves(address _lpToken) external view returns (bool);\\r\\n\\r\\n    function createLPToken() external returns (address lpToken);\\r\\n}\"},\"ITaxToken.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface ITaxToken is IERC20 {\\r\\n\\r\\n    function taxHelperIndex()external view returns(uint);\\r\\n\\r\\n    function buyBackBurn(uint256 _amount) external;\\r\\n\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n\\r\\n}\"},\"IUniswapV2Factory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\"},\"IUniswapV2Pair.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"},\"IUniswapV2Router01.sol\":{\"content\":\"pragma solidity \\u003e=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\"},\"IUniswapV2Router02.sol\":{\"content\":\"pragma solidity \\u003e=0.6.2;\\r\\n\\r\\nimport \\u0027./IUniswapV2Router01.sol\\u0027;\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"},\"IWallets.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IWalletsFacet {\\r\\n\\r\\n    function createBuyBackWallet(address _factory, address _token, uint256 _newThreshold) external returns (address);\\r\\n    function createLPWallet(address _factory, address _token, uint256 _newThreshold) external returns (address);\\r\\n\\r\\n    function updateBuyBackWalletThreshold(uint256 _newThreshold) external;\\r\\n\\r\\n    function updateLPWalletThreshold(uint256 _newThreshold) external;\\r\\n}\"},\"Lossless.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Storage.sol\\\";\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract LosslessFacet is Storage, Ownable {\\r\\n    function onlyRecoveryAdminCheck() internal view {\\r\\n        require(_msgSender() == recoveryAdmin, \\\"LRA\\\");\\r\\n    }\\r\\n\\r\\n    modifier onlyRecoveryAdmin() {\\r\\n        onlyRecoveryAdminCheck();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- LOSSLESS management ---\\r\\n\\r\\n    function getAdmin() external view returns (address) {\\r\\n        return admin;\\r\\n    }\\r\\n\\r\\n    function setLosslessAdmin(address newAdmin) external onlyRecoveryAdmin {\\r\\n        require(newAdmin != address(0), \\\"LZ\\\");\\r\\n        emit AdminChanged(admin, newAdmin);\\r\\n        admin = newAdmin;\\r\\n    }\\r\\n\\r\\n    function transferRecoveryAdminOwnership(address candidate, bytes32 keyHash) external onlyRecoveryAdmin {\\r\\n        require(candidate != address(0), \\\"LZ\\\");\\r\\n        recoveryAdminCandidate = candidate;\\r\\n        recoveryAdminKeyHash = keyHash;\\r\\n        emit RecoveryAdminChangeProposed(candidate);\\r\\n    }\\r\\n\\r\\n    function acceptRecoveryAdminOwnership(bytes memory key) external {\\r\\n        require(_msgSender() == recoveryAdminCandidate, \\\"LC\\\");\\r\\n        require(keccak256(key) == recoveryAdminKeyHash, \\\"LIK\\\");\\r\\n        emit RecoveryAdminChanged(recoveryAdmin, recoveryAdminCandidate);\\r\\n        recoveryAdmin = recoveryAdminCandidate;\\r\\n    }\\r\\n\\r\\n    function proposeLosslessTurnOff() external onlyRecoveryAdmin {\\r\\n        losslessTurnOffTimestamp = block.timestamp + timelockPeriod;\\r\\n        isLosslessTurnOffProposed = true;\\r\\n        emit LosslessTurnOffProposed(losslessTurnOffTimestamp);\\r\\n    }\\r\\n\\r\\n    function executeLosslessTurnOff() external onlyRecoveryAdmin {\\r\\n        require(isLosslessTurnOffProposed, \\\"LTNP\\\");\\r\\n        require(losslessTurnOffTimestamp \\u003c= block.timestamp, \\\"LTL\\\");\\r\\n        isLosslessOn = false;\\r\\n        isLosslessTurnOffProposed = false;\\r\\n        emit LosslessTurnedOff();\\r\\n    }\\r\\n\\r\\n    function executeLosslessTurnOn() external onlyRecoveryAdmin {\\r\\n        isLosslessTurnOffProposed = false;\\r\\n        isLosslessOn = true;\\r\\n        emit LosslessTurnedOn();\\r\\n    }\\r\\n}\"},\"LPWallet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\nimport \\\"./ITaxToken.sol\\\";\\r\\nimport \\\"./ITaxHelper.sol\\\";\\r\\n\\r\\nimport \\\"./IMintFactory.sol\\\";\\r\\n\\r\\n\\r\\ncontract LPWallet is Ownable{\\r\\n\\r\\n    ITaxToken public token;\\r\\n    IMintFactory public factory;\\r\\n    uint256 private threshold;\\r\\n\\r\\n    event UpdatedThreshold(uint256 _newThreshold);\\r\\n    event ETHtoTaxHelper(uint256 amount);\\r\\n    event TransferBalancetoTaxHelper(uint256 tokenBalance);\\r\\n\\r\\n    constructor(address _factory, address _token, uint256 _newThreshold) {\\r\\n        token = ITaxToken(_token);\\r\\n        factory = IMintFactory(_factory);\\r\\n        threshold = _newThreshold;\\r\\n        emit UpdatedThreshold(_newThreshold);\\r\\n        transferOwnership(_token);\\r\\n    }\\r\\n    \\r\\n    function checkLPTrigger() public view returns (bool) {\\r\\n        return address(this).balance \\u003e threshold;\\r\\n    }\\r\\n\\r\\n    function getBalance() public view returns (uint256) {\\r\\n        return address(this).balance;\\r\\n    }\\r\\n\\r\\n    function sendEthToTaxHelper() external returns (uint256) {\\r\\n        uint index = token.taxHelperIndex();\\r\\n        require(msg.sender == factory.getTaxHelperAddress(index), \\\"RA\\\");\\r\\n        uint256 amount = address(this).balance;\\r\\n        (bool sent,) = msg.sender.call{value: amount}(\\\"\\\");\\r\\n        require(sent, \\\"Failed to send Ether\\\");\\r\\n        emit ETHtoTaxHelper(amount);\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function transferBalanceToTaxHelper() external {\\r\\n        uint index = token.taxHelperIndex();\\r\\n        require(msg.sender == factory.getTaxHelperAddress(index));\\r\\n        uint256 tokenBalance = token.balanceOf(address(this));\\r\\n        token.transfer(msg.sender, tokenBalance);\\r\\n        emit TransferBalancetoTaxHelper(tokenBalance);\\r\\n    }\\r\\n\\r\\n    function updateThreshold(uint256 _newThreshold) external onlyOwner {\\r\\n        threshold = _newThreshold;\\r\\n        emit UpdatedThreshold(_newThreshold);\\r\\n    }\\r\\n\\r\\n    function getThreshold() external view returns (uint256) {\\r\\n        return threshold;\\r\\n    }\\r\\n\\r\\n    receive() payable external {\\r\\n    }\\r\\n\\r\\n\\r\\n} \"},\"MintFactory.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\n\\r\\n// This contract logs all tokens on the platform\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./EnumerableSet.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\n\\r\\ncontract MintFactory is Ownable {\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n    \\r\\n    EnumerableSet.AddressSet private tokens;\\r\\n    EnumerableSet.AddressSet private tokenGenerators;\\r\\n\\r\\n    struct TaxHelper {\\r\\n        string Name;\\r\\n        address Address;\\r\\n        uint256 Index;\\r\\n    }\\r\\n\\r\\n    mapping(uint =\\u003e TaxHelper) private taxHelpersData;\\r\\n    address[] private taxHelpers;\\r\\n     \\r\\n    mapping(address =\\u003e address[]) private tokenOwners;\\r\\n\\r\\n    address private FacetHelper;\\r\\n    address private FeeHelper;\\r\\n    address private LosslessController;\\r\\n\\r\\n    event TokenRegistered(address tokenOwner, address tokenContract);\\r\\n    event AllowTokenGenerator(address _address, bool _allow);\\r\\n\\r\\n    event AddedTaxHelper(string _name, address _address, uint256 _index);\\r\\n    event UpdatedTaxHelper(address _newAddress, uint256 _index);\\r\\n\\r\\n    event UpdatedFacetHelper(address _newAddress);\\r\\n    event UpdatedFeeHelper(address _newAddress);\\r\\n    event UpdatedLosslessController(address _newAddress);\\r\\n    \\r\\n    function adminAllowTokenGenerator (address _address, bool _allow) public onlyOwner {\\r\\n        if (_allow) {\\r\\n            tokenGenerators.add(_address);\\r\\n        } else {\\r\\n            tokenGenerators.remove(_address);\\r\\n        }\\r\\n        emit AllowTokenGenerator(_address, _allow);\\r\\n    }\\r\\n\\r\\n    function addTaxHelper(string calldata _name, address _address) public onlyOwner {\\r\\n        uint256 index = taxHelpers.length;\\r\\n        TaxHelper memory newTaxHelper;\\r\\n        newTaxHelper.Name = _name;\\r\\n        newTaxHelper.Address = _address;\\r\\n        newTaxHelper.Index = index;\\r\\n        taxHelpersData[index] = newTaxHelper;\\r\\n        taxHelpers.push(_address);\\r\\n        emit AddedTaxHelper(_name, _address, index);\\r\\n    }\\r\\n\\r\\n    function updateTaxHelper(uint256 _index, address _address) public onlyOwner {\\r\\n        taxHelpersData[_index].Address = _address;\\r\\n        taxHelpers[_index] = _address;\\r\\n        emit UpdatedTaxHelper(_address, _index);\\r\\n    }\\r\\n\\r\\n    function getTaxHelperAddress(uint256 _index) public view returns(address){\\r\\n        return taxHelpers[_index];\\r\\n    }\\r\\n\\r\\n    function getTaxHelpersDataByIndex(uint256 _index) public view returns(TaxHelper memory) {\\r\\n        return taxHelpersData[_index];\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice called by a registered tokenGenerator upon token creation\\r\\n     */\\r\\n    function registerToken (address _tokenOwner, address _tokenAddress) public {\\r\\n        require(tokenGenerators.contains(msg.sender), \\u0027FORBIDDEN\\u0027);\\r\\n        tokens.add(_tokenAddress);\\r\\n        tokenOwners[_tokenOwner].push(_tokenAddress);\\r\\n        emit TokenRegistered(_tokenOwner, _tokenAddress);\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * @notice gets a token at index registered under a user address\\r\\n     * @return token addresses registered to the user address\\r\\n     */\\r\\n     function getTokenByOwnerAtIndex(address _tokenOwner, uint256 _index) external view returns(address) {\\r\\n         return tokenOwners[_tokenOwner][_index];\\r\\n     }\\r\\n     \\r\\n     /**\\r\\n     * @notice gets the total of tokens registered under a user address\\r\\n     * @return uint total of token addresses registered to the user address\\r\\n     */\\r\\n     \\r\\n     function getTokensLengthByOwner(address _tokenOwner) external view returns(uint256) {\\r\\n         return tokenOwners[_tokenOwner].length;\\r\\n     }\\r\\n    \\r\\n    /**\\r\\n     * @notice Number of allowed tokenGenerators\\r\\n     */\\r\\n    function tokenGeneratorsLength() external view returns (uint256) {\\r\\n        return tokenGenerators.length();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice Gets the address of a registered tokenGenerator at specified index\\r\\n     */\\r\\n    function tokenGeneratorAtIndex(uint256 _index) external view returns (address) {\\r\\n        return tokenGenerators.at(_index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice returns true if user is allowed to generate tokens\\r\\n     */\\r\\n    function tokenGeneratorIsAllowed(address _tokenGenerator) external view returns (bool) {\\r\\n        return tokenGenerators.contains(_tokenGenerator);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice returns true if the token address was generated by the Unicrypt token platform\\r\\n     */\\r\\n    function tokenIsRegistered(address _tokenAddress) external view returns (bool) {\\r\\n        return tokens.contains(_tokenAddress);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice The length of all tokens on the platform\\r\\n     */\\r\\n    function tokensLength() external view returns (uint256) {\\r\\n        return tokens.length();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice gets a token at a specific index. Although using Enumerable Set, since tokens are only added and not removed, indexes will never change\\r\\n     * @return the address of the token contract at index\\r\\n     */\\r\\n    function tokenAtIndex(uint256 _index) external view returns (address) {\\r\\n        return tokens.at(_index);\\r\\n    }\\r\\n\\r\\n    // Helpers and Controllers\\r\\n    \\r\\n    function getFacetHelper() public view returns (address) {\\r\\n        return FacetHelper;\\r\\n    }\\r\\n\\r\\n    function updateFacetHelper(address _newFacetHelperAddress) public onlyOwner {\\r\\n        require(_newFacetHelperAddress != address(0));\\r\\n        FacetHelper = _newFacetHelperAddress;\\r\\n        emit UpdatedFacetHelper(_newFacetHelperAddress);\\r\\n    }\\r\\n\\r\\n    function getFeeHelper() public view returns (address) {\\r\\n        return FeeHelper;\\r\\n    }\\r\\n\\r\\n    function updateFeeHelper(address _newFeeHelperAddress) public onlyOwner {\\r\\n        require(_newFeeHelperAddress != address(0));\\r\\n        FeeHelper = _newFeeHelperAddress;\\r\\n        emit UpdatedFeeHelper(_newFeeHelperAddress);\\r\\n    }\\r\\n\\r\\n    function getLosslessController() public view returns (address) {\\r\\n        return LosslessController;\\r\\n    }\\r\\n\\r\\n    function updateLosslessController(address _newLosslessControllerAddress) public onlyOwner {\\r\\n        require(_newLosslessControllerAddress != address(0));\\r\\n        LosslessController = _newLosslessControllerAddress;\\r\\n        emit UpdatedLosslessController(_newLosslessControllerAddress);\\r\\n    }\\r\\n}\"},\"MintGenerator.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\n\\r\\n// This contract generates Token01 contracts and registers them in the TokenFactory.\\r\\n// Ideally you should not interact with this contract directly, and use the Unicrypt token app instead so warnings can be shown where necessary.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\nimport \\\"./TaxToken.sol\\\";\\r\\n\\r\\nimport \\\"./IMintFactory.sol\\\";\\r\\nimport \\\"./IFeeHelper.sol\\\";\\r\\n\\r\\ncontract MintGenerator is Ownable {\\r\\n    \\r\\n    uint256 public CONTRACT_VERSION = 1;\\r\\n\\r\\n\\r\\n    IMintFactory public MINT_FACTORY;\\r\\n    IFeeHelper public FEE_HELPER;\\r\\n    \\r\\n    constructor(address _mintFactory, address _feeHelper) {\\r\\n        MINT_FACTORY = IMintFactory(_mintFactory);\\r\\n        FEE_HELPER = IFeeHelper(_feeHelper);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice Creates a new Token contract and registers it in the TokenFactory.sol.\\r\\n     */\\r\\n    \\r\\n    function createToken (\\r\\n      TaxToken.ConstructorParams calldata params\\r\\n      ) public payable returns (address){\\r\\n        require(msg.value == FEE_HELPER.getGeneratorFee(), \\u0027FEE NOT MET\\u0027);\\r\\n        payable(FEE_HELPER.getFeeAddress()).transfer(FEE_HELPER.getGeneratorFee());\\r\\n        TaxToken newToken = new TaxToken(params, address(MINT_FACTORY));\\r\\n        MINT_FACTORY.registerToken(msg.sender, address(newToken));\\r\\n        return address(newToken);\\r\\n    }\\r\\n}\"},\"Multicall.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Storage.sol\\\";\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract MulticallFacet is Storage, Ownable { \\r\\n    struct MulticallAdminUpdateParams {\\r\\n        TaxSettings _taxSettings;\\r\\n        TaxSettings _lockSettings;\\r\\n        CustomTax[] _customTaxes;\\r\\n        Fees _fees;\\r\\n        address _transactionTaxWallet;\\r\\n        uint256 _maxBalanceAfterBuy;\\r\\n    }\\r\\n\\r\\n    function multicallAdminUpdate(MulticallAdminUpdateParams calldata params) public onlyOwner {\\r\\n        // Tax Settings\\r\\n        if(!isLocked.transactionTax \\u0026\\u0026 taxSettings.transactionTax != params._taxSettings.transactionTax) {\\r\\n            taxSettings.transactionTax = params._taxSettings.transactionTax;\\r\\n        }\\r\\n        if(!isLocked.holderTax \\u0026\\u0026 taxSettings.holderTax != params._taxSettings.holderTax \\u0026\\u0026 !params._taxSettings.canMint) {\\r\\n            taxSettings.holderTax = params._taxSettings.holderTax;\\r\\n        }\\r\\n        if(!isLocked.buyBackTax \\u0026\\u0026 taxSettings.buyBackTax != params._taxSettings.buyBackTax) {\\r\\n            taxSettings.buyBackTax = params._taxSettings.buyBackTax;\\r\\n        }\\r\\n        if(!isLocked.lpTax \\u0026\\u0026 taxSettings.lpTax != params._taxSettings.lpTax) {\\r\\n            taxSettings.lpTax = params._taxSettings.lpTax;\\r\\n        }\\r\\n        if(!isLocked.canMint \\u0026\\u0026 taxSettings.canMint != params._taxSettings.canMint \\u0026\\u0026 !taxSettings.holderTax) {\\r\\n            taxSettings.canMint = params._taxSettings.canMint;\\r\\n        }\\r\\n        if(!isLocked.canPause \\u0026\\u0026 taxSettings.canPause != params._taxSettings.canPause) {\\r\\n            taxSettings.canPause = params._taxSettings.canPause;\\r\\n        }\\r\\n        if(!isLocked.canBlacklist \\u0026\\u0026 taxSettings.canBlacklist != params._taxSettings.canBlacklist) {\\r\\n            taxSettings.canBlacklist = params._taxSettings.canBlacklist;\\r\\n        }\\r\\n        if(!isLocked.maxBalanceAfterBuy \\u0026\\u0026 taxSettings.maxBalanceAfterBuy != params._taxSettings.maxBalanceAfterBuy) {\\r\\n            taxSettings.maxBalanceAfterBuy = params._taxSettings.maxBalanceAfterBuy;\\r\\n        }\\r\\n        emit UpdatedSettings(taxSettings);\\r\\n\\r\\n\\r\\n        // Lock Settings\\r\\n        if(!isLocked.transactionTax) {\\r\\n            isLocked.transactionTax = params._lockSettings.transactionTax;\\r\\n        }\\r\\n        if(!isLocked.holderTax) {\\r\\n            isLocked.holderTax = params._lockSettings.holderTax;\\r\\n        }\\r\\n        if(!isLocked.buyBackTax) {\\r\\n            isLocked.buyBackTax = params._lockSettings.buyBackTax;\\r\\n        }\\r\\n        if(!isLocked.lpTax) {\\r\\n            isLocked.lpTax = params._lockSettings.lpTax;\\r\\n        }\\r\\n        if(!isLocked.canMint) {\\r\\n            isLocked.canMint = params._lockSettings.canMint;\\r\\n        }\\r\\n        if(!isLocked.canPause) {\\r\\n            isLocked.canPause = params._lockSettings.canPause;\\r\\n        }\\r\\n        if(!isLocked.canBlacklist) {\\r\\n            isLocked.canBlacklist = params._lockSettings.canBlacklist;\\r\\n        }\\r\\n        if(!isLocked.maxBalanceAfterBuy) {\\r\\n            isLocked.maxBalanceAfterBuy = params._lockSettings.maxBalanceAfterBuy;\\r\\n        }\\r\\n        emit UpdatedLockedSettings(isLocked);\\r\\n\\r\\n\\r\\n        // Custom Taxes\\r\\n        require(params._customTaxes.length \\u003c MaxCustom + 1, \\\"MCT\\\");\\r\\n        delete customTaxes;\\r\\n\\r\\n        for(uint i = 0; i \\u003c params._customTaxes.length; i++) {\\r\\n            require(params._customTaxes[i].wallet != address(0), \\\"ZA\\\");\\r\\n            customTaxes.push(params._customTaxes[i]);\\r\\n        }\\r\\n        customTaxLength = params._customTaxes.length;\\r\\n        emit UpdatedCustomTaxes(params._customTaxes);\\r\\n\\r\\n        // Fees        \\r\\n        fees.transactionTax.buy = params._fees.transactionTax.buy;\\r\\n        fees.transactionTax.sell = params._fees.transactionTax.sell;\\r\\n\\r\\n        fees.buyBackTax = params._fees.buyBackTax;\\r\\n\\r\\n        fees.holderTax = params._fees.holderTax;\\r\\n\\r\\n        fees.lpTax = params._fees.lpTax;\\r\\n\\r\\n        require(checkMaxTax(true), \\\"BF\\\");\\r\\n        require(checkMaxTax(false), \\\"SF\\\");\\r\\n        emit UpdatedTaxFees(params._fees);\\r\\n        \\r\\n        // transactionTax address\\r\\n        require(params._transactionTaxWallet != address(0), \\\"ZA\\\");\\r\\n        transactionTaxWallet = params._transactionTaxWallet;\\r\\n        emit UpdatedTransactionTaxAddress(params._transactionTaxWallet);\\r\\n\\r\\n        // maxBalanceAfterBuy\\r\\n        if(taxSettings.maxBalanceAfterBuy) {\\r\\n            maxBalanceAfterBuy = params._maxBalanceAfterBuy;\\r\\n            emit UpdatedMaxBalanceAfterBuy(params._maxBalanceAfterBuy);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function checkMaxTax(bool isBuy) internal view returns (bool) {\\r\\n        uint256 totalTaxes;\\r\\n        if(isBuy) {\\r\\n            totalTaxes += fees.transactionTax.buy;\\r\\n            totalTaxes += fees.holderTax;\\r\\n            for(uint i = 0; i \\u003c customTaxes.length; i++) {\\r\\n                totalTaxes += customTaxes[i].fee.buy;\\r\\n            }\\r\\n        } else {\\r\\n            totalTaxes += fees.transactionTax.sell;\\r\\n            totalTaxes += fees.lpTax;\\r\\n            totalTaxes += fees.holderTax;\\r\\n            totalTaxes += fees.buyBackTax;\\r\\n            for(uint i = 0; i \\u003c customTaxes.length; i++) {\\r\\n                totalTaxes += customTaxes[i].fee.sell;\\r\\n            }\\r\\n        }\\r\\n        if(totalTaxes \\u003c= MaxTax) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    struct AntiBotUpdateParams {\\r\\n        AntiBotSettings _antiBotSettings;\\r\\n        SwapWhitelistingSettings _swapWhitelistingSettings;\\r\\n    }\\r\\n\\r\\n    // Multicall AntiBot Update\\r\\n    function multicallAntiBotUpdate(AntiBotUpdateParams calldata params) public onlyOwner {\\r\\n        // AntiBot\\r\\n        antiBotSettings.increment = params._antiBotSettings.increment;\\r\\n        emit UpdatedAntiBotIncrement(antiBotSettings.increment);\\r\\n\\r\\n        require(params._antiBotSettings.endDate \\u003c= 48, \\\"ED\\\");\\r\\n        antiBotSettings.endDate = params._antiBotSettings.endDate;\\r\\n        emit UpdatedAntiBotEndDate(antiBotSettings.endDate);\\r\\n\\r\\n        antiBotSettings.initialMaxHold = params._antiBotSettings.initialMaxHold;\\r\\n        emit UpdatedAntiBotInitialMaxHold(antiBotSettings.initialMaxHold);\\r\\n\\r\\n        if(!marketInit) {\\r\\n            antiBotSettings.isActive = params._antiBotSettings.isActive;\\r\\n            emit UpdatedAntiBotActiveStatus(antiBotSettings.isActive);\\r\\n        }\\r\\n\\r\\n        // SwapWhitelisting\\r\\n        require(params._swapWhitelistingSettings.endDate \\u003c= 48, \\\"ED\\\");\\r\\n        swapWhitelistingSettings.endDate = params._swapWhitelistingSettings.endDate;\\r\\n        emit UpdatedSwapWhitelistingEndDate(antiBotSettings.endDate);\\r\\n\\r\\n        if(!marketInit) {\\r\\n            swapWhitelistingSettings.isActive = params._swapWhitelistingSettings.isActive;\\r\\n            emit UpdatedSwapWhitelistingActiveStatus(swapWhitelistingSettings.isActive);\\r\\n        }\\r\\n    }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n// File @openzeppelin/contracts/access/Ownable.sol@v4.0.0\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"},\"Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which allows children to implement an emergency stop\\r\\n * mechanism that can be triggered by an authorized account.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the\\r\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\r\\n * the functions of your contract. Note that they will not be pausable by\\r\\n * simply including this module, only once the modifiers are put in place.\\r\\n */\\r\\nabstract contract Pausable is Context {\\r\\n    /**\\r\\n     * @dev Emitted when the pause is triggered by `account`.\\r\\n     */\\r\\n    event Paused(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is lifted by `account`.\\r\\n     */\\r\\n    event Unpaused(address account);\\r\\n\\r\\n    bool private _paused;\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract in unpaused state.\\r\\n     */\\r\\n    constructor() {\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the contract is paused, and false otherwise.\\r\\n     */\\r\\n    function paused() public view virtual returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        require(!paused(), \\\"Pausable: paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        require(paused(), \\\"Pausable: not paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers stopped state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    function _pause() internal virtual whenNotPaused {\\r\\n        _paused = true;\\r\\n        emit Paused(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns to normal state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    function _unpause() internal virtual whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(_msgSender());\\r\\n    }\\r\\n}\"},\"Settings.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Storage.sol\\\";\\r\\nimport \\\"./BuyBackWallet.sol\\\";\\r\\nimport \\\"./LPWallet.sol\\\";\\r\\n\\r\\n\\r\\nimport \\\"./IBuyBackWallet.sol\\\";\\r\\nimport \\\"./ILPWallet.sol\\\";\\r\\nimport \\\"./IFeeHelper.sol\\\";\\r\\nimport \\\"./IMintFactory.sol\\\";\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract SettingsFacet is Storage, Ownable {\\r\\n\\r\\n    function canBlacklistRequire() internal view {\\r\\n        require(taxSettings.canBlacklist, \\\"NB\\\");\\r\\n    }\\r\\n\\r\\n    modifier canBlacklist {\\r\\n        canBlacklistRequire();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function addLPToken(address _newLPToken) public onlyOwner {\\r\\n        lpTokens[_newLPToken] = true;\\r\\n        emit AddedLPToken(_newLPToken);\\r\\n    }\\r\\n\\r\\n    function removeLPToken(address _lpToken) public onlyOwner {\\r\\n        lpTokens[_lpToken] = false;\\r\\n        emit RemovedLPToken(_lpToken);\\r\\n    }\\r\\n\\r\\n    function checkMaxTax(bool isBuy) internal view returns (bool) {\\r\\n        uint256 totalTaxes;\\r\\n        if(isBuy) {\\r\\n            totalTaxes += fees.transactionTax.buy;\\r\\n            totalTaxes += fees.holderTax;\\r\\n            for(uint i = 0; i \\u003c customTaxes.length; i++) {\\r\\n                totalTaxes += customTaxes[i].fee.buy;\\r\\n            }\\r\\n        } else {\\r\\n            totalTaxes += fees.transactionTax.sell;\\r\\n            totalTaxes += fees.lpTax;\\r\\n            totalTaxes += fees.holderTax;\\r\\n            totalTaxes += fees.buyBackTax;\\r\\n            for(uint i = 0; i \\u003c customTaxes.length; i++) {\\r\\n                totalTaxes += customTaxes[i].fee.sell;\\r\\n            }\\r\\n        }\\r\\n        if(totalTaxes \\u003c= MaxTax) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function paused() public view returns (bool) {\\r\\n        if(taxSettings.canPause == false) {\\r\\n            return false;\\r\\n        }\\r\\n        return isPaused;\\r\\n    }\\r\\n\\r\\n    function togglePause() public onlyOwner returns (bool) {\\r\\n        require(taxSettings.canPause, \\\"NP\\\");\\r\\n        isPaused = !isPaused;\\r\\n        emit ToggledPause(isPaused);\\r\\n        return isPaused;\\r\\n    }\\r\\n\\r\\n    function addBlacklistedAddress(address _address) public onlyOwner canBlacklist {\\r\\n        IFeeHelper feeHelper = IFeeHelper(IMintFactory(factory).getFeeHelper());\\r\\n        address feeAddress = feeHelper.getFeeAddress();\\r\\n        require(_address != feeAddress);\\r\\n        blacklist[_address] = true;\\r\\n        emit AddedBlacklistAddress(_address);\\r\\n    }\\r\\n\\r\\n    function removeBlacklistedAddress(address _address) public onlyOwner canBlacklist {\\r\\n        blacklist[_address] = false;\\r\\n        emit RemovedBlacklistAddress(_address);\\r\\n    }\\r\\n\\r\\n    function updateBlacklistBatch(address[] calldata _updatedAddresses, bool _isBlacklisted) public onlyOwner canBlacklist {\\r\\n        IFeeHelper feeHelper = IFeeHelper(IMintFactory(factory).getFeeHelper());\\r\\n        address feeAddress = feeHelper.getFeeAddress();\\r\\n        for(uint i = 0; i \\u003c _updatedAddresses.length; i++) {\\r\\n            if(_updatedAddresses[i] != feeAddress) {\\r\\n                blacklist[_updatedAddresses[i]] = _isBlacklisted;\\r\\n                if(_isBlacklisted) {\\r\\n                    emit AddedBlacklistAddress(_updatedAddresses[i]);\\r\\n                } else {\\r\\n                    emit RemovedBlacklistAddress(_updatedAddresses[i]);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isBlacklisted(address _address) public view returns (bool) {\\r\\n        return blacklist[_address];\\r\\n    }\\r\\n\\r\\n    function updateCustomTaxes(CustomTax[] calldata _customTaxes) public onlyOwner {\\r\\n        require(_customTaxes.length \\u003c MaxCustom + 1, \\\"MCT\\\");\\r\\n        delete customTaxes;\\r\\n\\r\\n        for(uint i = 0; i \\u003c _customTaxes.length; i++) {\\r\\n            require(_customTaxes[i].wallet != address(0));\\r\\n            customTaxes.push(_customTaxes[i]);\\r\\n        }\\r\\n        customTaxLength = _customTaxes.length;\\r\\n\\r\\n        require(checkMaxTax(true), \\\"BF\\\");\\r\\n        require(checkMaxTax(false), \\\"SF\\\");\\r\\n        emit UpdatedCustomTaxes(_customTaxes);\\r\\n    }\\r\\n\\r\\n    function updateTaxFees(Fees calldata _updatedFees) public onlyOwner {\\r\\n        fees.transactionTax.buy = _updatedFees.transactionTax.buy;\\r\\n        fees.transactionTax.sell = _updatedFees.transactionTax.sell;\\r\\n\\r\\n        fees.buyBackTax = _updatedFees.buyBackTax;\\r\\n\\r\\n        fees.holderTax = _updatedFees.holderTax;\\r\\n\\r\\n        fees.lpTax = _updatedFees.lpTax;\\r\\n\\r\\n        require(checkMaxTax(true), \\\"BF\\\");\\r\\n        require(checkMaxTax(false), \\\"SF\\\");\\r\\n        emit UpdatedTaxFees(_updatedFees);\\r\\n    }\\r\\n\\r\\n    function updateTransactionTaxAddress(address _newAddress) public onlyOwner {\\r\\n        // confirm if this is updateable\\r\\n        require(_newAddress != address(0));\\r\\n        transactionTaxWallet = _newAddress;\\r\\n        emit UpdatedTransactionTaxAddress(_newAddress);\\r\\n    }\\r\\n\\r\\n    function lockSettings(TaxSettings calldata _updatedLocks) public onlyOwner {\\r\\n        if(!isLocked.transactionTax) {\\r\\n            isLocked.transactionTax = _updatedLocks.transactionTax;\\r\\n        }\\r\\n        if(!isLocked.holderTax) {\\r\\n            isLocked.holderTax = _updatedLocks.holderTax;\\r\\n        }\\r\\n        if(!isLocked.buyBackTax) {\\r\\n            isLocked.buyBackTax = _updatedLocks.buyBackTax;\\r\\n        }\\r\\n        if(!isLocked.lpTax) {\\r\\n            isLocked.lpTax = _updatedLocks.lpTax;\\r\\n        }\\r\\n        if(!isLocked.canMint) {\\r\\n            isLocked.canMint = _updatedLocks.canMint;\\r\\n        }\\r\\n        if(!isLocked.canPause) {\\r\\n            isLocked.canPause = _updatedLocks.canPause;\\r\\n        }\\r\\n        if(!isLocked.canBlacklist) {\\r\\n            isLocked.canBlacklist = _updatedLocks.canBlacklist;\\r\\n        }\\r\\n        if(!isLocked.maxBalanceAfterBuy) {\\r\\n            isLocked.maxBalanceAfterBuy = _updatedLocks.maxBalanceAfterBuy;\\r\\n        }\\r\\n        emit UpdatedLockedSettings(isLocked);\\r\\n    }\\r\\n\\r\\n    function updateSettings(TaxSettings calldata _updatedSettings) public onlyOwner {\\r\\n        if(!isLocked.transactionTax \\u0026\\u0026 taxSettings.transactionTax != _updatedSettings.transactionTax) {\\r\\n            taxSettings.transactionTax = _updatedSettings.transactionTax;\\r\\n        }\\r\\n        if(!isLocked.holderTax \\u0026\\u0026 taxSettings.holderTax != _updatedSettings.holderTax \\u0026\\u0026 !_updatedSettings.canMint) {\\r\\n            taxSettings.holderTax = _updatedSettings.holderTax;\\r\\n        }\\r\\n        if(!isLocked.buyBackTax \\u0026\\u0026 taxSettings.buyBackTax != _updatedSettings.buyBackTax) {\\r\\n            taxSettings.buyBackTax = _updatedSettings.buyBackTax;\\r\\n        }\\r\\n        if(!isLocked.lpTax \\u0026\\u0026 taxSettings.lpTax != _updatedSettings.lpTax) {\\r\\n            taxSettings.lpTax = _updatedSettings.lpTax;\\r\\n        }\\r\\n        if(!isLocked.canMint \\u0026\\u0026 taxSettings.canMint != _updatedSettings.canMint \\u0026\\u0026 !taxSettings.holderTax) {\\r\\n            taxSettings.canMint = _updatedSettings.canMint;\\r\\n        }\\r\\n        if(!isLocked.canPause \\u0026\\u0026 taxSettings.canPause != _updatedSettings.canPause) {\\r\\n            taxSettings.canPause = _updatedSettings.canPause;\\r\\n        }\\r\\n        if(!isLocked.canBlacklist \\u0026\\u0026 taxSettings.canBlacklist != _updatedSettings.canBlacklist) {\\r\\n            taxSettings.canBlacklist = _updatedSettings.canBlacklist;\\r\\n        }\\r\\n        if(!isLocked.maxBalanceAfterBuy \\u0026\\u0026 taxSettings.maxBalanceAfterBuy != _updatedSettings.maxBalanceAfterBuy) {\\r\\n            taxSettings.maxBalanceAfterBuy = _updatedSettings.maxBalanceAfterBuy;\\r\\n        }\\r\\n        emit UpdatedSettings(taxSettings);\\r\\n    }\\r\\n\\r\\n    function updatePairAddress(address _newPairAddress) public onlyOwner {\\r\\n        pairAddress = _newPairAddress;\\r\\n        emit UpdatedPairAddress(_newPairAddress);\\r\\n    }\\r\\n\\r\\n    function updateTaxHelperIndex(uint8 _newIndex) public onlyOwner {\\r\\n        taxHelperIndex = _newIndex;\\r\\n        emit UpdatedTaxHelperIndex(_newIndex);\\r\\n    }\\r\\n}\"},\"Storage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./ILosslessController.sol\\\";\\r\\n\\r\\ncontract Storage {\\r\\n\\r\\n    uint256 public CONTRACT_VERSION = 1;\\r\\n\\r\\n    struct TaxSettings {\\r\\n        bool transactionTax;\\r\\n        bool buyBackTax;\\r\\n        bool holderTax;\\r\\n        bool lpTax;\\r\\n        bool canBlacklist;\\r\\n        bool canMint;\\r\\n        bool canPause;\\r\\n        bool maxBalanceAfterBuy;\\r\\n    }\\r\\n\\r\\n    struct Fee {\\r\\n        uint256 buy;\\r\\n        uint256 sell;\\r\\n    }\\r\\n\\r\\n    struct Fees {\\r\\n        Fee transactionTax;\\r\\n        uint256 buyBackTax;\\r\\n        uint256 holderTax;\\r\\n        uint256 lpTax;\\r\\n    }\\r\\n\\r\\n    struct CustomTax {\\r\\n        string name;\\r\\n        Fee fee;\\r\\n        address wallet;\\r\\n    }\\r\\n\\r\\n    TaxSettings public taxSettings;\\r\\n    TaxSettings public isLocked;\\r\\n    Fees public fees;\\r\\n    CustomTax[] public customTaxes;\\r\\n\\r\\n    address public transactionTaxWallet;\\r\\n    uint256 public customTaxLength = 0;\\r\\n    uint256 public MaxTax = 3000;\\r\\n    uint8 public MaxCustom = 10;\\r\\n\\r\\n    uint256 internal DENOMINATOR;\\r\\n\\r\\n    mapping (address =\\u003e uint256) internal _rOwned;\\r\\n    mapping (address =\\u003e uint256) internal _tOwned;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public _allowances;\\r\\n\\r\\n    mapping (address =\\u003e bool) public _isExcluded;\\r\\n    address[] internal _excluded;\\r\\n   \\r\\n    uint256 constant MAX = ~uint256(0);\\r\\n    uint256 internal _tTotal;\\r\\n    uint256 internal _rTotal;\\r\\n    uint256 public _tFeeTotal;\\r\\n\\r\\n    mapping (address =\\u003e bool) public lpTokens;\\r\\n    \\r\\n    string internal _name;\\r\\n    string internal _symbol;\\r\\n    uint8 internal _decimals;\\r\\n    address internal _creator;\\r\\n\\r\\n    address public factory;\\r\\n\\r\\n    address public buyBackWallet;\\r\\n    address public lpWallet;\\r\\n\\r\\n    bool internal isPaused = false;\\r\\n\\r\\n    bool internal isTaxed = false;\\r\\n    \\r\\n    mapping(address =\\u003e bool) internal blacklist;\\r\\n    mapping(address =\\u003e bool) internal swapWhitelist;\\r\\n    mapping(address =\\u003e bool) internal maxBalanceWhitelist;\\r\\n\\r\\n    address public pairAddress;\\r\\n\\r\\n    uint256 public taxHelperIndex;\\r\\n\\r\\n    // AntiBot Variables\\r\\n\\r\\n    bool public marketInit = false;\\r\\n    uint256 public marketInitBlockTime;\\r\\n\\r\\n    struct AntiBotSettings {\\r\\n        uint256 startBlock;\\r\\n        uint256 endDate;\\r\\n        uint256 increment;\\r\\n        uint256 initialMaxHold;\\r\\n        bool isActive;\\r\\n    }\\r\\n\\r\\n    AntiBotSettings public antiBotSettings;\\r\\n\\r\\n    mapping (address =\\u003e uint256) internal antiBotBalanceTracker;\\r\\n\\r\\n    uint256 public maxBalanceAfterBuy;\\r\\n\\r\\n    struct SwapWhitelistingSettings {\\r\\n        uint256 endDate;\\r\\n        bool isActive;\\r\\n    }\\r\\n    \\r\\n    SwapWhitelistingSettings public swapWhitelistingSettings;\\r\\n\\r\\n    // Lossless data and events\\r\\n\\r\\n    address public recoveryAdmin;\\r\\n    address internal recoveryAdminCandidate;\\r\\n    bytes32 internal recoveryAdminKeyHash;\\r\\n    address public admin;\\r\\n    uint256 public timelockPeriod;\\r\\n    uint256 public losslessTurnOffTimestamp;\\r\\n    bool public isLosslessTurnOffProposed;\\r\\n    bool public isLosslessOn;\\r\\n    ILosslessController public lossless;\\r\\n\\r\\n    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);\\r\\n    event RecoveryAdminChangeProposed(address indexed candidate);\\r\\n    event RecoveryAdminChanged(address indexed previousAdmin, address indexed newAdmin);\\r\\n    event LosslessTurnOffProposed(uint256 turnOffDate);\\r\\n    event LosslessTurnedOff();\\r\\n    event LosslessTurnedOn();\\r\\n\\r\\n    // Events \\r\\n\\r\\n    event TokenCreated(string name, string symbol, uint8 decimals, uint256 totalSupply, uint256 reflectionTotalSupply);\\r\\n\\r\\n    event AddedBlacklistAddress(address _address);\\r\\n    event RemovedBlacklistAddress(address _address);\\r\\n    event ToggledPause(bool _isPaused);\\r\\n    event AddedLPToken(address _newLPToken);\\r\\n    event RemovedLPToken(address _lpToken);\\r\\n    event CreatedBuyBackWallet(address _wallet);\\r\\n    event CreatedLPWallet(address _wallet);\\r\\n    event UpdatedBuyBackWalletThreshold(uint256 _newThreshold);\\r\\n    event UpdatedLPWalletThreshold(uint256 _newThreshold);\\r\\n\\r\\n    event MarketInit(uint256 timestamp, uint256 blockNumber);\\r\\n\\r\\n    event BuyBackTaxInitiated(address _sender, uint256 _fee, address _wallet, bool _isBuy);\\r\\n    event TransactionTaxInitiated(address _sender, uint256 _fee, address _wallet, bool _isBuy);\\r\\n    event LPTaxInitiated(address _sender, uint256 _fee, address _wallet, bool _isBuy);\\r\\n    event CustomTaxInitiated(address _sender, uint256 _fee, address _wallet, bool _isBuy);\\r\\n\\r\\n    event UpdatedCustomTaxes(CustomTax[] _customTaxes);\\r\\n    event UpdatedTaxFees(Fees _updatedFees);\\r\\n    event UpdatedTransactionTaxAddress(address _newAddress);\\r\\n    event UpdatedLockedSettings(TaxSettings _updatedLocks);\\r\\n    event UpdatedSettings(TaxSettings _updatedSettings);\\r\\n    event UpdatedPairAddress(address _newPairAddress);\\r\\n    event UpdatedTaxHelperIndex(uint _newIndex);\\r\\n\\r\\n    event Reflect(uint256 tAmount, uint256 rAmount, uint256 rTotal_, uint256 teeTotal_);\\r\\n    event ExcludedAccount(address account);\\r\\n    event IncludedAccount(address account);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    // AntiBot\\r\\n\\r\\n    event UpdatedAntiBotSettings(AntiBotSettings _antiBotSettings);\\r\\n    event UpdatedSwapWhitelistingSettings(SwapWhitelistingSettings _swapWhitelistingSettings);\\r\\n\\r\\n    event UpdatedAntiBotIncrement(uint256 _updatedIncrement);\\r\\n    event UpdatedAntiBotEndDate(uint256 _updatedEndDate);\\r\\n    event UpdatedAntiBotInitialMaxHold(uint256 _updatedInitialMaxHold);\\r\\n    event UpdatedAntiBotActiveStatus(bool _isActive);\\r\\n    event UpdatedSwapWhitelistingEndDate(uint256 _updatedEndDate);\\r\\n    event UpdatedSwapWhitelistingActiveStatus(bool _isActive);\\r\\n    event UpdatedMaxBalanceAfterBuy(uint256 _newMaxBalance);\\r\\n\\r\\n    event AddedMaxBalanceWhitelistAddress(address _address);   \\r\\n    event RemovedMaxBalanceWhitelistAddress(address _address);        \\r\\n    event AddedSwapWhitelistAddress(address _address);\\r\\n    event RemovedSwapWhitelistAddress(address _address);\\r\\n}\"},\"Tax.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\n// This contract logs all tokens on the platform\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./ITaxHelper.sol\\\";\\r\\nimport \\\"./IMintFactory.sol\\\";\\r\\nimport \\\"./ILosslessController.sol\\\";\\r\\nimport \\\"./IFeeHelper.sol\\\";\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./FullMath.sol\\\";\\r\\n\\r\\nimport \\\"./Storage.sol\\\";\\r\\n\\r\\nimport \\\"./BuyBackWallet.sol\\\";\\r\\nimport \\\"./LPWallet.sol\\\";\\r\\n\\r\\n\\r\\ncontract TaxFacet is Storage, Ownable{\\r\\n\\r\\n    function paused() internal view returns (bool) {\\r\\n        return isPaused;\\r\\n    }\\r\\n\\r\\n    function isBlacklisted(address _address) internal view returns (bool) {\\r\\n        return blacklist[_address];\\r\\n    }\\r\\n\\r\\n    /// @notice Handles the taxes for the token.\\r\\n    /// Calls the appropriate tax helper contract to handle \\r\\n    /// LP and BuyBack tax logic\\r\\n    /// @dev handles every tax within the tax facet. \\r\\n    /// @param sender the one sending the transaction\\r\\n    /// @param recipient the one receiving the transaction\\r\\n    /// @param amount the amount of tokens being sent\\r\\n    /// @return totalTaxAmount the total amount of the token taxed\\r\\n    function handleTaxes(address sender, address recipient, uint256 amount) public virtual returns (uint256 totalTaxAmount) {\\r\\n        // restrict it to being only called by registered tokens\\r\\n        require(IMintFactory(factory).tokenIsRegistered(address(this)));\\r\\n        bool isBuy = false;\\r\\n\\r\\n        if(lpTokens[sender]) {\\r\\n            isBuy = true;\\r\\n            if(!marketInit) {\\r\\n                marketInit = true;\\r\\n                antiBotSettings.startBlock = block.number;\\r\\n                marketInitBlockTime = block.timestamp;\\r\\n                emit MarketInit(block.timestamp, block.number);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(!lpTokens[sender] \\u0026\\u0026 !lpTokens[recipient]) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        ITaxHelper TaxHelper = ITaxHelper(IMintFactory(factory).getTaxHelperAddress(taxHelperIndex));\\r\\n        if(sender == address(TaxHelper) || recipient == address(TaxHelper)) {\\r\\n            return 0;\\r\\n        }\\r\\n        totalTaxAmount;\\r\\n        uint256 fee;\\r\\n        if(taxSettings.buyBackTax \\u0026\\u0026 !isBuy) {\\r\\n            if(TaxHelper.lpTokenHasReserves(pairAddress)) {\\r\\n                fee = amount * fees.buyBackTax / DENOMINATOR;\\r\\n            }\\r\\n            \\r\\n            if(fee != 0) {\\r\\n                _transfer(sender, address(TaxHelper), fee);\\r\\n\\r\\n                TaxHelper.initiateBuyBackTax(address(this), address(buyBackWallet));\\r\\n                emit BuyBackTaxInitiated(sender, fee, address(buyBackWallet), isBuy);\\r\\n                totalTaxAmount += fee;\\r\\n            }\\r\\n            fee = 0;\\r\\n        }\\r\\n        if(taxSettings.transactionTax) {\\r\\n            if(isBuy) {\\r\\n                fee = amount * fees.transactionTax.buy / DENOMINATOR;\\r\\n            } else {\\r\\n                fee = amount * fees.transactionTax.sell / DENOMINATOR;\\r\\n            }\\r\\n            if(fee != 0) {\\r\\n                _transfer(sender, transactionTaxWallet, fee);\\r\\n                emit TransactionTaxInitiated(sender, fee, transactionTaxWallet, isBuy);\\r\\n                totalTaxAmount += fee;\\r\\n            }\\r\\n            fee = 0;\\r\\n        }\\r\\n        if(taxSettings.lpTax \\u0026\\u0026 !isBuy) {\\r\\n            if(TaxHelper.lpTokenHasReserves(pairAddress)) {\\r\\n                fee = amount * fees.lpTax / DENOMINATOR;\\r\\n            }\\r\\n            if(fee != 0) {\\r\\n                _transfer(sender, address(TaxHelper), fee);\\r\\n                TaxHelper.initiateLPTokenTax(address(this), address(lpWallet));\\r\\n                emit LPTaxInitiated(sender, fee, address(lpWallet), isBuy);\\r\\n                totalTaxAmount += fee;\\r\\n            }\\r\\n            fee = 0;\\r\\n        }\\r\\n        if(customTaxes.length \\u003e 0) {\\r\\n            for(uint8 i = 0; i \\u003c customTaxes.length; i++) {\\r\\n                uint256 customFee;\\r\\n                if(isBuy) {\\r\\n                    customFee = amount * customTaxes[i].fee.buy / DENOMINATOR;\\r\\n                } else {\\r\\n                    customFee = amount * customTaxes[i].fee.sell / DENOMINATOR;\\r\\n                }\\r\\n                fee += customFee;\\r\\n                if(fee != 0) {\\r\\n                    totalTaxAmount += fee;\\r\\n                    _transfer(sender, customTaxes[i].wallet, fee);\\r\\n                    emit CustomTaxInitiated(sender, fee, customTaxes[i].wallet, isBuy);\\r\\n                    fee = 0;\\r\\n                }\\r\\n            }\\r\\n        }    \\r\\n    }\\r\\n\\r\\n    /// @notice internal transfer method\\r\\n    /// @dev includes checks for all features not handled by handleTaxes()\\r\\n    /// @param sender the one sending the transaction\\r\\n    /// @param recipient the one receiving the transaction\\r\\n    /// @param amount the amount of tokens being sent\\r\\n    function _transfer(address sender, address recipient, uint256 amount) public {\\r\\n        // restrict it to being only called by registered tokens\\r\\n        if(!IMintFactory(factory).tokenGeneratorIsAllowed(msg.sender)) {\\r\\n            require(IMintFactory(factory).tokenIsRegistered(address(this)));\\r\\n        }\\r\\n        require(sender != address(0), \\\"ETFZ\\\");\\r\\n        require(recipient != address(0), \\\"ETTZ\\\");\\r\\n        require(amount \\u003e 0, \\\"TGZ\\\");\\r\\n        require(!paused(), \\\"TP\\\");\\r\\n        require(!isBlacklisted(msg.sender), \\\"SB\\\");\\r\\n        require(!isBlacklisted(recipient), \\\"RB\\\"); \\r\\n        require(!isBlacklisted(tx.origin), \\\"SB\\\");\\r\\n        // Reflection Transfers\\r\\n        if(taxSettings.holderTax) {\\r\\n            if (_isExcluded[sender] \\u0026\\u0026 !_isExcluded[recipient]) {\\r\\n            _transferFromExcluded(sender, recipient, amount);\\r\\n            } else if (!_isExcluded[sender] \\u0026\\u0026 _isExcluded[recipient]) {\\r\\n                _transferToExcluded(sender, recipient, amount);\\r\\n            } else if (!_isExcluded[sender] \\u0026\\u0026 !_isExcluded[recipient]) {\\r\\n                _transferStandard(sender, recipient, amount);\\r\\n            } else if (_isExcluded[sender] \\u0026\\u0026 _isExcluded[recipient]) {\\r\\n                _transferBothExcluded(sender, recipient, amount);\\r\\n            } else {\\r\\n                _transferStandard(sender, recipient, amount);\\r\\n            }\\r\\n        } else {\\r\\n            // Non Reflection Transfer\\r\\n            _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n            uint256 senderBalance = _tOwned[sender];\\r\\n            require(senderBalance \\u003e= amount, \\\"ETA\\\");\\r\\n            _tOwned[sender] = senderBalance - amount;\\r\\n            _tOwned[recipient] += amount;\\r\\n\\r\\n            emit Transfer(sender, recipient, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\r\\n\\r\\n\\r\\n    // Reflection Functions\\r\\n\\r\\n\\r\\n    function reflect(uint256 tAmount) public {\\r\\n        address sender = _msgSender();\\r\\n        require(!_isExcluded[sender], \\\"EA\\\");\\r\\n        (uint256 rAmount,,,,) = _getValues(tAmount);\\r\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\r\\n        _rTotal = _rTotal - rAmount;\\r\\n        _tFeeTotal = _tFeeTotal + tAmount;\\r\\n        emit Reflect(tAmount, rAmount, _rTotal, _tFeeTotal);\\r\\n    }\\r\\n\\r\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\\r\\n        require(tAmount \\u003c= _tTotal, \\\"ALS\\\");\\r\\n        if (!deductTransferFee) {\\r\\n            (uint256 rAmount,,,,) = _getValues(tAmount);\\r\\n            return rAmount;\\r\\n        } else {\\r\\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\\r\\n            return rTransferAmount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256)  {\\r\\n        require(rAmount \\u003c= _rTotal, \\\"ALR\\\");\\r\\n        uint256 currentRate = _getRate();\\r\\n        return rAmount / currentRate;\\r\\n    }\\r\\n\\r\\n    function excludeAccount(address account) external onlyOwner {\\r\\n        require(!_isExcluded[account], \\\"AE\\\");\\r\\n        if(_rOwned[account] \\u003e 0) {\\r\\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\\r\\n        }\\r\\n        _isExcluded[account] = true;\\r\\n        _excluded.push(account);\\r\\n        emit ExcludedAccount(account);\\r\\n    }\\r\\n\\r\\n    function includeAccount(address account) external onlyOwner {\\r\\n        require(_isExcluded[account], \\\"AI\\\");\\r\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\r\\n            if (_excluded[i] == account) {\\r\\n                _excluded[i] = _excluded[_excluded.length - 1];\\r\\n                _tOwned[account] = 0;\\r\\n                _isExcluded[account] = false;\\r\\n                _excluded.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        emit IncludedAccount(account);\\r\\n    }\\r\\n\\r\\n    function isExcluded(address account) external view returns(bool) {\\r\\n        return _isExcluded[account];\\r\\n    }\\r\\n\\r\\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\\r\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\r\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;    \\r\\n        _reflectFee(rFee, tFee);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n\\r\\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\\r\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\r\\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\\r\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;           \\r\\n        _reflectFee(rFee, tFee);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n\\r\\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\\r\\n        _tOwned[sender] = _tOwned[sender] - tAmount;\\r\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\r\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;   \\r\\n        _reflectFee(rFee, tFee);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n\\r\\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\\r\\n        _tOwned[sender] = _tOwned[sender] - tAmount;\\r\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\r\\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\\r\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;        \\r\\n        _reflectFee(rFee, tFee);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n\\r\\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\\r\\n        _rTotal = _rTotal - rFee;\\r\\n        _tFeeTotal = _tFeeTotal + tFee;\\r\\n    }\\r\\n\\r\\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\\r\\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\\r\\n        uint256 currentRate = _getRate();\\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\\r\\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\\r\\n    }\\r\\n\\r\\n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256) {\\r\\n        uint256 tFee = tAmount / fees.holderTax;\\r\\n        uint256 tTransferAmount = tAmount - tFee;\\r\\n        return (tTransferAmount, tFee);\\r\\n    }\\r\\n\\r\\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\\r\\n        uint256 rAmount = tAmount * currentRate;\\r\\n        uint256 rFee = tFee * currentRate;\\r\\n        uint256 rTransferAmount = rAmount - rFee;\\r\\n        return (rAmount, rTransferAmount, rFee);\\r\\n    }\\r\\n\\r\\n    function _getRate() private view returns(uint256) {\\r\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\r\\n        return rSupply / tSupply;\\r\\n    }\\r\\n\\r\\n    function _getCurrentSupply() private view returns(uint256, uint256) {\\r\\n        uint256 rSupply = _rTotal;\\r\\n        uint256 tSupply = _tTotal;      \\r\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\r\\n            if (_rOwned[_excluded[i]] \\u003e rSupply || _tOwned[_excluded[i]] \\u003e tSupply) return (_rTotal, _tTotal);\\r\\n            rSupply = rSupply - _rOwned[_excluded[i]];\\r\\n            tSupply = tSupply - _tOwned[_excluded[i]];\\r\\n        }\\r\\n        if (rSupply \\u003c _rTotal / _tTotal) return (_rTotal, _tTotal);\\r\\n        return (rSupply, tSupply);\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) public {\\r\\n        if (isLosslessOn) {\\r\\n            lossless.beforeBurn(_msgSender(), amount);\\r\\n        } \\r\\n        address taxHelper = IMintFactory(factory).getTaxHelperAddress(taxHelperIndex);\\r\\n        require(msg.sender == taxHelper || msg.sender == owner(), \\\"RA\\\");\\r\\n        _burn(owner(), amount);\\r\\n    }\\r\\n\\r\\n    /// @notice custom burn to handle reflection\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"EBZ\\\");\\r\\n\\r\\n        if (isLosslessOn) {\\r\\n            lossless.beforeBurn(account, amount);\\r\\n        } \\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        if(taxSettings.holderTax \\u0026\\u0026 !_isExcluded[account]) {\\r\\n            (uint256 rAmount,,,,) = _getValues(amount);\\r\\n            _rOwned[account] = _rOwned[account] - rAmount;\\r\\n            _rTotal = _rTotal - rAmount;\\r\\n            _tFeeTotal = _tFeeTotal + amount;\\r\\n        }\\r\\n\\r\\n        uint256 accountBalance = _tOwned[account];\\r\\n        require(accountBalance \\u003e= amount, \\\"EBB\\\");\\r\\n        _tOwned[account] = accountBalance - amount;\\r\\n        _tTotal -= amount;\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n    \\r\\n}\"},\"TaxHelperUniswapV2.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\nimport \\\"./IUniswapV2Factory.sol\\\";\\r\\nimport \\\"./IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./IBuyBackWallet.sol\\\";\\r\\nimport \\\"./ILPWallet.sol\\\";\\r\\nimport \\\"./ITaxToken.sol\\\";\\r\\nimport \\\"./IMintFactory.sol\\\";\\r\\n\\r\\n// add events\\r\\n\\r\\ncontract TaxHelperUniswapV2 is Ownable{\\r\\n    \\r\\n    IUniswapV2Router02 router;\\r\\n    IUniswapV2Factory factory;\\r\\n    IMintFactory mintFactory;\\r\\n\\r\\n    // event Buy\\r\\n    event CreatedLPToken(address token0, address token1, address LPToken);\\r\\n\\r\\n    constructor(address swapV2Router, address swapV2Factory, address _mintFactory) {\\r\\n    router = IUniswapV2Router02(swapV2Router);\\r\\n    factory = IUniswapV2Factory(swapV2Factory);\\r\\n    mintFactory = IMintFactory(_mintFactory);\\r\\n \\r\\n    }\\r\\n\\r\\n    modifier isToken() {\\r\\n        require(mintFactory.tokenIsRegistered(msg.sender), \\\"RA\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function initiateBuyBackTax(address _token, address _wallet) payable external isToken returns(bool) {\\r\\n        ITaxToken token = ITaxToken(_token);\\r\\n        uint256 _amount = token.balanceOf(address(this));\\r\\n        address[] memory addressPaths = new address[](2);\\r\\n        addressPaths[0] = _token;\\r\\n        addressPaths[1] = router.WETH();\\r\\n        token.approve(address(router), _amount);\\r\\n        if(_amount \\u003e 0) {\\r\\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(_amount, 0, addressPaths, _wallet, block.timestamp);\\r\\n        }\\r\\n        IBuyBackWallet buyBackWallet = IBuyBackWallet(_wallet);\\r\\n        bool res = buyBackWallet.checkBuyBackTrigger();\\r\\n        if(res) {\\r\\n            addressPaths[0] = router.WETH();\\r\\n            addressPaths[1] = _token;\\r\\n            uint256 amountEth = buyBackWallet.sendEthToTaxHelper();\\r\\n            uint256 balanceBefore = token.balanceOf(address(this));\\r\\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountEth}(0, addressPaths, address(this), block.timestamp);\\r\\n            // burn baby burn!\\r\\n            uint256 balanceAfter = token.balanceOf(address(this));\\r\\n            uint256 amountToBurn = balanceAfter - balanceBefore;\\r\\n            token.approve(token.owner(), amountToBurn);\\r\\n            token.buyBackBurn(amountToBurn);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function initiateLPTokenTax(address _token, address _wallet) external isToken returns (bool) {\\r\\n        ITaxToken token = ITaxToken(_token);\\r\\n        uint256 _amount = token.balanceOf(address(this));\\r\\n        address[] memory addressPaths = new address[](2);\\r\\n        addressPaths[0] = _token;\\r\\n        addressPaths[1] = router.WETH();\\r\\n        uint256 halfAmount = _amount / 2;\\r\\n        uint256 otherHalf = _amount - halfAmount;\\r\\n        token.transfer(_wallet, otherHalf);\\r\\n        token.approve(address(router), halfAmount);\\r\\n        if(halfAmount \\u003e 0) {\\r\\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(halfAmount, 0, addressPaths, _wallet, block.timestamp);\\r\\n        }\\r\\n        ILPWallet lpWallet = ILPWallet(_wallet);\\r\\n        bool res = lpWallet.checkLPTrigger();\\r\\n        if(res) {\\r\\n            lpWallet.transferBalanceToTaxHelper();\\r\\n            uint256 amountEth = lpWallet.sendEthToTaxHelper();\\r\\n            uint256 tokenBalance = token.balanceOf(address(this));\\r\\n            token.approve(address(router), tokenBalance);\\r\\n            router.addLiquidityETH{value: amountEth}(_token, tokenBalance, 0, 0, token.owner(), block.timestamp + 20 minutes);\\r\\n            uint256 ethDust = address(this).balance;\\r\\n            if(ethDust \\u003e 0) {\\r\\n                (bool sent,) = _wallet.call{value: ethDust}(\\\"\\\");\\r\\n                require(sent, \\\"Failed to send Ether\\\");\\r\\n            }\\r\\n            uint256 tokenDust = token.balanceOf(address(this));\\r\\n            if(tokenDust \\u003e 0) {\\r\\n                token.transfer(_wallet, tokenDust);\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }    \\r\\n    \\r\\n    function createLPToken() external returns(address lpToken) {\\r\\n        lpToken = factory.createPair(msg.sender, router.WETH());\\r\\n        emit CreatedLPToken(msg.sender, router.WETH(), lpToken);\\r\\n    }\\r\\n\\r\\n    function lpTokenHasReserves(address _lpToken) public view returns (bool) {\\r\\n        (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(_lpToken).getReserves();\\r\\n        return reserve0 \\u003e 0 \\u0026\\u0026 reserve1 \\u003e 0;\\r\\n    }\\r\\n\\r\\n    receive() payable external {\\r\\n    }\\r\\n\\r\\n} \"},\"TaxToken.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./ITaxHelper.sol\\\";\\r\\nimport \\\"./IMintFactory.sol\\\";\\r\\nimport \\\"./IBuyBackWallet.sol\\\";\\r\\nimport \\\"./ILPWallet.sol\\\";\\r\\nimport \\\"./ISettings.sol\\\";\\r\\nimport \\\"./IFacetHelper.sol\\\";\\r\\nimport \\\"./IFeeHelper.sol\\\";\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./FullMath.sol\\\";\\r\\n\\r\\nimport \\\"./BuyBackWallet.sol\\\";\\r\\nimport \\\"./LPWallet.sol\\\";\\r\\n\\r\\nimport \\\"./Storage.sol\\\";\\r\\n\\r\\ncontract TaxToken is Storage, Ownable{\\r\\n    \\r\\n\\r\\n    struct ConstructorParams {\\r\\n        string name_; \\r\\n        string symbol_; \\r\\n        uint8 decimals_; \\r\\n        address creator_;\\r\\n        uint256 tTotal_;\\r\\n        uint256 _maxTax;\\r\\n        TaxSettings _settings;\\r\\n        TaxSettings _lockedSettings;\\r\\n        Fees _fees;\\r\\n        address _transactionTaxWallet;\\r\\n        CustomTax[] _customTaxes;\\r\\n        uint256 lpWalletThreshold;\\r\\n        uint256 buyBackWalletThreshold;\\r\\n        uint256 _taxHelperIndex;\\r\\n        address admin_;\\r\\n        address recoveryAdmin_;\\r\\n        bool isLossless_;\\r\\n        AntiBotSettings _antiBotSettings;\\r\\n        uint256 _maxBalanceAfterBuy;\\r\\n        SwapWhitelistingSettings _swapWhitelistingSettings;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        ConstructorParams memory params,\\r\\n        address _factory\\r\\n        ) {\\r\\n        address constructorFacetAddress = IFacetHelper(IMintFactory(_factory).getFacetHelper()).getConstructorFacet();\\r\\n        (bool success, bytes memory result) = constructorFacetAddress.delegatecall(abi.encodeWithSignature(\\\"constructorHandler((string,string,uint8,address,uint256,uint256,(bool,bool,bool,bool,bool,bool,bool,bool),(bool,bool,bool,bool,bool,bool,bool,bool),((uint256,uint256),uint256,uint256,uint256),address,(string,(uint256,uint256),address)[],uint256,uint256,uint256,address,address,bool,(uint256,uint256,uint256,uint256,bool),uint256,(uint256,bool)),address)\\\", params, _factory));\\r\\n        if (!success) {\\r\\n            if (result.length \\u003c 68) revert();\\r\\n            revert(abi.decode(result, (string)));\\r\\n        }\\r\\n        IFeeHelper feeHelper = IFeeHelper(IMintFactory(factory).getFeeHelper());\\r\\n        uint256 fee = FullMath.mulDiv(params.tTotal_, feeHelper.getFee(), feeHelper.getFeeDenominator());\\r\\n        address feeAddress = feeHelper.getFeeAddress();\\r\\n        _approve(params.creator_, msg.sender, fee);\\r\\n        isTaxed = true;\\r\\n        transferFrom(params.creator_, feeAddress, fee);\\r\\n    }\\r\\n\\r\\n    /// @notice this is the power behind Lossless\\r\\n    function transferOutBlacklistedFunds(address[] calldata from) external {\\r\\n        require(isLosslessOn); // added by us for extra protection\\r\\n        require(_msgSender() == address(lossless), \\\"LOL\\\");\\r\\n        for (uint i = 0; i \\u003c from.length; i++) {\\r\\n            _transfer(from[i], address(lossless), balanceOf(from[i]));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Checks whether an address is blacklisted\\r\\n    /// @param _address the address to check\\r\\n    /// @return bool is blacklisted or not\\r\\n    function isBlacklisted(address _address) public view returns (bool) {\\r\\n        return blacklist[_address];\\r\\n    }\\r\\n\\r\\n    /// @notice Checks whether the contract has paused transactions\\r\\n    /// @return bool is paused or not\\r\\n    function paused() public view returns (bool) {\\r\\n        if(taxSettings.canPause == false) {\\r\\n            return false;\\r\\n        }\\r\\n        return isPaused;\\r\\n    }\\r\\n\\r\\n    /// @notice Handles the burning of token during the buyback tax process\\r\\n    /// @dev must first receive the amount to be burned from the taxHelper contract (see initial transfer in function)\\r\\n    /// @param _amount the amount to burn\\r\\n    function buyBackBurn(uint256 _amount) external {\\r\\n        address taxHelper = IMintFactory(factory).getTaxHelperAddress(taxHelperIndex);\\r\\n        require(msg.sender == taxHelper, \\\"RA\\\");\\r\\n        _transfer(taxHelper, owner(), _amount);\\r\\n\\r\\n        _beforeTokenTransfer(owner(), address(0), _amount);\\r\\n\\r\\n        address taxFacetAddress = IFacetHelper(IMintFactory(factory).getFacetHelper()).getTaxFacet();\\r\\n        (bool success, bytes memory result) = taxFacetAddress.delegatecall(abi.encodeWithSignature(\\\"burn(uint256)\\\", _amount));\\r\\n        if (!success) {\\r\\n            if (result.length \\u003c 68) revert();\\r\\n            revert(abi.decode(result, (string)));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Handles the taxes for the token.\\r\\n    /// @dev handles every tax within the tax facet. \\r\\n    /// @param sender the one sending the transaction\\r\\n    /// @param recipient the one receiving the transaction\\r\\n    /// @param amount the amount of tokens being sent\\r\\n    /// @return totalTaxAmount the total amount of the token taxed\\r\\n    function handleTaxes(address sender, address recipient, uint256 amount) internal virtual returns (uint256 totalTaxAmount) {\\r\\n        address taxFacetAddress = IFacetHelper(IMintFactory(factory).getFacetHelper()).getTaxFacet();\\r\\n        (bool success, bytes memory result) = taxFacetAddress.delegatecall(abi.encodeWithSignature(\\\"handleTaxes(address,address,uint256)\\\", sender, recipient, amount));\\r\\n        if (!success) {\\r\\n            if (result.length \\u003c 68) revert();\\r\\n            revert(abi.decode(result, (string)));\\r\\n        }\\r\\n        return abi.decode(result, (uint256));\\r\\n\\r\\n    }\\r\\n\\r\\n    // ERC20 Functions\\r\\n\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _tTotal;\\r\\n    }\\r\\n\\r\\n    /// @dev modified to handle if the token has reflection active in it settings\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        if(taxSettings.holderTax) {\\r\\n            if (_isExcluded[account]) return _tOwned[account];\\r\\n            return tokenFromReflection(_rOwned[account]); \\r\\n        }\\r\\n        return _tOwned[account];\\r\\n    }\\r\\n\\r\\n    // Reflection Functions \\r\\n    // necessary to get reflection balance\\r\\n\\r\\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\\r\\n        require(rAmount \\u003c= _rTotal, \\\"ALR\\\");\\r\\n        uint256 currentRate =  _getRate();\\r\\n        return rAmount / currentRate;\\r\\n    }\\r\\n\\r\\n    function _getRate() public view returns(uint256) {\\r\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\r\\n        return rSupply / tSupply;\\r\\n    }\\r\\n\\r\\n    function _getCurrentSupply() public view returns(uint256, uint256) {\\r\\n        uint256 rSupply = _rTotal;\\r\\n        uint256 tSupply = _tTotal;      \\r\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\r\\n            if (_rOwned[_excluded[i]] \\u003e rSupply || _tOwned[_excluded[i]] \\u003e tSupply) return (_rTotal, _tTotal);\\r\\n            rSupply = rSupply - _rOwned[_excluded[i]];\\r\\n            tSupply = tSupply - _tOwned[_excluded[i]];\\r\\n        }\\r\\n        if (rSupply \\u003c _rTotal / _tTotal) return (_rTotal, _tTotal);\\r\\n        return (rSupply, tSupply);\\r\\n    }\\r\\n\\r\\n\\r\\n    // ERC20 Functions continued \\r\\n    /// @dev modified slightly to add taxes\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\r\\n        if(!isTaxed) {\\r\\n            isTaxed = true;\\r\\n            uint256 totalTaxAmount = handleTaxes(_msgSender(), recipient, amount);\\r\\n            amount -= totalTaxAmount;\\r\\n        }\\r\\n        if (isLosslessOn) {\\r\\n            lossless.beforeTransfer(_msgSender(), recipient, amount);\\r\\n        } \\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        isTaxed = false;\\r\\n        if (isLosslessOn) {\\r\\n            lossless.afterTransfer(_msgSender(), recipient, amount);\\r\\n        } \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address _owner, address spender) public view returns (uint256) {\\r\\n        return _allowances[_owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public returns (bool) {\\r\\n        if (isLosslessOn) {\\r\\n            lossless.beforeApprove(_msgSender(), spender, amount);\\r\\n        }\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\r\\n        if(!isTaxed) {\\r\\n            isTaxed = true;\\r\\n            uint256 totalTaxAmount = handleTaxes(sender, recipient, amount);\\r\\n            amount -= totalTaxAmount;\\r\\n        }\\r\\n        if (isLosslessOn) {\\r\\n            lossless.beforeTransferFrom(_msgSender(), sender, recipient, amount);\\r\\n        }\\r\\n        _transfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\r\\n        require(currentAllowance \\u003e= amount, \\\"ETA\\\");\\r\\n\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\\r\\n\\r\\n        isTaxed = false;\\r\\n        if (isLosslessOn) {\\r\\n            lossless.afterTransfer(_msgSender(), recipient, amount);\\r\\n        } \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        if (isLosslessOn) {\\r\\n            lossless.beforeIncreaseAllowance(_msgSender(), spender, addedValue);\\r\\n        }\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n         if (isLosslessOn) {\\r\\n            lossless.beforeDecreaseAllowance(_msgSender(), spender, subtractedValue);\\r\\n        }\\r\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\r\\n        require(currentAllowance \\u003e= subtractedValue, \\\"EABZ\\\");\\r\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(address _owner, address spender, uint256 amount) private {\\r\\n        require(_owner != address(0), \\\"EAFZ\\\");\\r\\n        require(spender != address(0), \\\"EATZ\\\");\\r\\n        if (isLosslessOn) {\\r\\n            lossless.beforeApprove(_owner, spender, amount);\\r\\n        } \\r\\n\\r\\n        _allowances[_owner][spender] = amount;\\r\\n        emit Approval(_owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function _transfer(address sender, address recipient, uint256 amount) private {\\r\\n        // AntiBot Checks\\r\\n        address antiBotFacetAddress = IFacetHelper(IMintFactory(factory).getFacetHelper()).getAntiBotFacet();\\r\\n        if(marketInit \\u0026\\u0026 antiBotSettings.isActive \\u0026\\u0026 lpTokens[sender]) {\\r\\n            (bool success, bytes memory result) = antiBotFacetAddress.delegatecall(abi.encodeWithSignature(\\\"antiBotCheck(uint256,address)\\\", amount, recipient));\\r\\n            if (!success) {\\r\\n                if (result.length \\u003c 68) revert();\\r\\n                revert(abi.decode(result, (string)));\\r\\n            }\\r\\n        } \\r\\n        if(taxSettings.maxBalanceAfterBuy \\u0026\\u0026 lpTokens[sender]) {\\r\\n            (bool success2, bytes memory result2) = antiBotFacetAddress.delegatecall(abi.encodeWithSignature(\\\"maxBalanceAfterBuyCheck(uint256,address)\\\", amount, recipient));\\r\\n            if (!success2) {\\r\\n                if (result2.length \\u003c 68) revert();\\r\\n                revert(abi.decode(result2, (string)));\\r\\n            }\\r\\n        } \\r\\n        if(marketInit \\u0026\\u0026 swapWhitelistingSettings.isActive \\u0026\\u0026 lpTokens[sender]) {\\r\\n            (bool success3, bytes memory result3) = antiBotFacetAddress.delegatecall(abi.encodeWithSignature(\\\"swapWhitelistingCheck(address)\\\", recipient));\\r\\n            if (!success3) {\\r\\n                if (result3.length \\u003c 68) revert();\\r\\n                revert(abi.decode(result3, (string)));\\r\\n            }\\r\\n        } \\r\\n        address taxFacetAddress = IFacetHelper(IMintFactory(factory).getFacetHelper()).getTaxFacet();\\r\\n        (bool success4, bytes memory result4) = taxFacetAddress.delegatecall(abi.encodeWithSignature(\\\"_transfer(address,address,uint256)\\\", sender, recipient, amount));\\r\\n        if (!success4) {\\r\\n            if (result4.length \\u003c 68) revert();\\r\\n            revert(abi.decode(result4, (string)));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\r\\n\\r\\n    function mint(uint256 amount) public onlyOwner {\\r\\n        if (isLosslessOn) {\\r\\n            lossless.beforeMint(_msgSender(), amount);\\r\\n        } \\r\\n        _mint(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice custom mint to handle fees\\r\\n    function _mint(address account, uint256 amount) internal virtual onlyOwner {\\r\\n        require(account != address(0), \\\"EMZ\\\");\\r\\n        require(taxSettings.canMint, \\\"NM\\\");\\r\\n        require(!taxSettings.holderTax, \\\"NM\\\");\\r\\n        if (isLosslessOn) {\\r\\n            lossless.beforeMint(account, amount);\\r\\n        } \\r\\n\\r\\n        IFeeHelper feeHelper = IFeeHelper(IMintFactory(factory).getFeeHelper());\\r\\n        uint256 fee = FullMath.mulDiv(amount, feeHelper.getFee(), feeHelper.getFeeDenominator());\\r\\n        address feeAddress = feeHelper.getFeeAddress();\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n        _tTotal += amount;\\r\\n        _tOwned[feeAddress] += fee;\\r\\n        _tOwned[account] += amount - fee;\\r\\n\\r\\n        emit Transfer(address(0), feeAddress, fee);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) public {\\r\\n        address taxFacetAddress = IFacetHelper(IMintFactory(factory).getFacetHelper()).getTaxFacet();\\r\\n        (bool success, bytes memory result) = taxFacetAddress.delegatecall(abi.encodeWithSignature(\\\"burn(uint256)\\\", amount));\\r\\n        if (!success) {\\r\\n            if (result.length \\u003c 68) revert();\\r\\n            revert(abi.decode(result, (string)));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Handles all facet logic\\r\\n    /// @dev Implements a customized version of the EIP-2535 Diamond Standard to add extra functionality to the contract\\r\\n    /// https://github.com/mudgen/diamond-3 \\r\\n    fallback() external {\\r\\n        address facetHelper = IMintFactory(factory).getFacetHelper(); \\r\\n        address facet = IFacetHelper(facetHelper).getFacetAddressFromSelector(msg.sig);\\r\\n        require(facet != address(0), \\\"Function does not exist\\\");\\r\\n        assembly {\\r\\n            let ptr := mload(0x40)\\r\\n            calldatacopy(ptr, 0, calldatasize())\\r\\n    \\r\\n            let result := delegatecall(\\r\\n                gas(),\\r\\n                facet,\\r\\n                ptr,\\r\\n                calldatasize(),\\r\\n                0,\\r\\n                0\\r\\n            )\\r\\n\\r\\n            let size := returndatasize()\\r\\n            returndatacopy(ptr, 0, size)\\r\\n\\r\\n            switch result\\r\\n            case 0 {\\r\\n                revert(ptr, size)\\r\\n            }\\r\\n            default {\\r\\n                return(ptr, size)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n  \\r\\n}\"},\"TokenFees.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ninterface ITokenFees {\\r\\n    function getTokenFee() view external returns(uint256);\\r\\n    \\r\\n    function setTokenFee(uint _tokenFee) external;\\r\\n    \\r\\n    function getTokenFeeAddress() view external returns(address);\\r\\n    \\r\\n    function setTokenFeeAddress(address payable _tokenFeeAddress) external;\\r\\n}\\r\\n\\r\\ncontract TokenFees is Ownable{\\r\\n    \\r\\n    struct Settings {\\r\\n        uint256 TOKEN_FEE; \\r\\n        uint256 DENOMINATOR;\\r\\n        address payable TOKEN_FEE_ADDRESS;\\r\\n    }\\r\\n    \\r\\n    Settings public SETTINGS;\\r\\n    \\r\\n    constructor() {\\r\\n        SETTINGS.TOKEN_FEE = 1;\\r\\n        SETTINGS.DENOMINATOR = 10000;\\r\\n        SETTINGS.TOKEN_FEE_ADDRESS = payable(msg.sender);\\r\\n    }\\r\\n    \\r\\n    function getTokenFee() view external returns(uint256) {\\r\\n        return SETTINGS.TOKEN_FEE;\\r\\n    }\\r\\n    \\r\\n    function setTokenFee(uint _tokenFee) external onlyOwner {\\r\\n        SETTINGS.TOKEN_FEE = _tokenFee;\\r\\n    }\\r\\n    \\r\\n    function getTokenFeeAddress() view external returns(address) {\\r\\n        return SETTINGS.TOKEN_FEE_ADDRESS;\\r\\n    }\\r\\n    \\r\\n    function setTokenFeeAddress(address payable _tokenFeeAddress) external onlyOwner {\\r\\n        SETTINGS.TOKEN_FEE_ADDRESS = _tokenFeeAddress;\\r\\n    }\\r\\n} \"},\"Wallets.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n// ALL RIGHTS RESERVED\\r\\n\\r\\n// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./Storage.sol\\\";\\r\\nimport \\\"./BuyBackWallet.sol\\\";\\r\\nimport \\\"./LPWallet.sol\\\";\\r\\n\\r\\n\\r\\nimport \\\"./IBuyBackWallet.sol\\\";\\r\\nimport \\\"./ILPWallet.sol\\\";\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\ncontract WalletsFacet is Storage, Ownable {\\r\\n\\r\\n\\r\\n    function createBuyBackWallet(address _factory, address _token, uint256 _newThreshold) external returns (address) {\\r\\n        BuyBackWallet newBuyBackWallet = new BuyBackWallet(_factory, _token,_newThreshold);\\r\\n        emit CreatedBuyBackWallet(address(newBuyBackWallet));\\r\\n        return address(newBuyBackWallet);\\r\\n    }\\r\\n\\r\\n    function createLPWallet(address _factory, address _token, uint256 _newThreshold) external returns (address) {\\r\\n        LPWallet newLPWallet = new LPWallet(_factory, _token, _newThreshold);\\r\\n        emit CreatedLPWallet(address(newLPWallet));\\r\\n        return address(newLPWallet);\\r\\n    }\\r\\n\\r\\n    function updateBuyBackWalletThreshold(uint256 _newThreshold) public onlyOwner {\\r\\n        IBuyBackWallet(buyBackWallet).updateThreshold(_newThreshold);\\r\\n        emit UpdatedBuyBackWalletThreshold(_newThreshold);\\r\\n    }\\r\\n\\r\\n    function updateLPWalletThreshold(uint256 _newThreshold) public onlyOwner {\\r\\n        ILPWallet(lpWallet).updateThreshold(_newThreshold);\\r\\n        emit UpdatedLPWalletThreshold(_newThreshold);\\r\\n    }\\r\\n\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SETTINGS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"GENERATOR_FEE\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"FEE\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DENOMINATOR\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"FEE_ADDRESS\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGeneratorFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeAddress\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setGeneratorFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FeeHelper", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5bafb0be298a086a3c6e45a846e4007fd7f9963f8fe5873e87c9cad3f52e30e3"}