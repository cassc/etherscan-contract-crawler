{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/matrixx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/utils/StorageSlotUpgradeable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Library for reading and writing primitive types to specific storage slots.\\r\\n *\\r\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\r\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\r\\n *\\r\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\r\\n *\\r\\n * Example usage to set ERC1967 implementation slot:\\r\\n * ```\\r\\n * contract ERC1967 {\\r\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n *\\r\\n *     function _getImplementation() internal view returns (address) {\\r\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\r\\n *     }\\r\\n *\\r\\n *     function _setImplementation(address newImplementation) internal {\\r\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\r\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\r\\n *     }\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\r\\n */\\r\\nlibrary StorageSlotUpgradeable {\\r\\n    struct AddressSlot {\\r\\n        address value;\\r\\n    }\\r\\n\\r\\n    struct BooleanSlot {\\r\\n        bool value;\\r\\n    }\\r\\n\\r\\n    struct Bytes32Slot {\\r\\n        bytes32 value;\\r\\n    }\\r\\n\\r\\n    struct Uint256Slot {\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/proxy/beacon/IBeaconUpgradeable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\r\\n */\\r\\ninterface IBeaconUpgradeable {\\r\\n    /**\\r\\n     * @dev Must return an address that can be used as a delegate call target.\\r\\n     *\\r\\n     * {BeaconProxy} will check that this address is a contract.\\r\\n     */\\r\\n    function implementation() external view returns (address);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/interfaces/draft-IERC1822Upgradeable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\r\\n * proxy whose upgrades are fully controlled by the current implementation.\\r\\n */\\r\\ninterface IERC1822ProxiableUpgradeable {\\r\\n    /**\\r\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\r\\n     * address.\\r\\n     *\\r\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\r\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\r\\n     * function revert if invoked through a proxy.\\r\\n     */\\r\\n    function proxiableUUID() external view returns (bytes32);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/utils/AddressUpgradeable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary AddressUpgradeable {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/proxy/utils/Initializable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\r\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\r\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\r\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\r\\n *\\r\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\r\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\r\\n *\\r\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\r\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\r\\n *\\r\\n * [CAUTION]\\r\\n * ====\\r\\n * Avoid leaving a contract uninitialized.\\r\\n *\\r\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\r\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\r\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\r\\n *\\r\\n * [.hljs-theme-light.nopadding]\\r\\n * ```\\r\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n * constructor() initializer {}\\r\\n * ```\\r\\n * ====\\r\\n */\\r\\nabstract contract Initializable {\\r\\n    /**\\r\\n     * @dev Indicates that the contract has been initialized.\\r\\n     */\\r\\n    bool private _initialized;\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates that the contract is in the process of being initialized.\\r\\n     */\\r\\n    bool private _initializing;\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\r\\n     */\\r\\n    modifier initializer() {\\r\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\r\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\r\\n        // contract may have been reentered.\\r\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\r\\n\\r\\n        bool isTopLevelCall = !_initializing;\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = true;\\r\\n            _initialized = true;\\r\\n        }\\r\\n\\r\\n        _;\\r\\n\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\r\\n     * {initializer} modifier, directly or indirectly.\\r\\n     */\\r\\n    modifier onlyInitializing() {\\r\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _isConstructor() private view returns (bool) {\\r\\n        return !AddressUpgradeable.isContract(address(this));\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\r\\n\\r\\npragma solidity ^0.8.2;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev This abstract contract provides getters and event emitting update functions for\\r\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n *\\r\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\r\\n */\\r\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\r\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\r\\n    }\\r\\n\\r\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\r\\n    }\\r\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\r\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\r\\n\\r\\n    /**\\r\\n     * @dev Storage slot with the address of the current implementation.\\r\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\r\\n     * validated in the constructor.\\r\\n     */\\r\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the implementation is upgraded.\\r\\n     */\\r\\n    event Upgraded(address indexed implementation);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current implementation address.\\r\\n     */\\r\\n    function _getImplementation() internal view returns (address) {\\r\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\r\\n     */\\r\\n    function _setImplementation(address newImplementation) private {\\r\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\r\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Perform implementation upgrade\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function _upgradeTo(address newImplementation) internal {\\r\\n        _setImplementation(newImplementation);\\r\\n        emit Upgraded(newImplementation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Perform implementation upgrade with additional setup call.\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function _upgradeToAndCall(\\r\\n        address newImplementation,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        _upgradeTo(newImplementation);\\r\\n        if (data.length > 0 || forceCall) {\\r\\n            _functionDelegateCall(newImplementation, data);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function _upgradeToAndCallUUPS(\\r\\n        address newImplementation,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\r\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\r\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\r\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\r\\n            _setImplementation(newImplementation);\\r\\n        } else {\\r\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\r\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\r\\n            } catch {\\r\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\r\\n            }\\r\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Storage slot with the admin of the contract.\\r\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\r\\n     * validated in the constructor.\\r\\n     */\\r\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the admin account has changed.\\r\\n     */\\r\\n    event AdminChanged(address previousAdmin, address newAdmin);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current admin.\\r\\n     */\\r\\n    function _getAdmin() internal view returns (address) {\\r\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Stores a new address in the EIP1967 admin slot.\\r\\n     */\\r\\n    function _setAdmin(address newAdmin) private {\\r\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\r\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Changes the admin of the proxy.\\r\\n     *\\r\\n     * Emits an {AdminChanged} event.\\r\\n     */\\r\\n    function _changeAdmin(address newAdmin) internal {\\r\\n        emit AdminChanged(_getAdmin(), newAdmin);\\r\\n        _setAdmin(newAdmin);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\r\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\r\\n     */\\r\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the beacon is upgraded.\\r\\n     */\\r\\n    event BeaconUpgraded(address indexed beacon);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current beacon.\\r\\n     */\\r\\n    function _getBeacon() internal view returns (address) {\\r\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\r\\n     */\\r\\n    function _setBeacon(address newBeacon) private {\\r\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\r\\n        require(\\r\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\r\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\r\\n        );\\r\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\r\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\r\\n     *\\r\\n     * Emits a {BeaconUpgraded} event.\\r\\n     */\\r\\n    function _upgradeBeaconToAndCall(\\r\\n        address newBeacon,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        _setBeacon(newBeacon);\\r\\n        emit BeaconUpgraded(newBeacon);\\r\\n        if (data.length > 0 || forceCall) {\\r\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\r\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/proxy/utils/UUPSUpgradeable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\r\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\r\\n *\\r\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\r\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\r\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\r\\n *\\r\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\r\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\r\\n    }\\r\\n\\r\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\r\\n    }\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\r\\n    address private immutable __self = address(this);\\r\\n\\r\\n    /**\\r\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\r\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\r\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\r\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\r\\n     * fail.\\r\\n     */\\r\\n    modifier onlyProxy() {\\r\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\r\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\r\\n     * callable on the implementing contract but not through proxies.\\r\\n     */\\r\\n    modifier notDelegated() {\\r\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\r\\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\\r\\n     *\\r\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\r\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\r\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\r\\n     */\\r\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\r\\n        return _IMPLEMENTATION_SLOT;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\r\\n     *\\r\\n     * Calls {_authorizeUpgrade}.\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\r\\n        _authorizeUpgrade(newImplementation);\\r\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\r\\n     * encoded in `data`.\\r\\n     *\\r\\n     * Calls {_authorizeUpgrade}.\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\r\\n        _authorizeUpgrade(newImplementation);\\r\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\r\\n     * {upgradeTo} and {upgradeToAndCall}.\\r\\n     *\\r\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\r\\n     *\\r\\n     * ```solidity\\r\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\r\\n     * ```\\r\\n     */\\r\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\r\\n\\r\\n    /**\\r\\n     * This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/utils/ContextUpgradeable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract ContextUpgradeable is Initializable {\\r\\n    function __Context_init() internal onlyInitializing {\\r\\n    }\\r\\n\\r\\n    function __Context_init_unchained() internal onlyInitializing {\\r\\n    }\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/access/OwnableUpgradeable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    function __Ownable_init() internal onlyInitializing {\\r\\n        __Ownable_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __Ownable_init_unchained() internal onlyInitializing {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[49] private __gap;\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/token/ERC20/IERC20Upgradeable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20Upgradeable {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\n// File: @openzeppelin/contracts-upgradeable@4.5.0/token/ERC20/ERC20Upgradeable.sol\\r\\n\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\r\\n * instead returning `false` on failure. This behavior is nonetheless\\r\\n * conventional and does not conflict with the expectations of ERC20\\r\\n * applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn't required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The default value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\r\\n        __ERC20_init_unchained(name_, symbol_);\\r\\n    }\\r\\n\\r\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overridden;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\r\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * NOTE: Does not update the allowance if the current allowance\\r\\n     * is the maximum `uint256`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` and `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``from``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = _allowances[owner][spender];\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\r\\n     *\\r\\n     * This internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n        }\\r\\n        _balances[to] += amount;\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[account] = accountBalance - amount;\\r\\n        }\\r\\n        _totalSupply -= amount;\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n\\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\r\\n     *\\r\\n     * Does not update the allowance amount in case of infinite allowance.\\r\\n     * Revert if not enough allowance is available.\\r\\n     *\\r\\n     * Might emit an {Approval} event.\\r\\n     */\\r\\n    function _spendAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * has been transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[45] private __gap;\\r\\n}\\r\\n\\r\\n// File: swap.sol\\r\\n\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\ninterface IERC20 {\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function decimals() external view returns(uint256);\\r\\n}\\r\\n\\r\\ncontract MatrixBoxes is Initializable, OwnableUpgradeable, UUPSUpgradeable {\\r\\n    struct globalUser {\\r\\n        uint256 boxLevel;\\r\\n        address directReferrer;\\r\\n        address[] directReferrals;\\r\\n        uint256 bankBonusIncome;\\r\\n        uint256 personalSalesDirectBonusIncome;\\r\\n        bool isTurboUser;\\r\\n        uint256 investedIntoMBTPool;\\r\\n        uint256 nextWithdrawalTimestamp;\\r\\n        uint256 tradingIncome;\\r\\n    }\\r\\n\\r\\n    struct localUser {\\r\\n        address localReferrer;\\r\\n        address[] localReferrals;\\r\\n        uint256 matrixDepth;\\r\\n        uint256 turboBonusIncome;\\r\\n        uint256 matrixBonusIncome;\\r\\n        uint256 matrixIncomeDirectBonusIncome;\\r\\n    }\\r\\n    mapping(address => globalUser) public globalUsers;\\r\\n    mapping(address => mapping(uint256 => localUser)) public localUsers;\\r\\n    mapping(uint256 => uint256) public boxesBoughtAmount;\\r\\n    address [] public bankUsers;\\r\\n\\r\\n\\r\\n    uint256[10] public REQUIRED_REFERRALS;\\r\\n\\r\\n    uint256[10] public REQUIRED_PURCHASES;\\r\\n\\r\\n    uint256 public  bankBonusRequiredSales;\\r\\n    uint256 public  matrixCrowdStartDate;\\r\\n\\r\\n    uint256[] public BOX_PRICES;\\r\\n    uint256 public constant BOX_LEVELS = 10;\\r\\n\\r\\n    uint256 public constant MAX_PARTNERS = 3;\\r\\n\\r\\n    uint256 public  nextTuesday;\\r\\n\\r\\n    uint256 public constant DIVIDER  = 1000;\\r\\n    uint256 public constant BANK_BONUS_POOL_RATIO = 10;\\r\\n    uint256 public constant TURBO_BONUS_RATIO = 10;\\r\\n    uint256 public constant PERSONAL_SALES_DIRECT_BONUS_RATIO = 50;\\r\\n    uint256 public constant MATRIX_INCOME_DIRECT_BONUS_RATIO = 100;\\r\\n    uint256 public constant MBT_POOL_RATIO = 50;\\r\\n\\r\\n    uint256 public fundPool;\\r\\n\\r\\n    address public crowdWallet;\\r\\n    address public fundWallet ;\\r\\n    address public mbtTokenWallet;\\r\\n    address public companyWallet;\\r\\n    address public personalWallet1;\\r\\n    address public personalWallet2;\\r\\n    address public personalWallet3;\\r\\n    address public bankBonusPoolWallet;\\r\\n    address public profitFromTradingAddress;\\r\\n    IERC20  public token;\\r\\n\\r\\n    uint256 public _decimals;\\r\\n\\r\\n\\r\\n    uint256 public profitFromTradingAmount;\\r\\n\\r\\n    uint256 public constant COMPANY_WALLET_RATIO = 10;\\r\\n    uint256 public constant PERSONAL_WALLET_1_RATIO = 10;\\r\\n\\r\\n\\r\\n    // reward ration from trading\\r\\n    uint256 public constant commissionRation = 150;//15%\\r\\n    uint256 public constant startupFundRation = 100; //10%\\r\\n    uint256 public constant rewardsRation = 150; //15%\\r\\n    uint256 public constant clientsRation = 600; //60%\\r\\n\\r\\n\\r\\n    uint256[] public REWARDS_PERCENTAGES_BOX_1_7; // 4%, 4%, 3%, 3%, 3%, 3%, 3%, 3%, 4%, 4%\\r\\n    uint256[] public REWARDS_PERCENTAGES_BOX_8_10; // 2%, 2%, 1.5%, 1.5%, 1.5%, 1.5%, 1.5%, 1.5%, 2%, 2%\\r\\n\\r\\n    uint256 public constant CROWD_RATIO_LEVEL_1_7 = 50; // 50%\\r\\n    uint256 public constant FUND_RATIO_LEVEL_1_7 = 50; // 50%\\r\\n\\r\\n    uint256 public constant CROWD_RATIO_LEVEL_8_10 = 70; // 70%\\r\\n    uint256 public constant FUND_RATIO_LEVEL_8_10 = 30; // 30%\\r\\n\\r\\n\\r\\n\\r\\n    event UserRegistered(address indexed user, address indexed directReferrer);\\r\\n    event BankUserAdded(address indexed user);\\r\\n    event TurboUserAdded(address indexed user);\\r\\n    event UpgradedBox(address indexed user, address indexed localReferrer, address indexed directReferrer, uint256 boxLevel, uint256 timestamp);\\r\\n\\r\\n    event ReceivedMatrixBonus(address indexed initUser, address indexed referrerBeneficiary, uint256 boxLevel, uint256 bonusAmount, uint256 timestamp);\\r\\n    event ReceivedDirectMatrixBonus(address indexed initUser, address indexed localReferrer, address indexed directReferrerBeneficiary, uint256 boxLevel, uint256 bonusAmount, uint256 timestamp);\\r\\n    event ReceivedDirectBoxSalesBonus(address indexed initUser, address indexed directReferrerBeneficiary, uint256 boxLevel, uint256 bonusAmount, uint256 timestamp);\\r\\n    event ReceivedBankBonus(address indexed bankUserBeneficiary, uint256 boxLevel, uint256 bonusAmount, uint256 timestamp);\\r\\n    event ReceivedTurboBonus(address indexed initUser, address indexed torboUserBeneficiary, uint256 boxLevel, uint256 bonusAmount, uint256 timestamp);\\r\\n\\r\\n    event SentToFundWallet(address indexed initUser, address indexed fundWallet, uint256 boxLevel, uint256 amount, uint256 timestamp);\\r\\n    event GotRewardFromTrading(address indexed initUserBeneficiary, uint256 rewardAmount, uint256 nextWithdrawalTime, uint256 timestamp);\\r\\n    event DistributedTradingIncome(address indexed initUser, uint256 allProfit, uint256 nextTuesday, uint256 timestamp);\\r\\n\\r\\n    event SentToCrowdWallet(address indexed initUser, address indexed crowdWallet, uint256 boxLevel, uint256 amount, uint256 timestamp);\\r\\n    event SpentOnAwards(address indexed initUser, uint256 boxLevel, uint256 crowdAmount, uint256 spentOnAwards);\\r\\n\\r\\n    function initialize(\\r\\n    ) public initializer {\\r\\n        __Ownable_init();\\r\\n        __UUPSUpgradeable_init();\\r\\n    }\\r\\n//Data_transfer___________________________________________________________________________\\r\\n    function setGlobalUsers(\\r\\n        address  _wallet, uint _boxLevel, address  _directReferrer,\\r\\n        address[] memory _directReferrals, uint _bankBonusIncome, uint _personalSalesDirectBonusIncome,\\r\\n        bool _isTurboUser, uint _investedIntoMBTPool, uint _nextWithdrawalTimestamp, uint _tradingIncome) \\r\\n    external onlyOwner{    \\r\\n                globalUsers[_wallet] = globalUser(\\r\\n                _boxLevel,\\r\\n                _directReferrer,\\r\\n                _directReferrals,\\r\\n                _bankBonusIncome,\\r\\n                _personalSalesDirectBonusIncome,\\r\\n                _isTurboUser,\\r\\n                _investedIntoMBTPool,\\r\\n                _nextWithdrawalTimestamp,\\r\\n                _tradingIncome\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function setLocalUser(\\r\\n        address _wallet, uint  _boxLevel, address  _localReferrer,\\r\\n        address[] memory _localReferrals, uint _matrixDepth, uint _turboBonusIncome,\\r\\n        uint _matrixBonusIncome, uint _matrixIncomeDirectBonusIncome)\\r\\n    external onlyOwner{\\r\\n         localUsers[_wallet][_boxLevel] = localUser(\\r\\n                _localReferrer,\\r\\n                _localReferrals,\\r\\n                _matrixDepth,\\r\\n                _turboBonusIncome,\\r\\n                _matrixBonusIncome,\\r\\n                _matrixIncomeDirectBonusIncome\\r\\n         );\\r\\n    }\\r\\n\\r\\n    function giveBox(address _wallet, uint _boxLevel) public onlyOwner {\\r\\n        globalUsers[_wallet].boxLevel = _boxLevel;\\r\\n        address freeReferrer = findFreeReferrer(getDirectReferrer(_wallet), _boxLevel);\\r\\n        localUsers[freeReferrer][_boxLevel].localReferrals.push(_wallet);\\r\\n        localUsers[_wallet][_boxLevel].localReferrer = freeReferrer;\\r\\n\\r\\n        localUsers[_wallet][_boxLevel].matrixDepth = localUsers[freeReferrer][_boxLevel].matrixDepth +1;\\r\\n    }\\r\\n//________________________________________________________________________________________\\r\\n    function setDevWallets(address[10] memory _wallets) public onlyOwner{\\r\\n        crowdWallet              = _wallets[0];\\r\\n        fundWallet               = _wallets[1];\\r\\n        mbtTokenWallet           = _wallets[2];\\r\\n        companyWallet            = _wallets[3];\\r\\n        personalWallet1          = _wallets[4];\\r\\n        personalWallet2          = _wallets[5];\\r\\n        personalWallet3          = _wallets[6];\\r\\n        bankBonusPoolWallet      = _wallets[7];\\r\\n        profitFromTradingAddress = _wallets[8];\\r\\n        token                    = IERC20(_wallets[9]);\\r\\n        if(bankUsers.length == 0){\\r\\n            bankUsers.push(companyWallet);\\r\\n        } else {\\r\\n            bankUsers[0]    = companyWallet;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function setBoxPrices(uint256[] memory newBoxPrices) public onlyOwner {\\r\\n        BOX_PRICES = newBoxPrices;\\r\\n    }\\r\\n\\r\\n    function setRequiredReferrals(uint256[10] memory newRequiredReferrals) public onlyOwner {\\r\\n        REQUIRED_REFERRALS = newRequiredReferrals;\\r\\n    }\\r\\n\\r\\n    function setRequiredPurchases(uint256[10] memory newRequiredPurchases) public onlyOwner {\\r\\n        REQUIRED_PURCHASES = newRequiredPurchases;\\r\\n    }\\r\\n\\r\\n    function setRewardsPercentagesBox1_7(uint8[] memory newPercentages) public onlyOwner {\\r\\n        REWARDS_PERCENTAGES_BOX_1_7 = newPercentages;\\r\\n    }\\r\\n\\r\\n    function setRewardsPercentagesBox8_10(uint8[] memory newPercentages) public onlyOwner {\\r\\n        REWARDS_PERCENTAGES_BOX_8_10 = newPercentages;\\r\\n    }\\r\\n\\r\\n    function setBankBonusRequiredSales(uint256 newBankBonusRequiredSales) public onlyOwner {\\r\\n        bankBonusRequiredSales = newBankBonusRequiredSales;\\r\\n    }\\r\\n\\r\\n    function setMatrixCrowdStartDate(uint256 newStartDate) public onlyOwner {\\r\\n        matrixCrowdStartDate = newStartDate;\\r\\n    }\\r\\n\\r\\n    function decimals() public view returns (uint256) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function setDecimals(uint256 newDecimals) public onlyOwner{\\r\\n        _decimals = newDecimals;\\r\\n    }\\r\\n\\r\\n    function _authorizeUpgrade(address newImplementation)\\r\\n    internal\\r\\n    onlyOwner\\r\\n    override\\r\\n    {}\\r\\n\\r\\n    function registerUser(address referrer) external {\\r\\n        require(globalUsers[msg.sender].boxLevel == 0, \\\"User already registered\\\");\\r\\n        require(globalUsers[referrer].boxLevel > 0, \\\"Referrer not registered\\\");\\r\\n\\r\\n        globalUsers[referrer].directReferrals.push(msg.sender);\\r\\n        globalUsers[msg.sender].directReferrer = referrer;\\r\\n        upgradeBox();\\r\\n        emit UserRegistered(msg.sender, referrer);\\r\\n    }\\r\\n\\r\\n    function upgradeBox() public {\\r\\n        require(globalUsers[msg.sender].boxLevel < BOX_LEVELS, \\\"User already have max level box\\\");\\r\\n\\r\\n        globalUsers[msg.sender].boxLevel += 1;\\r\\n        uint256 boxLevel = globalUsers[msg.sender].boxLevel;\\r\\n        uint256 price = BOX_PRICES[boxLevel];\\r\\n        token.transferFrom(msg.sender, address(this), price);\\r\\n\\r\\n\\r\\n        address freeReferrer = findFreeReferrer(getDirectReferrer(msg.sender), boxLevel);\\r\\n        localUsers[freeReferrer][boxLevel].localReferrals.push(msg.sender);\\r\\n        localUsers[msg.sender][boxLevel].localReferrer = freeReferrer;\\r\\n\\r\\n        localUsers[msg.sender][boxLevel].matrixDepth = localUsers[freeReferrer][boxLevel].matrixDepth +1;\\r\\n\\r\\n        uint256 amountIn = price;\\r\\n\\r\\n        uint256 stableBonuses;\\r\\n        stableBonuses += payBankBonus(amountIn) + payPersonalSalesDirectBonus(amountIn)\\r\\n        + payMbtPool(amountIn) + payCompanyWallet(amountIn) + payPersonalWallet1(amountIn);\\r\\n        uint256 turboBonus = amountIn * TURBO_BONUS_RATIO / DIVIDER;\\r\\n        amountIn -= stableBonuses;\\r\\n\\r\\n        uint256 crowdAmount;\\r\\n        uint256 fundAmount;\\r\\n        if (boxLevel <= 7) {\\r\\n            crowdAmount = (amountIn * CROWD_RATIO_LEVEL_1_7) / 100;\\r\\n            fundAmount = (amountIn * FUND_RATIO_LEVEL_1_7) / 100;\\r\\n        } else {\\r\\n            crowdAmount = (amountIn * CROWD_RATIO_LEVEL_8_10) / 100;\\r\\n            fundAmount = (amountIn * FUND_RATIO_LEVEL_8_10) / 100;\\r\\n        }\\r\\n\\r\\n        token.transfer(personalWallet2, (fundAmount * 1) / 100);\\r\\n        token.transfer(fundWallet, (fundAmount * 99) / 100);\\r\\n\\r\\n        emit SentToFundWallet(msg.sender, fundWallet, boxLevel, (fundAmount * 99) / 100, block.timestamp);\\r\\n        fundPool += (fundAmount * 99) / 100;\\r\\n        _distributeCrowd(crowdAmount, boxLevel, turboBonus);\\r\\n        boxesBoughtAmount[boxLevel]++;\\r\\n        emit UpgradedBox( msg.sender, freeReferrer, globalUsers[msg.sender].directReferrer, boxLevel, block.timestamp );\\r\\n\\r\\n    }\\r\\n\\r\\n    function distributeProfitFromTrading(uint256 profit) public onlyOwner {\\r\\n        token.transferFrom(msg.sender, address(this), profit);\\r\\n        uint256 companyAmount =( profit * commissionRation / DIVIDER) + (profit * startupFundRation / DIVIDER);\\r\\n        token.transfer(companyWallet, companyAmount); // startup fund and commission 25% (15% + 10%)\\r\\n\\r\\n        uint256 rewards = profit * rewardsRation / DIVIDER; // 15%\\r\\n        token.transfer(companyWallet, rewards);\\r\\n\\r\\n\\r\\n        uint256 clientsAmount = profit * clientsRation / DIVIDER; // 60%\\r\\n        token.transfer(profitFromTradingAddress, clientsAmount);\\r\\n\\r\\n        profitFromTradingAmount = profit;\\r\\n\\r\\n        nextTuesday = getNextTuesdayAtMidnight(block.timestamp);\\r\\n\\r\\n        emit DistributedTradingIncome(msg.sender, profit, nextTuesday, block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n    function getUserTradingRewardAmount(address user) public view returns(uint256){\\r\\n        uint256 userInvestmentInFund = getTotalAmountSentToFund(user);\\r\\n        uint256 totalInvestmentInFund = fundPool;\\r\\n\\r\\n        uint256 weeklyProfitFromTrading = profitFromTradingAmount;\\r\\n\\r\\n        uint256 userShare = (userInvestmentInFund * weeklyProfitFromTrading) / totalInvestmentInFund;\\r\\n\\r\\n        return userShare;\\r\\n    }\\r\\n\\r\\n    mapping (address => bool) public isPlatinumUser;\\r\\n\\r\\n    function setPlatinumUser(address user) public onlyOwner {\\r\\n        isPlatinumUser[user] = true;\\r\\n    }\\r\\n\\r\\n    function getUserUserStatus(address user) public view returns(string memory){\\r\\n        uint256 boxLevel = globalUsers[msg.sender].boxLevel;\\r\\n        uint256 qualificationLevel = getUserQualificationLevel(user);\\r\\n        if (isPlatinumUser[user]){\\r\\n            return \\\"PLATINUM\\\";\\r\\n        }\\r\\n\\r\\n        if (boxLevel == 10 && qualificationLevel == 10){\\r\\n            return \\\"PLATINUM\\\";\\r\\n        }\\r\\n        if (boxLevel == 10){\\r\\n            return \\\"SUPER\\\";\\r\\n        }\\r\\n        if (qualificationLevel == 10){\\r\\n            return \\\"MASTER\\\";\\r\\n        }\\r\\n        return \\\"STANDARD\\\";\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function setNextWithdrawalTime(address user, uint256 timestamp) internal {\\r\\n        globalUsers[user].nextWithdrawalTimestamp = timestamp;\\r\\n    }\\r\\n    function canWithdraw(address user) public view returns (bool) {\\r\\n        return block.timestamp >= globalUsers[user].nextWithdrawalTimestamp;\\r\\n    }\\r\\n\\r\\n    function takeWeeklyTradingReward() public {\\r\\n        require(canWithdraw(msg.sender), \\\"You can't withdraw your reward yet.\\\");\\r\\n        uint256 userTradingRewardAmount =  getUserTradingRewardAmount( msg.sender);\\r\\n        token.transferFrom(profitFromTradingAddress, msg.sender, userTradingRewardAmount);\\r\\n        globalUsers[msg.sender].tradingIncome += userTradingRewardAmount;\\r\\n        setNextWithdrawalTime(msg.sender, nextTuesday);\\r\\n        emit GotRewardFromTrading(msg.sender, userTradingRewardAmount, globalUsers[msg.sender].nextWithdrawalTimestamp, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function getNextTuesdayAtMidnight(uint256 timestamp) public pure returns (uint256) {\\r\\n        uint256 daysToAdd = (7 + 2 - (timestamp / 86400 + 4) % 7) % 7; // Add 4 for the Thursday offset.\\r\\n\\r\\n        uint256 nextTuesdayTimestamp = timestamp + (daysToAdd * 86400) - (timestamp % 86400);\\r\\n\\r\\n        return nextTuesdayTimestamp;\\r\\n    }\\r\\n\\r\\n    function approveUserBankBonus(address user) public {\\r\\n        require(checkFirstCondition(user) || checkSecondCondition(user) || checkThirdCondition(user), \\\"the user has not fulfilled any of the conditions\\\");\\r\\n        for (uint256 i = 0; i < bankUsers.length; i++) {\\r\\n            require(bankUsers[i] != user, \\\"User already in bankUsers\\\");\\r\\n        }\\r\\n        bankUsers.push(user);\\r\\n        emit BankUserAdded(user);\\r\\n    }\\r\\n\\r\\n    function isBankBonusUser(address user) public view returns (bool) {\\r\\n        for (uint256 i = 0; i < bankUsers.length; i++) {\\r\\n            if (bankUsers[i] == user) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function approveUserTurboBonus(address user) public {\\r\\n        require(globalUsers[user].boxLevel >= 9, \\\"User's box level must be 9 or higher.\\\");\\r\\n\\r\\n        uint256 currentTime = block.timestamp;\\r\\n        require(currentTime <= matrixCrowdStartDate + 30 days, \\\"30 days have passed since the start of the project\\\");\\r\\n\\r\\n        globalUsers[user].boxLevel = 10;\\r\\n        globalUsers[user].isTurboUser = true;\\r\\n        emit TurboUserAdded(user);\\r\\n    }\\r\\n\\r\\n\\r\\n    function getUserWorksOnFund(address user) public view returns(uint256) {\\r\\n        uint256 totalInvestment = 0;\\r\\n        uint256 userBoxLevel = globalUsers[user].boxLevel;\\r\\n\\r\\n        for (uint256 i = 1; i <= userBoxLevel; i++) {\\r\\n            uint256 boxPrice = BOX_PRICES[i];\\r\\n            uint256 fundAmount;\\r\\n            boxPrice -= (boxPrice * 1) / 100; // 1%  payBankBonusPool\\r\\n            boxPrice -= (boxPrice * 5) / 100; // 5%  payPersonalSalesDirectBonus\\r\\n            boxPrice -= (boxPrice * 5) / 100; // 5%  payMbtPool\\r\\n            boxPrice -= (boxPrice * 1) / 100; // 1%  payCompanyWallet\\r\\n            boxPrice -= (boxPrice * 1) / 100; // 1%  payPersonalWallet1\\r\\n            if (i <= 7) {\\r\\n                fundAmount = (boxPrice * FUND_RATIO_LEVEL_1_7) / 100;\\r\\n            } else {\\r\\n                fundAmount = (boxPrice * FUND_RATIO_LEVEL_8_10) / 100;\\r\\n            }\\r\\n\\r\\n            fundAmount -= (fundAmount * 1) / 100; // 1%  payPersonalWallet2\\r\\n            totalInvestment += fundAmount;\\r\\n        }\\r\\n\\r\\n        return totalInvestment;\\r\\n    }\\r\\n\\r\\n    function getInvestedAmount(address user) public view returns (uint256) {\\r\\n        uint256 totalInvested = 0;\\r\\n        uint256 userBoxLevel = globalUsers[user].boxLevel;\\r\\n\\r\\n        for (uint256 i = 1; i <= userBoxLevel; i++) {\\r\\n            totalInvested += BOX_PRICES[i];\\r\\n        }\\r\\n\\r\\n        return totalInvested;\\r\\n    }\\r\\n\\r\\n    function getTotalInvestedAmountOfDirectReferrals(address user) public view returns (uint256) {\\r\\n        uint256 totalInvested = 0;\\r\\n        address[] memory directReferrals = getDirectReferrals(user);\\r\\n\\r\\n        for (uint256 i = 0; i < directReferrals.length; i++) {\\r\\n            totalInvested += getInvestedAmount(directReferrals[i]);\\r\\n        }\\r\\n\\r\\n        return totalInvested;\\r\\n    }\\r\\n\\r\\n    function getTotalBoxPurchaseAmount() public view returns (uint256) {\\r\\n        uint256 maxBoxLevel = BOX_LEVELS;\\r\\n\\r\\n        require(maxBoxLevel > 0, \\\"No box levels available\\\");\\r\\n\\r\\n        uint256 totalPurchaseAmount = 0;\\r\\n\\r\\n        for (uint256 i = 1; i <= maxBoxLevel; i++) {\\r\\n            totalPurchaseAmount += boxesBoughtAmount[i] * BOX_PRICES[i];\\r\\n        }\\r\\n\\r\\n        return totalPurchaseAmount;\\r\\n    }\\r\\n\\r\\n    function getPurchaseAmountForBoxLevel(uint256 boxLevel) public view returns (uint256) {\\r\\n        require(boxLevel > 0 && boxLevel <= BOX_LEVELS, \\\"Invalid box level\\\");\\r\\n\\r\\n        return boxesBoughtAmount[boxLevel] * BOX_PRICES[boxLevel];\\r\\n    }\\r\\n\\r\\n    function getQualificationRequirements(uint256 boxLevel) public view returns (uint256 referralsRequired, uint256 purchasesRequired) {\\r\\n        require(boxLevel >= 1 && boxLevel <= REQUIRED_REFERRALS.length, \\\"Invalid box level\\\");\\r\\n\\r\\n        referralsRequired = REQUIRED_REFERRALS[boxLevel - 1];\\r\\n        purchasesRequired = REQUIRED_PURCHASES[boxLevel - 1];\\r\\n\\r\\n        return (referralsRequired, purchasesRequired);\\r\\n    }\\r\\n\\r\\n\\r\\n    function getUserBoxLevel(address user) public view returns (uint256) {\\r\\n        return globalUsers[user].boxLevel;\\r\\n    }\\r\\n\\r\\n\\r\\n    function getDirectReferrer(address user) public view returns (address) {\\r\\n        return globalUsers[user].directReferrer;\\r\\n    }\\r\\n\\r\\n    function getDirectReferrals(address user) public view returns (address[] memory) {\\r\\n        return globalUsers[user].directReferrals;\\r\\n    }\\r\\n\\r\\n    function getDirectReferralsAmount(address user) public view returns(uint256){\\r\\n        return getDirectReferrals(user).length;\\r\\n    }\\r\\n\\r\\n    function getBankBonusIncome(address user) public view returns (uint256) {\\r\\n        return globalUsers[user].bankBonusIncome;\\r\\n    }\\r\\n\\r\\n    function getPersonalSalesDirectBonusIncome(address user) public view returns (uint256) {\\r\\n        return globalUsers[user].personalSalesDirectBonusIncome;\\r\\n    }\\r\\n\\r\\n    function isTurboUser(address user) public view returns (bool) {\\r\\n        return globalUsers[user].isTurboUser;\\r\\n    }\\r\\n\\r\\n    function getUserInvestmentInMBTPool(address userAddress) external view returns (uint256) {\\r\\n        return globalUsers[userAddress].investedIntoMBTPool;\\r\\n    }\\r\\n\\r\\n    function getTotalAmountSentToFund(address user) public view returns (uint256) {\\r\\n        uint256 totalSentToFund = 0;\\r\\n        uint256 userBoxLevel = globalUsers[user].boxLevel;\\r\\n\\r\\n        for (uint256 i = 1; i <= userBoxLevel; i++) {\\r\\n            uint256 boxPrice = BOX_PRICES[i];\\r\\n            uint256 fundAmount;\\r\\n\\r\\n            if (i <= 7) {\\r\\n                fundAmount = boxPrice / 2; // 50% for levels 1-7\\r\\n            } else {\\r\\n                fundAmount = (boxPrice * 30) / 100; // 30% for levels 8-10\\r\\n            }\\r\\n\\r\\n            totalSentToFund += fundAmount;\\r\\n        }\\r\\n\\r\\n        return totalSentToFund;\\r\\n    }\\r\\n\\r\\n    //get tradingIncome\\r\\n    function getTradingIncome(address user) public view returns(uint256){\\r\\n        return globalUsers[user].tradingIncome;\\r\\n    }\\r\\n\\r\\n    // LOCAL USER INFO FUNCTIONS ---------------------------------------------------------------------------------------\\r\\n\\r\\n    function getUserLocalReferrer(address user, uint256 boxLevel) public view returns (address) {\\r\\n        return localUsers[user][boxLevel].localReferrer;\\r\\n    }\\r\\n\\r\\n    function getLocalReferrals(address user, uint256 boxLevel) public view returns (address[] memory) {\\r\\n        return localUsers[user][boxLevel].localReferrals;\\r\\n    }\\r\\n\\r\\n    function getLocalReferralsAmount(address user, uint256 boxLevel) public view returns(uint256){\\r\\n        return getLocalReferrals(user, boxLevel).length;\\r\\n    }\\r\\n\\r\\n    function getUserMatrixDepth(address user, uint256 boxLevel) public view returns (uint256) {\\r\\n        return localUsers[user][boxLevel].matrixDepth;\\r\\n    }\\r\\n\\r\\n    function getTurboBonusIncome(address user, uint256 boxLevel) public view returns (uint256) {\\r\\n        return localUsers[user][boxLevel].turboBonusIncome;\\r\\n    }\\r\\n\\r\\n    function getMatrixBonusIncome(address user, uint256 boxLevel) public view returns (uint256) {\\r\\n        return localUsers[user][boxLevel].matrixBonusIncome;\\r\\n    }\\r\\n\\r\\n    function getMatrixIncomeDirectBonusIncome(address user, uint256 boxLevel) public view returns (uint256) {\\r\\n        return localUsers[user][boxLevel].matrixIncomeDirectBonusIncome;\\r\\n    }\\r\\n\\r\\n\\r\\n    function getAllDirectBoxSoldIncome(address user) public view returns(uint256) {\\r\\n        return getPersonalSalesDirectBonusIncome(user) * 20; //cause 5% from box price so 100/5 = 20\\r\\n    }\\r\\n\\r\\n    function getAllDirectReferralsBoxSoldIncome(address user) public view returns(uint256) {\\r\\n        address[] memory directReferrals = getDirectReferrals(user); // \u0424\u0443\u043d\u043a\u0446\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043e\u043a \u0432\u0441\u0435\u0445 \u043f\u0440\u044f\u043c\u044b\u0445 \u0440\u0435\u0444\u0435\u0440\u0430\u043b\u043e\u0432 \u0434\u043b\u044f \u0434\u0430\u043d\u043d\u043e\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f.\\r\\n        uint256 totalIncome = 0;\\r\\n\\r\\n        for (uint256 i = 0; i < directReferrals.length; i++) {\\r\\n            totalIncome += getPersonalSalesDirectBonusIncome(directReferrals[i]) * 20;\\r\\n        }\\r\\n\\r\\n        return totalIncome;\\r\\n    }\\r\\n\\r\\n    //\\r\\n\\r\\n    function getGlobalTurboBonusIncome(address user) public view returns (uint256) {\\r\\n        uint256 income;\\r\\n        for (uint i = 0; i < BOX_LEVELS; i++){\\r\\n            income += getTurboBonusIncome(user, i);\\r\\n        }\\r\\n        return income;\\r\\n    }\\r\\n\\r\\n    function getGlobalMatrixBonusIncome(address user) public view returns (uint256) {\\r\\n        uint256 income;\\r\\n        for (uint i = 0; i < BOX_LEVELS; i++){\\r\\n            income += getMatrixBonusIncome(user, i);\\r\\n        }\\r\\n        return income;\\r\\n    }\\r\\n\\r\\n    function getGlobalMatrixIncomeDirectBonusIncome(address user) public view returns (uint256) {\\r\\n        uint256 income;\\r\\n        for (uint i = 0; i < BOX_LEVELS; i++){\\r\\n            income += getMatrixIncomeDirectBonusIncome(user, i);\\r\\n        }\\r\\n        return income;\\r\\n    }\\r\\n//--\\r\\n    function getAllUserIncome(address user) public view returns (uint256) {\\r\\n        uint256 totalIncome;\\r\\n\\r\\n        // \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0443\u0440\u043e\u0432\u043d\u0438 \u0431\u043e\u043a\u0441\u043e\u0432 \u0438 \u0441\u0443\u043c\u043c\u0438\u0440\u0443\u0435\u043c \u0434\u043e\u0445\u043e\u0434\u044b\\r\\n        for (uint256 i = 0; i < BOX_LEVELS; i++) {\\r\\n            // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0434\u043e\u0445\u043e\u0434\u044b \u0441 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0443\u0440\u043e\u0432\u043d\u044f \u0431\u043e\u043a\u0441\u0430\\r\\n            totalIncome += getTurboBonusIncome(user, i) + getMatrixBonusIncome(user, i) + getMatrixIncomeDirectBonusIncome(user, i);\\r\\n        }\\r\\n        totalIncome += getBankBonusIncome(user) + getPersonalSalesDirectBonusIncome(user);\\r\\n        return totalIncome;\\r\\n    }\\r\\n\\r\\n    // SHARES/STAKES FUNCTIONS\\r\\n    function getUserMBTPoolShareInPercentage(address user) public view returns (uint256) {\\r\\n        uint256 totalMBTPool = token.balanceOf(mbtTokenWallet); // \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u0442\u0441\u044f, \u0447\u0442\u043e mbtTokenWallet - \u044d\u0442\u043e \u0430\u0434\u0440\u0435\u0441 MBT \u043f\u0443\u043b\u0430\\r\\n        uint256 userInvestment = globalUsers[user].investedIntoMBTPool;\\r\\n\\r\\n        if (totalMBTPool == 0) {\\r\\n            return 0; // \u0434\u043b\u044f \u043f\u0440\u0435\u0434\u043e\u0442\u0432\u0440\u0430\u0449\u0435\u043d\u0438\u044f \u0434\u0435\u043b\u0435\u043d\u0438\u044f \u043d\u0430 \u043d\u043e\u043b\u044c\\r\\n        }\\r\\n\\r\\n        uint256 userShare = (userInvestment * 100) / totalMBTPool;\\r\\n        return userShare;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function findFreeReferrer(address referrer, uint256 boxLevel) public view returns(address) {\\r\\n\\r\\n        if(localUsers[referrer][boxLevel].localReferrals.length < MAX_PARTNERS) {\\r\\n            return referrer;\\r\\n        }\\r\\n\\r\\n        for(uint i = 0; i < MAX_PARTNERS; i++) {\\r\\n            address referralAddress = localUsers[referrer][boxLevel].localReferrals[i];\\r\\n            address nextReferrer = findFreeReferrer(referralAddress, boxLevel);\\r\\n            if(nextReferrer != address(0)) {\\r\\n                return nextReferrer;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return address(0);\\r\\n    }\\r\\n\\r\\n    function getAllLocalReferrersAbove(address user, uint256 boxLevel) public view returns (address[] memory) {\\r\\n        uint256 count = getUserMatrixDepth(user, boxLevel);\\r\\n        return getLocalReferrersAbove(user, count, boxLevel);\\r\\n    }\\r\\n\\r\\n    function getLocalReferrersAbove(address user, uint256 count, uint256 boxLevel) public view returns (address[] memory) {\\r\\n        address[] memory referrers = new address[](count);\\r\\n        address currentUser = user;\\r\\n\\r\\n        for (uint256 i = 0; i < count; i++) {\\r\\n            if (currentUser == address(0)) {\\r\\n                break;\\r\\n            }\\r\\n            currentUser = getUserLocalReferrer(currentUser, boxLevel);\\r\\n            referrers[i] = currentUser;\\r\\n        }\\r\\n\\r\\n        return referrers;\\r\\n    }\\r\\n\\r\\n    function getUserQualificationLevel(address user) public view returns (uint256) {\\r\\n\\r\\n        if (globalUsers[user].isTurboUser) {\\r\\n            return 10;\\r\\n        }\\r\\n\\r\\n        if (user == owner()) {\\r\\n            return 10;\\r\\n        }\\r\\n\\r\\n        uint256 personalReferralsAmount = getDirectReferralsAmount(user);\\r\\n        uint256 totalPurchase = getAllDirectBoxSoldIncome(user);\\r\\n\\r\\n        uint256 qualificationLevel = 0;\\r\\n\\r\\n        for (uint256 level = 0; level < REQUIRED_REFERRALS.length && level < REQUIRED_PURCHASES.length; level++) {\\r\\n            if (personalReferralsAmount >= REQUIRED_REFERRALS[level] && totalPurchase >= REQUIRED_PURCHASES[level]) {\\r\\n                qualificationLevel = level;\\r\\n            } else {\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return qualificationLevel;\\r\\n    }\\r\\n\\r\\n    function eligibleReferrer(address userAddress, uint256 boxLevel) public view returns (address) {\\r\\n        address referrer = userAddress;\\r\\n\\r\\n        uint256 iteration = 0;\\r\\n\\r\\n        while (!_isQualified(referrer, boxLevel)) {\\r\\n            iteration += 1;\\r\\n            referrer = localUsers[referrer][boxLevel].localReferrer;\\r\\n            if (iteration > 10) {\\r\\n                return address(0);\\r\\n            }\\r\\n        }\\r\\n        return referrer;\\r\\n    }\\r\\n\\r\\n    function _distributeCrowd(uint256 crowdAmount, uint256 boxLevel, uint256 turboBonus) internal{\\r\\n        uint256 spentOnAwards = _distributeRewards(crowdAmount, boxLevel, turboBonus);\\r\\n        emit SpentOnAwards(msg.sender, boxLevel, crowdAmount, spentOnAwards);\\r\\n        uint256 amount = token.balanceOf(address(this));\\r\\n\\r\\n        token.transfer(personalWallet3, (amount * 1) / 100);\\r\\n        token.transfer(crowdWallet,  (amount * 99) / 100);\\r\\n        emit SentToCrowdWallet(msg.sender, crowdWallet, boxLevel, (amount * 99) / 100, block.timestamp);\\r\\n\\r\\n    }\\r\\n\\r\\n    function _distributeRewards(uint256 crowdAmount, uint256 boxLevel, uint256 turboBonus) internal returns (uint256) {\\r\\n        uint256 spentOnAwards = 0;\\r\\n        address currentUser = msg.sender;\\r\\n        address[] memory referrers = getLocalReferrersAbove(currentUser, 10, boxLevel);\\r\\n\\r\\n        for (uint256 i = 0; i < referrers.length; i++) {\\r\\n            address referrer = referrers[i];\\r\\n\\r\\n            if (referrer == address(0)) {\\r\\n                break;\\r\\n            }\\r\\n            address qualifiedReferrer = eligibleReferrer(referrer, boxLevel);\\r\\n            if (qualifiedReferrer == address(0)) {\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            uint256 matrixReward = payMatrixBonus(qualifiedReferrer, boxLevel, msg.sender, crowdAmount);\\r\\n            emit ReceivedMatrixBonus(msg.sender, qualifiedReferrer, boxLevel, matrixReward, block.timestamp);\\r\\n            address directRef = getDirectReferrer(qualifiedReferrer);\\r\\n            if (directRef != address(0)) {\\r\\n                uint256 directReward = (matrixReward * MATRIX_INCOME_DIRECT_BONUS_RATIO) / DIVIDER;\\r\\n\\r\\n                token.transfer(directRef, directReward);\\r\\n                localUsers[directRef][boxLevel].matrixIncomeDirectBonusIncome += directReward;\\r\\n                spentOnAwards +=  directReward;\\r\\n                emit ReceivedDirectMatrixBonus(msg.sender, qualifiedReferrer, directRef, boxLevel, directReward, block.timestamp);\\r\\n\\r\\n            }\\r\\n\\r\\n            spentOnAwards += matrixReward;\\r\\n\\r\\n            if (isTurboUser(qualifiedReferrer) ) {\\r\\n                token.transfer(qualifiedReferrer, turboBonus);\\r\\n                spentOnAwards += turboBonus;\\r\\n                localUsers[qualifiedReferrer][boxLevel].turboBonusIncome += turboBonus;\\r\\n                emit ReceivedTurboBonus(msg.sender, qualifiedReferrer, boxLevel, turboBonus, block.timestamp);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return spentOnAwards;\\r\\n    }\\r\\n    function payPersonalSalesDirectBonus(uint256 amountIn) internal returns (uint256) {\\r\\n        address directReferrer = getDirectReferrer(msg.sender);\\r\\n        uint256 amount = amountIn * PERSONAL_SALES_DIRECT_BONUS_RATIO / DIVIDER;\\r\\n        token.transfer(directReferrer, amount);\\r\\n        globalUsers[directReferrer].personalSalesDirectBonusIncome += amount;\\r\\n        emit ReceivedDirectBoxSalesBonus(msg.sender, directReferrer, globalUsers[msg.sender].boxLevel, amount, block.timestamp);\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function payMbtPool(uint256 amountIn) internal returns (uint256){\\r\\n        uint256 amount = amountIn * MBT_POOL_RATIO / DIVIDER;\\r\\n        token.transfer(mbtTokenWallet, amount);\\r\\n        globalUsers[msg.sender].investedIntoMBTPool += amount;\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function payCompanyWallet(uint256 amountIn) internal returns(uint256){\\r\\n        uint256 amount = amountIn * COMPANY_WALLET_RATIO / DIVIDER;\\r\\n        token.transfer(companyWallet, amount);\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function payPersonalWallet1(uint256 amountIn) internal returns(uint256){\\r\\n        uint256 amount = amountIn * PERSONAL_WALLET_1_RATIO / DIVIDER;\\r\\n        token.transfer(personalWallet1, amount);\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function payBankBonus(uint256 amountIn) internal returns (uint256){\\r\\n        uint256 amount = amountIn * BANK_BONUS_POOL_RATIO / DIVIDER;\\r\\n\\r\\n        for (uint256 i = 0; i < bankUsers.length; i++) {\\r\\n            token.transfer(bankUsers[i], amount / bankUsers.length);\\r\\n            globalUsers[bankUsers[i]].bankBonusIncome += amount / bankUsers.length;\\r\\n            emit ReceivedBankBonus(bankUsers[i],  globalUsers[msg.sender].boxLevel, amount / bankUsers.length, block.timestamp);\\r\\n        }\\r\\n\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n\\r\\n    function payMatrixBonus(address referrer, uint256 boxLevel, address initialUser, uint256 amount) internal returns (uint256) {\\r\\n        uint256 depthDifference = getUserMatrixDepth(initialUser, boxLevel) - getUserMatrixDepth(referrer, boxLevel);\\r\\n\\r\\n        if (depthDifference > 10) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 rewardPercentage;\\r\\n        if (boxLevel <= 7) {\\r\\n            rewardPercentage = REWARDS_PERCENTAGES_BOX_1_7[depthDifference - 1];\\r\\n        } else {\\r\\n            rewardPercentage = REWARDS_PERCENTAGES_BOX_8_10[depthDifference - 1];\\r\\n        }\\r\\n        uint256 reward = (amount * rewardPercentage) / DIVIDER;  // DIVIDER = 1000\\r\\n\\r\\n        token.transfer(referrer, reward);\\r\\n        localUsers[referrer][boxLevel].matrixBonusIncome += reward;\\r\\n        return reward;\\r\\n    }\\r\\n\\r\\n    function checkFirstCondition(address user) internal view returns (bool) {\\r\\n        uint256 totalSales = getCrowdAllUserIncomeIncludingReferrals(user);\\r\\n        uint256 currentTime = block.timestamp;\\r\\n\\r\\n        return currentTime <= matrixCrowdStartDate + 30 days && totalSales >= 1e6 * 10**decimals();\\r\\n    }\\r\\n\\r\\n    function checkReferralSales(address user, uint256 boxLevel) internal view returns (bool) {\\r\\n        uint256 totalSales = getAllUserIncome(user);\\r\\n\\r\\n        address[] memory localReferrals = getLocalReferrals(user, boxLevel);\\r\\n\\r\\n        for (uint i = 0; i < localReferrals.length; i++) {\\r\\n            uint256 referralSales = getAllUserIncome(localReferrals[i]);\\r\\n            if (referralSales >= totalSales / 2) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function checkSecondCondition(address user) internal view returns (bool) {\\r\\n        uint256 totalSales = getCrowdAllUserIncomeIncludingReferrals(user);\\r\\n        if (totalSales < bankBonusRequiredSales) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        for (uint256 boxLevel = 0; boxLevel < BOX_LEVELS; boxLevel++) {\\r\\n            if (!checkReferralSales(user, boxLevel)) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function checkThirdCondition(address user) internal view returns (bool) {\\r\\n        if (globalUsers[user].boxLevel == 10 && getUserQualificationLevel(user) == 10) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n\\r\\n    }\\r\\n\\r\\n    function getCrowdAllUserIncomeIncludingReferrals(address user) internal view returns (uint256) {\\r\\n        uint256 totalIncome = getAllUserIncome(user);\\r\\n\\r\\n        address[] memory referrals = globalUsers[user].directReferrals;\\r\\n\\r\\n        for (uint256 i = 0; i < referrals.length; i++) {\\r\\n            totalIncome += getAllUserIncome(referrals[i]);\\r\\n        }\\r\\n\\r\\n        return totalIncome;\\r\\n    }\\r\\n\\r\\n    function _isQualified(address referrer, uint256 boxLevel) internal view returns (bool) {\\r\\n        if (referrer == address(0)) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        if (referrer == owner()) {\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        uint256 personalReferralsAmount = getDirectReferralsAmount(referrer);\\r\\n        uint256 totalPurchase = getAllDirectBoxSoldIncome(referrer);\\r\\n\\r\\n        if (boxLevel < REQUIRED_REFERRALS.length && boxLevel < REQUIRED_PURCHASES.length) {\\r\\n            if (personalReferralsAmount >= REQUIRED_REFERRALS[boxLevel] && totalPurchase >= REQUIRED_PURCHASES[boxLevel]) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"BankUserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initUser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allProfit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextTuesday\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"DistributedTradingIncome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initUserBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextWithdrawalTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"GotRewardFromTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bankUserBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ReceivedBankBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initUser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"directReferrerBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ReceivedDirectBoxSalesBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initUser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"localReferrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"directReferrerBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ReceivedDirectMatrixBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initUser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrerBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ReceivedMatrixBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initUser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"torboUserBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ReceivedTurboBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initUser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"crowdWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SentToCrowdWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initUser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fundWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SentToFundWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initUser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"crowdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spentOnAwards\",\"type\":\"uint256\"}],\"name\":\"SpentOnAwards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"TurboUserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"localReferrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpgradedBox\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BANK_BONUS_POOL_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOX_LEVELS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BOX_PRICES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COMPANY_WALLET_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CROWD_RATIO_LEVEL_1_7\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CROWD_RATIO_LEVEL_8_10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUND_RATIO_LEVEL_1_7\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUND_RATIO_LEVEL_8_10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MATRIX_INCOME_DIRECT_BONUS_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PARTNERS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MBT_POOL_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERSONAL_SALES_DIRECT_BONUS_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERSONAL_WALLET_1_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REQUIRED_PURCHASES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REQUIRED_REFERRALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REWARDS_PERCENTAGES_BOX_1_7\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REWARDS_PERCENTAGES_BOX_8_10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TURBO_BONUS_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"approveUserBankBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"approveUserTurboBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bankBonusPoolWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bankBonusRequiredSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bankUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"boxesBoughtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"canWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clientsRation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commissionRation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crowdWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"distributeProfitFromTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"eligibleReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAllDirectBoxSoldIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAllDirectReferralsBoxSoldIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"getAllLocalReferrersAbove\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAllUserIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBankBonusIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDirectReferrals\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDirectReferralsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDirectReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getGlobalMatrixBonusIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getGlobalMatrixIncomeDirectBonusIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getGlobalTurboBonusIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getInvestedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"getLocalReferrals\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"getLocalReferralsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"getLocalReferrersAbove\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"getMatrixBonusIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"getMatrixIncomeDirectBonusIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getNextTuesdayAtMidnight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPersonalSalesDirectBonusIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"getPurchaseAmountForBoxLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"getQualificationRequirements\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referralsRequired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchasesRequired\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTotalAmountSentToFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBoxPurchaseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTotalInvestedAmountOfDirectReferrals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTradingIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"getTurboBonusIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserBoxLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserInvestmentInMBTPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"getUserLocalReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserMBTPoolShareInPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"}],\"name\":\"getUserMatrixDepth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserQualificationLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTradingRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserUserStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserWorksOnFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_boxLevel\",\"type\":\"uint256\"}],\"name\":\"giveBox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"globalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"boxLevel\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bankBonusIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"personalSalesDirectBonusIncome\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isTurboUser\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"investedIntoMBTPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdrawalTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradingIncome\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isBankBonusUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPlatinumUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isTurboUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"localUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"localReferrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"matrixDepth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"turboBonusIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"matrixBonusIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"matrixIncomeDirectBonusIncome\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"matrixCrowdStartDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mbtTokenWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextTuesday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"personalWallet1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"personalWallet2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"personalWallet3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFromTradingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFromTradingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"registerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsRation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBankBonusRequiredSales\",\"type\":\"uint256\"}],\"name\":\"setBankBonusRequiredSales\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"newBoxPrices\",\"type\":\"uint256[]\"}],\"name\":\"setBoxPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDecimals\",\"type\":\"uint256\"}],\"name\":\"setDecimals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[10]\",\"name\":\"_wallets\",\"type\":\"address[10]\"}],\"name\":\"setDevWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_boxLevel\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_directReferrer\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_directReferrals\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_bankBonusIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_personalSalesDirectBonusIncome\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isTurboUser\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_investedIntoMBTPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextWithdrawalTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tradingIncome\",\"type\":\"uint256\"}],\"name\":\"setGlobalUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_boxLevel\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_localReferrer\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_localReferrals\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_matrixDepth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_turboBonusIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_matrixBonusIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_matrixIncomeDirectBonusIncome\",\"type\":\"uint256\"}],\"name\":\"setLocalUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStartDate\",\"type\":\"uint256\"}],\"name\":\"setMatrixCrowdStartDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"setPlatinumUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"newRequiredPurchases\",\"type\":\"uint256[10]\"}],\"name\":\"setRequiredPurchases\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"newRequiredReferrals\",\"type\":\"uint256[10]\"}],\"name\":\"setRequiredReferrals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"newPercentages\",\"type\":\"uint8[]\"}],\"name\":\"setRewardsPercentagesBox1_7\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"newPercentages\",\"type\":\"uint8[]\"}],\"name\":\"setRewardsPercentagesBox8_10\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startupFundRation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeWeeklyTradingReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeBox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "MatrixBoxes", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "byzantium", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}