{"SourceCode": "{\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity\\u0027s `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity\\u0027s `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity\\u0027s `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b \\u003c= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity\\u0027s `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, \\\"SafeMath: division by zero\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b \\u003e 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\"},\"VestingWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// VestingWallet\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/**\\n * @title VestingWallet\\n * @dev This contract handles the vesting of ERC20 tokens for a given beneficiary. \\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\\n * be immediately releasable.\\n */\\n\\nabstract contract BEP20Basic {\\n    function totalSupply() public view virtual returns (uint256);\\n    function balanceOf(address who) public view virtual returns (uint256);\\n    function transfer(address to, uint256 value) public virtual returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n\\nabstract contract BEP20 is BEP20Basic {\\n    function allowance(address owner, address spender) public view virtual returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\\n    function approve(address spender, uint256 value) public virtual returns (bool);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\ncontract VestingWallet  {\\n  using SafeMath for uint256;\\n\\n  BEP20 private token;\\n  address public beneficiary;\\n\\n  uint64  public numberOfMint;\\n  uint256 public monthlySupply;\\n  uint256 public nextMintingTime;\\n  uint256 DAYS_IN_YEAR = 365 days;\\n  uint256 ONE_MONTH = 60;//DAYS_IN_YEAR.div(12); // 1 month /60;//\\n  bool firstTime = true;\\n\\n  constructor(\\n    BEP20 _token,\\n    address _beneficiary,\\n    uint256 _monthlySupply\\n    ) \\n   {\\n        token = _token;\\n        beneficiary = _beneficiary;\\n        nextMintingTime = block.timestamp;\\n        monthlySupply = _monthlySupply;\\n    }\\n\\n  function release() public  {\\n      require( block.timestamp \\u003e nextMintingTime.add(ONE_MONTH) || firstTime , \\\"erreur\\\");\\n      require(token.balanceOf(address(this)) \\u003e= monthlySupply, \\\"BEP20: transfer amount exceeds balance\\\");\\n        token.transfer(beneficiary, monthlySupply);\\n        nextMintingTime = nextMintingTime.add(ONE_MONTH);\\n        numberOfMint++;\\n        firstTime = false;\\n  }\\n\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract BEP20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_monthlySupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monthlySupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextMintingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfMint\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VestingWallet", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000007e52a123ed6db6ac872a875552935fbbd2544c860000000000000000000000002bed48b7c101110d4158acd0b1a6243f677b209800000000000000000000000000000000000000000000000000000095753c1940", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bd292255624c114f74e84712bffe5b93372fd251cd880e4ab5b0b59da1cc8b61"}