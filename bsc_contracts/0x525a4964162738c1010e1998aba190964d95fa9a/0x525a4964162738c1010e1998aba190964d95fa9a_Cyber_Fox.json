{"SourceCode": "pragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721 {\r\n\t/**\r\n\t * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n\t * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n\t * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n\t * transfer, the approved address for that NFT (if any) is reset to none.\r\n\t */\r\n\tevent Transfer(\r\n\t\taddress indexed _from,\r\n\t\taddress indexed _to,\r\n\t\tuint256 indexed _tokenId\r\n\t);\r\n\r\n\t/**\r\n\t * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n\t * address indicates there is no approved address. When a Transfer event emits, this also\r\n\t * indicates that the approved address for that NFT (if any) is reset to none.\r\n\t */\r\n\tevent Approval(\r\n\t\taddress indexed _owner,\r\n\t\taddress indexed _approved,\r\n\t\tuint256 indexed _tokenId\r\n\t);\r\n\r\n\t/**\r\n\t * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n\t * all NFTs of the owner.\r\n\t */\r\n\tevent ApprovalForAll(\r\n\t\taddress indexed _owner,\r\n\t\taddress indexed _operator,\r\n\t\tbool _approved\r\n\t);\r\n\r\n\t/**\r\n\t * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n\t * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n\t * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n\t * function checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n\t * `onERC721Received` on `_to` and throws if the return value is not\r\n\t * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n\t * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n\t * be changed to payable.\r\n\t * @param _from The current owner of the NFT.\r\n\t * @param _to The new owner.\r\n\t * @param _tokenId The NFT to transfer.\r\n\t * @param _data Additional data with no specified format, sent in call to `_to`.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId,\r\n\t\tbytes calldata _data\r\n\t) external;\r\n\r\n\t/**\r\n\t * @notice This works identically to the other function with an extra data parameter, except this\r\n\t * function just sets data to \"\"\r\n\t * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n\t * be changed to payable.\r\n\t * @param _from The current owner of the NFT.\r\n\t * @param _to The new owner.\r\n\t * @param _tokenId The NFT to transfer.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId\r\n\t) external;\r\n\r\n\t/**\r\n\t * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n\t * they may be permanently lost.\r\n\t * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n\t * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n\t * address. Throws if `_tokenId` is not a valid NFT.  This function can be changed to payable.\r\n\t * @param _from The current owner of the NFT.\r\n\t * @param _to The new owner.\r\n\t * @param _tokenId The NFT to transfer.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId\r\n\t) external;\r\n\r\n\t/**\r\n\t * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n\t * the current NFT owner, or an authorized operator of the current owner.\r\n\t * @param _approved The new approved NFT controller.\r\n\t * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\r\n\t * @param _tokenId The NFT to approve.\r\n\t */\r\n\tfunction approve(address _approved, uint256 _tokenId) external;\r\n\r\n\t/**\r\n\t * @notice The contract MUST allow multiple operators per owner.\r\n\t * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n\t * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n\t * @param _operator Address to add to the set of authorized operators.\r\n\t * @param _approved True if the operators is approved, false to revoke approval.\r\n\t */\r\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n\t/**\r\n\t * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n\t * considered invalid, and this function throws for queries about the zero address.\r\n\t * @notice Count all NFTs assigned to an owner.\r\n\t * @param _owner Address for whom to query the balance.\r\n\t * @return Balance of _owner.\r\n\t */\r\n\tfunction balanceOf(address _owner) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @notice Find the owner of an NFT.\r\n\t * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\r\n\t * considered invalid, and queries about them do throw.\r\n\t * @param _tokenId The identifier for an NFT.\r\n\t * @return Address of _tokenId owner.\r\n\t */\r\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n\t/**\r\n\t * @notice Throws if `_tokenId` is not a valid NFT.\r\n\t * @dev Get the approved address for a single NFT.\r\n\t * @param _tokenId The NFT to find the approved address for.\r\n\t * @return Address that _tokenId is approved for.\r\n\t */\r\n\tfunction getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n\t/**\r\n\t * @notice Query if an address is an authorized operator for another address.\r\n\t * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\r\n\t * @param _owner The address that owns the NFTs.\r\n\t * @param _operator The address that acts on behalf of the owner.\r\n\t * @return True if approved for all, false otherwise.\r\n\t */\r\n\tfunction isApprovedForAll(address _owner, address _operator)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (bool);\r\n}\r\n\r\n// File contracts/erc721-token-receiver.solpragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev ERC-721 interface for accepting safe transfers.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721TokenReceiver {\r\n\t/**\r\n\t * @notice The contract address is always the message sender. A wallet/broker/auction application\r\n\t * MUST implement the wallet interface if it will accept safe transfers.\r\n\t * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\r\n\t * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n\t * of other than the magic value MUST result in the transaction being reverted.\r\n\t * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\r\n\t * @param _operator The address which called `safeTransferFrom` function.\r\n\t * @param _from The address which previously owned the token.\r\n\t * @param _tokenId The NFT identifier which is being transferred.\r\n\t * @param _data Additional data with no specified format.\r\n\t * @return Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n\t */\r\n\tfunction onERC721Received(\r\n\t\taddress _operator,\r\n\t\taddress _from,\r\n\t\tuint256 _tokenId,\r\n\t\tbytes calldata _data\r\n\t) external returns (bytes4);\r\n}\r\n\r\n// File contracts/erc165.solpragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev A standard for detecting smart contract interfaces.\r\n * See: https://eips.ethereum.org/EIPS/eip-165.\r\n */\r\ninterface ERC165 {\r\n\t/**\r\n\t * @dev Checks if the smart contract includes a specific interface.\r\n\t * This function uses less than 30,000 gas.\r\n\t * @param _interfaceID The interface identifier, as specified in ERC-165.\r\n\t * @return True if _interfaceID is supported, false otherwise.\r\n\t */\r\n\tfunction supportsInterface(bytes4 _interfaceID)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (bool);\r\n}\r\n\r\n// File contracts/supports-interface.sol\r\n\r\npragma solidity 0.8.4;\r\n/**\r\n * @dev Implementation of standard for detect smart contract interfaces.\r\n */\r\n\r\ncontract SupportsInterface is ERC165 {\r\n\t/**\r\n\t * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\r\n\t */\r\n\tmapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n\t/**\r\n\t * @dev Contract constructor.\r\n\t */\r\n\tconstructor() {\r\n\t\tsupportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function to check which interfaces are suported by this contract.\r\n\t * @param _interfaceID Id of the interface.\r\n\t * @return True if _interfaceID is supported, false otherwise.\r\n\t */\r\n\tfunction supportsInterface(bytes4 _interfaceID)\r\n\t\texternal\r\n\t\tview\r\n\t\toverride\r\n\t\treturns (bool)\r\n\t{\r\n\t\treturn supportedInterfaces[_interfaceID];\r\n\t}\r\n}\r\n\r\n// File contracts/address-utils.sol\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @notice Based on:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n * Requires EIP-1052.\r\n * @dev Utility library of inline functions on addresses.\r\n */\r\nlibrary AddressUtils {\r\n\t/**\r\n\t * @dev Returns whether the target address is a contract.\r\n\t * @param _addr Address to check.\r\n\t * @return addressCheck True if _addr is a contract, false if not.\r\n\t */\r\n\tfunction isContract(address _addr)\r\n\t\tinternal\r\n\t\tview\r\n\t\treturns (bool addressCheck)\r\n\t{\r\n\t\t// This method relies in extcodesize, which returns 0 for contracts in\r\n\t\t// construction, since the code is only stored at the end of the\r\n\t\t// constructor execution.\r\n\r\n\t\t// According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n\t\t// and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n\t\t// for accounts without code, i.e. `keccak256('')`\r\n\t\tbytes32 codehash;\r\n\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\t\tassembly {\r\n\t\t\tcodehash := extcodehash(_addr)\r\n\t\t} // solhint-disable-line\r\n\t\taddressCheck = (codehash != 0x0 && codehash != accountHash);\r\n\t}\r\n}\r\n\r\n// File contracts/nf-token.sol\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Implementation of ERC-721 non-fungible token standard.\r\n */\r\ncontract NFToken is ERC721, SupportsInterface {\r\n\tusing AddressUtils for address;\r\n\r\n\t/**\r\n\t * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\r\n\t * Based on 0xcert framework error codes.\r\n\t */\r\n\tstring constant ZERO_ADDRESS = '003001';\r\n\tstring constant NOT_VALID_NFT = '003002';\r\n\tstring constant NOT_OWNER_OR_OPERATOR = '003003';\r\n\tstring constant NOT_OWNER_APPROVED_OR_OPERATOR = '003004';\r\n\tstring constant NOT_ABLE_TO_RECEIVE_NFT = '003005';\r\n\tstring constant NFT_ALREADY_EXISTS = '003006';\r\n\tstring constant NOT_OWNER = '003007';\r\n\tstring constant IS_OWNER = '003008';\r\n\r\n\t/**\r\n\t * @dev Magic value of a smart contract that can receive NFT.\r\n\t * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n\t */\r\n\tbytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n\t/**\r\n\t * @dev A mapping from NFT ID to the address that owns it.\r\n\t */\r\n\tmapping(uint256 => address) internal idToOwner;\r\n\r\n\t/**\r\n\t * @dev Mapping from NFT ID to approved address.\r\n\t */\r\n\tmapping(uint256 => address) internal idToApproval;\r\n\r\n\t/**\r\n\t * @dev Mapping from owner address to count of their tokens.\r\n\t */\r\n\tmapping(address => uint256) private ownerToNFTokenCount;\r\n\r\n\t/**\r\n\t * @dev Mapping from owner address to mapping of operator addresses.\r\n\t */\r\n\tmapping(address => mapping(address => bool)) internal ownerToOperators;\r\n\r\n\t/**\r\n\t * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\r\n\t * @param _tokenId ID of the NFT to validate.\r\n\t */\r\n\tmodifier canOperate(uint256 _tokenId) {\r\n\t\taddress tokenOwner = idToOwner[_tokenId];\r\n\t\trequire(\r\n\t\t\ttokenOwner == msg.sender ||\r\n\t\t\t\townerToOperators[tokenOwner][msg.sender],\r\n\t\t\tNOT_OWNER_OR_OPERATOR\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Guarantees that the msg.sender is allowed to transfer NFT.\r\n\t * @param _tokenId ID of the NFT to transfer.\r\n\t */\r\n\tmodifier canTransfer(uint256 _tokenId) {\r\n\t\taddress tokenOwner = idToOwner[_tokenId];\r\n\t\trequire(\r\n\t\t\ttokenOwner == msg.sender ||\r\n\t\t\t\tidToApproval[_tokenId] == msg.sender ||\r\n\t\t\t\townerToOperators[tokenOwner][msg.sender],\r\n\t\t\tNOT_OWNER_APPROVED_OR_OPERATOR\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Guarantees that _tokenId is a valid Token.\r\n\t * @param _tokenId ID of the NFT to validate.\r\n\t */\r\n\tmodifier validNFToken(uint256 _tokenId) {\r\n\t\trequire(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Contract constructor.\r\n\t */\r\n\tconstructor() {\r\n\t\tsupportedInterfaces[0x80ac58cd] = true; // ERC721\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n\t * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n\t * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n\t * function checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n\t * `onERC721Received` on `_to` and throws if the return value is not\r\n\t * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n\t * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n\t * be changed to payable.\r\n\t * @param _from The current owner of the NFT.\r\n\t * @param _to The new owner.\r\n\t * @param _tokenId The NFT to transfer.\r\n\t * @param _data Additional data with no specified format, sent in call to `_to`.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId,\r\n\t\tbytes calldata _data\r\n\t) external override {\r\n\t\t_safeTransferFrom(_from, _to, _tokenId, _data);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice This works identically to the other function with an extra data parameter, except this\r\n\t * function just sets data to \"\".\r\n\t * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n\t * be changed to payable.\r\n\t * @param _from The current owner of the NFT.\r\n\t * @param _to The new owner.\r\n\t * @param _tokenId The NFT to transfer.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId\r\n\t) external override {\r\n\t\t_safeTransferFrom(_from, _to, _tokenId, '');\r\n\t}\r\n\r\n\t/**\r\n\t * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n\t * they may be permanently lost.\r\n\t * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n\t * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n\t * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\r\n\t * @param _from The current owner of the NFT.\r\n\t * @param _to The new owner.\r\n\t * @param _tokenId The NFT to transfer.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId\r\n\t) external override canTransfer(_tokenId) validNFToken(_tokenId) {\r\n\t\taddress tokenOwner = idToOwner[_tokenId];\r\n\t\trequire(tokenOwner == _from, NOT_OWNER);\r\n\t\trequire(_to != address(0), ZERO_ADDRESS);\r\n\r\n\t\t_transfer(_to, _tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n\t * the current NFT owner, or an authorized operator of the current owner.\r\n\t * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\r\n\t * @param _approved Address to be approved for the given NFT ID.\r\n\t * @param _tokenId ID of the token to be approved.\r\n\t */\r\n\tfunction approve(address _approved, uint256 _tokenId)\r\n\t\texternal\r\n\t\toverride\r\n\t\tcanOperate(_tokenId)\r\n\t\tvalidNFToken(_tokenId)\r\n\t{\r\n\t\taddress tokenOwner = idToOwner[_tokenId];\r\n\t\trequire(_approved != tokenOwner, IS_OWNER);\r\n\r\n\t\tidToApproval[_tokenId] = _approved;\r\n\t\temit Approval(tokenOwner, _approved, _tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice This works even if sender doesn't own any tokens at the time.\r\n\t * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n\t * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n\t * @param _operator Address to add to the set of authorized operators.\r\n\t * @param _approved True if the operators is approved, false to revoke approval.\r\n\t */\r\n\tfunction setApprovalForAll(address _operator, bool _approved)\r\n\t\texternal\r\n\t\toverride\r\n\t{\r\n\t\townerToOperators[msg.sender][_operator] = _approved;\r\n\t\temit ApprovalForAll(msg.sender, _operator, _approved);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n\t * considered invalid, and this function throws for queries about the zero address.\r\n\t * @param _owner Address for whom to query the balance.\r\n\t * @return Balance of _owner.\r\n\t */\r\n\tfunction balanceOf(address _owner)\r\n\t\texternal\r\n\t\tview\r\n\t\toverride\r\n\t\treturns (uint256)\r\n\t{\r\n\t\trequire(_owner != address(0), ZERO_ADDRESS);\r\n\t\treturn _getOwnerNFTCount(_owner);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\r\n\t * considered invalid, and queries about them do throw.\r\n\t * @param _tokenId The identifier for an NFT.\r\n\t * @return _owner Address of _tokenId owner.\r\n\t */\r\n\tfunction ownerOf(uint256 _tokenId)\r\n\t\texternal\r\n\t\tview\r\n\t\toverride\r\n\t\treturns (address _owner)\r\n\t{\r\n\t\t_owner = idToOwner[_tokenId];\r\n\t\trequire(_owner != address(0), NOT_VALID_NFT);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Throws if `_tokenId` is not a valid NFT.\r\n\t * @dev Get the approved address for a single NFT.\r\n\t * @param _tokenId ID of the NFT to query the approval of.\r\n\t * @return Address that _tokenId is approved for.\r\n\t */\r\n\tfunction getApproved(uint256 _tokenId)\r\n\t\texternal\r\n\t\tview\r\n\t\toverride\r\n\t\tvalidNFToken(_tokenId)\r\n\t\treturns (address)\r\n\t{\r\n\t\treturn idToApproval[_tokenId];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if `_operator` is an approved operator for `_owner`.\r\n\t * @param _owner The address that owns the NFTs.\r\n\t * @param _operator The address that acts on behalf of the owner.\r\n\t * @return True if approved for all, false otherwise.\r\n\t */\r\n\tfunction isApprovedForAll(address _owner, address _operator)\r\n\t\texternal\r\n\t\tview\r\n\t\toverride\r\n\t\treturns (bool)\r\n\t{\r\n\t\treturn ownerToOperators[_owner][_operator];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Does NO checks.\r\n\t * @dev Actually performs the transfer.\r\n\t * @param _to Address of a new owner.\r\n\t * @param _tokenId The NFT that is being transferred.\r\n\t */\r\n\tfunction _transfer(address _to, uint256 _tokenId) internal {\r\n\t\taddress from = idToOwner[_tokenId];\r\n\t\t_clearApproval(_tokenId);\r\n\r\n\t\t_removeNFToken(from, _tokenId);\r\n\t\t_addNFToken(_to, _tokenId);\r\n\r\n\t\temit Transfer(from, _to, _tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice This is an internal function which should be called from user-implemented external\r\n\t * mint function. Its purpose is to show and properly initialize data structures when using this\r\n\t * implementation.\r\n\t * @dev Mints a new NFT.\r\n\t * @param _to The address that will own the minted NFT.\r\n\t * @param _tokenId of the NFT to be minted by the msg.sender.\r\n\t */\r\n\tfunction _mint(address _to, uint256 _tokenId) internal virtual {\r\n\t\trequire(_to != address(0), ZERO_ADDRESS);\r\n\t\trequire(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n\t\t_addNFToken(_to, _tokenId);\r\n\r\n\t\temit Transfer(address(0), _to, _tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice This is an internal function which should be called from user-implemented external burn\r\n\t * function. Its purpose is to show and properly initialize data structures when using this\r\n\t * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\r\n\t * NFT.\r\n\t * @dev Burns a NFT.\r\n\t * @param _tokenId ID of the NFT to be burned.\r\n\t */\r\n\tfunction _burn(uint256 _tokenId) internal virtual validNFToken(_tokenId) {\r\n\t\taddress tokenOwner = idToOwner[_tokenId];\r\n\t\t_clearApproval(_tokenId);\r\n\t\t_removeNFToken(tokenOwner, _tokenId);\r\n\t\temit Transfer(tokenOwner, address(0), _tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n\t * @dev Removes a NFT from owner.\r\n\t * @param _from Address from which we want to remove the NFT.\r\n\t * @param _tokenId Which NFT we want to remove.\r\n\t */\r\n\tfunction _removeNFToken(address _from, uint256 _tokenId) internal virtual {\r\n\t\trequire(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n\t\townerToNFTokenCount[_from] -= 1;\r\n\t\tdelete idToOwner[_tokenId];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n\t * @dev Assigns a new NFT to owner.\r\n\t * @param _to Address to which we want to add the NFT.\r\n\t * @param _tokenId Which NFT we want to add.\r\n\t */\r\n\tfunction _addNFToken(address _to, uint256 _tokenId) internal virtual {\r\n\t\trequire(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n\t\tidToOwner[_tokenId] = _to;\r\n\t\townerToNFTokenCount[_to] += 1;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n\t * extension to remove double storage (gas optimization) of owner NFT count.\r\n\t * @param _owner Address for whom to query the count.\r\n\t * @return Number of _owner NFTs.\r\n\t */\r\n\tfunction _getOwnerNFTCount(address _owner)\r\n\t\tinternal\r\n\t\tview\r\n\t\tvirtual\r\n\t\treturns (uint256)\r\n\t{\r\n\t\treturn ownerToNFTokenCount[_owner];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Actually perform the safeTransferFrom.\r\n\t * @param _from The current owner of the NFT.\r\n\t * @param _to The new owner.\r\n\t * @param _tokenId The NFT to transfer.\r\n\t * @param _data Additional data with no specified format, sent in call to `_to`.\r\n\t */\r\n\tfunction _safeTransferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId,\r\n\t\tbytes memory _data\r\n\t) private canTransfer(_tokenId) validNFToken(_tokenId) {\r\n\t\taddress tokenOwner = idToOwner[_tokenId];\r\n\t\trequire(tokenOwner == _from, NOT_OWNER);\r\n\t\trequire(_to != address(0), ZERO_ADDRESS);\r\n\r\n\t\t_transfer(_to, _tokenId);\r\n\r\n\t\tif (_to.isContract()) {\r\n\t\t\tbytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\r\n\t\t\t\tmsg.sender,\r\n\t\t\t\t_from,\r\n\t\t\t\t_tokenId,\r\n\t\t\t\t_data\r\n\t\t\t);\r\n\t\t\trequire(\r\n\t\t\t\tretval == MAGIC_ON_ERC721_RECEIVED,\r\n\t\t\t\tNOT_ABLE_TO_RECEIVE_NFT\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Clears the current approval of a given NFT ID.\r\n\t * @param _tokenId ID of the NFT to be transferred.\r\n\t */\r\n\tfunction _clearApproval(uint256 _tokenId) private {\r\n\t\tdelete idToApproval[_tokenId];\r\n\t}\r\n}\r\n\r\n// File contracts/erc721-enumerable.solpragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721Enumerable {\r\n\t/**\r\n\t * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\r\n\t * assigned and queryable owner not equal to the zero address.\r\n\t * @return Total supply of NFTs.\r\n\t */\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\r\n\t * @param _index A counter less than `totalSupply()`.\r\n\t * @return Token id.\r\n\t */\r\n\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\r\n\t * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\r\n\t * representing invalid NFTs.\r\n\t * @param _owner An address where we are interested in NFTs owned by them.\r\n\t * @param _index A counter less than `balanceOf(_owner)`.\r\n\t * @return Token id.\r\n\t */\r\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n}\r\n\r\n// File contracts/nf-token-enumerable.solpragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\r\n */\r\ncontract NFTokenEnumerable is NFToken, ERC721Enumerable {\r\n\t/**\r\n\t * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\r\n\t * Based on 0xcert framework error codes.\r\n\t */\r\n\tstring constant INVALID_INDEX = '005007';\r\n\r\n\t/**\r\n\t * @dev Array of all NFT IDs.\r\n\t */\r\n\tuint256[] internal tokens;\r\n\r\n\t/**\r\n\t * @dev Mapping from token ID to its index in global tokens array.\r\n\t */\r\n\tmapping(uint256 => uint256) internal idToIndex;\r\n\r\n\t/**\r\n\t * @dev Mapping from owner to list of owned NFT IDs.\r\n\t */\r\n\tmapping(address => uint256[]) internal ownerToIds;\r\n\r\n\t/**\r\n\t * @dev Mapping from NFT ID to its index in the owner tokens list.\r\n\t */\r\n\tmapping(uint256 => uint256) internal idToOwnerIndex;\r\n\r\n\t/**\r\n\t * @dev Contract constructor.\r\n\t */\r\n\tconstructor() {\r\n\t\tsupportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the count of all existing NFTokens.\r\n\t * @return Total supply of NFTs.\r\n\t */\r\n\tfunction totalSupply() external view override returns (uint256) {\r\n\t\treturn tokens.length;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns NFT ID by its index.\r\n\t * @param _index A counter less than `totalSupply()`.\r\n\t * @return Token id.\r\n\t */\r\n\tfunction tokenByIndex(uint256 _index)\r\n\t\texternal\r\n\t\tview\r\n\t\toverride\r\n\t\treturns (uint256)\r\n\t{\r\n\t\trequire(_index < tokens.length, INVALID_INDEX);\r\n\t\treturn tokens[_index];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev returns the n-th NFT ID from a list of owner's tokens.\r\n\t * @param _owner Token owner's address.\r\n\t * @param _index Index number representing n-th token in owner's list of tokens.\r\n\t * @return Token id.\r\n\t */\r\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n\t\texternal\r\n\t\tview\r\n\t\toverride\r\n\t\treturns (uint256)\r\n\t{\r\n\t\trequire(_index < ownerToIds[_owner].length, INVALID_INDEX);\r\n\t\treturn ownerToIds[_owner][_index];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice This is an internal function which should be called from user-implemented external\r\n\t * mint function. Its purpose is to show and properly initialize data structures when using this\r\n\t * implementation.\r\n\t * @dev Mints a new NFT.\r\n\t * @param _to The address that will own the minted NFT.\r\n\t * @param _tokenId of the NFT to be minted by the msg.sender.\r\n\t */\r\n\tfunction _mint(address _to, uint256 _tokenId) internal virtual override {\r\n\t\tsuper._mint(_to, _tokenId);\r\n\t\ttokens.push(_tokenId);\r\n\t\tidToIndex[_tokenId] = tokens.length - 1;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice This is an internal function which should be called from user-implemented external\r\n\t * burn function. Its purpose is to show and properly initialize data structures when using this\r\n\t * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\r\n\t * NFT.\r\n\t * @dev Burns a NFT.\r\n\t * @param _tokenId ID of the NFT to be burned.\r\n\t */\r\n\tfunction _burn(uint256 _tokenId) internal virtual override {\r\n\t\tsuper._burn(_tokenId);\r\n\r\n\t\tuint256 tokenIndex = idToIndex[_tokenId];\r\n\t\tuint256 lastTokenIndex = tokens.length - 1;\r\n\t\tuint256 lastToken = tokens[lastTokenIndex];\r\n\r\n\t\ttokens[tokenIndex] = lastToken;\r\n\r\n\t\ttokens.pop();\r\n\t\t// This wastes gas if you are burning the last token but saves a little gas if you are not.\r\n\t\tidToIndex[lastToken] = tokenIndex;\r\n\t\tidToIndex[_tokenId] = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n\t * @dev Removes a NFT from an address.\r\n\t * @param _from Address from wich we want to remove the NFT.\r\n\t * @param _tokenId Which NFT we want to remove.\r\n\t */\r\n\tfunction _removeNFToken(address _from, uint256 _tokenId)\r\n\t\tinternal\r\n\t\tvirtual\r\n\t\toverride\r\n\t{\r\n\t\trequire(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n\t\tdelete idToOwner[_tokenId];\r\n\r\n\t\tuint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n\t\tuint256 lastTokenIndex = ownerToIds[_from].length - 1;\r\n\r\n\t\tif (lastTokenIndex != tokenToRemoveIndex) {\r\n\t\t\tuint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n\t\t\townerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n\t\t\tidToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n\t\t}\r\n\r\n\t\townerToIds[_from].pop();\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n\t * @dev Assigns a new NFT to an address.\r\n\t * @param _to Address to wich we want to add the NFT.\r\n\t * @param _tokenId Which NFT we want to add.\r\n\t */\r\n\tfunction _addNFToken(address _to, uint256 _tokenId)\r\n\t\tinternal\r\n\t\tvirtual\r\n\t\toverride\r\n\t{\r\n\t\trequire(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\t\tidToOwner[_tokenId] = _to;\r\n\r\n\t\townerToIds[_to].push(_tokenId);\r\n\t\tidToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n\t * extension to remove double storage(gas optimization) of owner NFT count.\r\n\t * @param _owner Address for whom to query the count.\r\n\t * @return Number of _owner NFTs.\r\n\t */\r\n\tfunction _getOwnerNFTCount(address _owner)\r\n\t\tinternal\r\n\t\tview\r\n\t\tvirtual\r\n\t\toverride\r\n\t\treturns (uint256)\r\n\t{\r\n\t\treturn ownerToIds[_owner].length;\r\n\t}\r\n}\r\n\r\n// File contracts/erc721-metadata.sol\r\n\r\npragma solidity 0.8.4;\r\n/**\r\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\n\r\ninterface ERC721Metadata {\r\n\t/**\r\n\t * @dev Returns a descriptive name for a collection of NFTs in this contract.\r\n\t * @return _name Representing name.\r\n\t */\r\n\tfunction name() external view returns (string memory _name);\r\n\r\n\t/**\r\n\t * @dev Returns a abbreviated name for a collection of NFTs in this contract.\r\n\t * @return _symbol Representing symbol.\r\n\t */\r\n\tfunction symbol() external view returns (string memory _symbol);\r\n\r\n\t/**\r\n\t * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\r\n\t * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\r\n\t * that conforms to the \"ERC721 Metadata JSON Schema\".\r\n\t * @return URI of _tokenId.\r\n\t */\r\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\n// File contracts/nf-token-metadata.sol\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\r\n */\r\ncontract NFTokenMetadata is NFToken, ERC721Metadata {\r\n\t/**\r\n\t * @dev A descriptive name for a collection of NFTs.\r\n\t */\r\n\tstring internal nftName;\r\n\r\n\t/**\r\n\t * @dev An abbreviated name for NFTokens.\r\n\t */\r\n\tstring internal nftSymbol;\r\n\r\n\t/**\r\n\t * @dev Mapping from NFT ID to metadata uri.\r\n\t */\r\n\tmapping(uint256 => string) internal idToUri;\r\n\r\n\t/**\r\n\t * @notice When implementing this contract don't forget to set nftName and nftSymbol.\r\n\t * @dev Contract constructor.\r\n\t */\r\n\tconstructor() {\r\n\t\tsupportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns a descriptive name for a collection of NFTokens.\r\n\t * @return _name Representing name.\r\n\t */\r\n\tfunction name() external view override returns (string memory _name) {\r\n\t\t_name = nftName;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns an abbreviated name for NFTokens.\r\n\t * @return _symbol Representing symbol.\r\n\t */\r\n\tfunction symbol() external view override returns (string memory _symbol) {\r\n\t\t_symbol = nftSymbol;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev A distinct URI (RFC 3986) for a given NFT.\r\n\t * @param _tokenId Id for which we want uri.\r\n\t * @return URI of _tokenId.\r\n\t */\r\n\tfunction tokenURI(uint256 _tokenId)\r\n\t\texternal\r\n\t\tview\r\n\t\toverride\r\n\t\tvalidNFToken(_tokenId)\r\n\t\treturns (string memory)\r\n\t{\r\n\t\treturn idToUri[_tokenId];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice This is an internal function which should be called from user-implemented external\r\n\t * burn function. Its purpose is to show and properly initialize data structures when using this\r\n\t * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\r\n\t * NFT.\r\n\t * @dev Burns a NFT.\r\n\t * @param _tokenId ID of the NFT to be burned.\r\n\t */\r\n\tfunction _burn(uint256 _tokenId) internal virtual override {\r\n\t\tsuper._burn(_tokenId);\r\n\r\n\t\tdelete idToUri[_tokenId];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice This is an internal function which should be called from user-implemented external\r\n\t * function. Its purpose is to show and properly initialize data structures when using this\r\n\t * implementation.\r\n\t * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\r\n\t * @param _tokenId Id for which we want URI.\r\n\t * @param _uri String representing RFC 3986 URI.\r\n\t */\r\n\tfunction _setTokenUri(uint256 _tokenId, string memory _uri)\r\n\t\tinternal\r\n\t\tvalidNFToken(_tokenId)\r\n\t{\r\n\t\tidToUri[_tokenId] = _uri;\r\n\t}\r\n}\r\n\r\n// File contracts/NFTokenMetadataEnumerable.sol\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\r\n */\r\nabstract contract NFTokenEnumerableMetadata is\r\n\tNFToken,\r\n\tERC721Metadata,\r\n\tERC721Enumerable\r\n{\r\n\t/**\r\n\t * @dev A descriptive name for a collection of NFTs.\r\n\t */\r\n\tstring internal nftName;\r\n\r\n\t/**\r\n\t * @dev An abbreviated name for NFTokens.\r\n\t */\r\n\tstring internal nftSymbol;\r\n\r\n\t/**\r\n\t * @dev Mapping from NFT ID to metadata uri.\r\n\t */\r\n\tmapping(uint256 => string) internal idToUri;\r\n\r\n\t/**\r\n\t * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\r\n\t * Based on 0xcert framework error codes.\r\n\t */\r\n\tstring constant INVALID_INDEX = '005007';\r\n\r\n\t/**\r\n\t * @dev Array of all NFT IDs.\r\n\t */\r\n\tuint256[] internal tokens;\r\n\r\n\t/**\r\n\t * @dev Mapping from token ID to its index in global tokens array.\r\n\t */\r\n\tmapping(uint256 => uint256) internal idToIndex;\r\n\r\n\t/**\r\n\t * @dev Mapping from owner to list of owned NFT IDs.\r\n\t */\r\n\tmapping(address => uint256[]) internal ownerToIds;\r\n\r\n\t/**\r\n\t * @dev Mapping from NFT ID to its index in the owner tokens list.\r\n\t */\r\n\tmapping(uint256 => uint256) internal idToOwnerIndex;\r\n\r\n\t/**\r\n\t * @notice When implementing this contract don't forget to set nftName and nftSymbol.\r\n\t * @dev Contract constructor.\r\n\t */\r\n\tconstructor() {\r\n\t\tsupportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n\t\tsupportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns a descriptive name for a collection of NFTokens.\r\n\t * @return _name Representing name.\r\n\t */\r\n\tfunction name() external view override returns (string memory _name) {\r\n\t\t_name = nftName;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns an abbreviated name for NFTokens.\r\n\t * @return _symbol Representing symbol.\r\n\t */\r\n\tfunction symbol() external view override returns (string memory _symbol) {\r\n\t\t_symbol = nftSymbol;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev A distinct URI (RFC 3986) for a given NFT.\r\n\t * @param _tokenId Id for which we want uri.\r\n\t * @return URI of _tokenId.\r\n\t */\r\n\tfunction tokenURI(uint256 _tokenId)\r\n\t\texternal\r\n\t\tview\r\n\t\toverride\r\n\t\tvalidNFToken(_tokenId)\r\n\t\treturns (string memory)\r\n\t{\r\n\t\treturn idToUri[_tokenId];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice This is an internal function which should be called from user-implemented external\r\n\t * function. Its purpose is to show and properly initialize data structures when using this\r\n\t * implementation.\r\n\t * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\r\n\t * @param _tokenId Id for which we want URI.\r\n\t * @param _uri String representing RFC 3986 URI.\r\n\t */\r\n\tfunction _setTokenUri(uint256 _tokenId, string memory _uri)\r\n\t\tinternal\r\n\t\tvalidNFToken(_tokenId)\r\n\t{\r\n\t\tidToUri[_tokenId] = _uri;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the count of all existing NFTokens.\r\n\t * @return Total supply of NFTs.\r\n\t */\r\n\tfunction totalSupply() external view override returns (uint256) {\r\n\t\treturn tokens.length;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns NFT ID by its index.\r\n\t * @param _index A counter less than `totalSupply()`.\r\n\t * @return Token id.\r\n\t */\r\n\tfunction tokenByIndex(uint256 _index)\r\n\t\texternal\r\n\t\tview\r\n\t\toverride\r\n\t\treturns (uint256)\r\n\t{\r\n\t\trequire(_index < tokens.length, INVALID_INDEX);\r\n\t\treturn tokens[_index];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev returns the n-th NFT ID from a list of owner's tokens.\r\n\t * @param _owner Token owner's address.\r\n\t * @param _index Index number representing n-th token in owner's list of tokens.\r\n\t * @return Token id.\r\n\t */\r\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n\t\texternal\r\n\t\tview\r\n\t\toverride\r\n\t\treturns (uint256)\r\n\t{\r\n\t\trequire(_index < ownerToIds[_owner].length, INVALID_INDEX);\r\n\t\treturn ownerToIds[_owner][_index];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice This is an internal function which should be called from user-implemented external\r\n\t * mint function. Its purpose is to show and properly initialize data structures when using this\r\n\t * implementation.\r\n\t * @dev Mints a new NFT.\r\n\t * @param _to The address that will own the minted NFT.\r\n\t * @param _tokenId of the NFT to be minted by the msg.sender.\r\n\t */\r\n\tfunction _mint(address _to, uint256 _tokenId) internal virtual override {\r\n\t\tsuper._mint(_to, _tokenId);\r\n\t\ttokens.push(_tokenId);\r\n\t\tidToIndex[_tokenId] = tokens.length - 1;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice This is an internal function which should be called from user-implemented external\r\n\t * burn function. Its purpose is to show and properly initialize data structures when using this\r\n\t * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\r\n\t * NFT.\r\n\t * @dev Burns a NFT.\r\n\t * @param _tokenId ID of the NFT to be burned.\r\n\t */\r\n\tfunction _burn(uint256 _tokenId) internal virtual override {\r\n\t\tsuper._burn(_tokenId);\r\n\r\n\t\tuint256 tokenIndex = idToIndex[_tokenId];\r\n\t\tuint256 lastTokenIndex = tokens.length - 1;\r\n\t\tuint256 lastToken = tokens[lastTokenIndex];\r\n\r\n\t\ttokens[tokenIndex] = lastToken;\r\n\r\n\t\ttokens.pop();\r\n\t\tdelete idToUri[_tokenId];\r\n\t\t// This wastes gas if you are burning the last token but saves a little gas if you are not.\r\n\t\tidToIndex[lastToken] = tokenIndex;\r\n\t\tidToIndex[_tokenId] = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n\t * @dev Removes a NFT from an address.\r\n\t * @param _from Address from wich we want to remove the NFT.\r\n\t * @param _tokenId Which NFT we want to remove.\r\n\t */\r\n\tfunction _removeNFToken(address _from, uint256 _tokenId)\r\n\t\tinternal\r\n\t\tvirtual\r\n\t\toverride\r\n\t{\r\n\t\trequire(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n\t\tdelete idToOwner[_tokenId];\r\n\r\n\t\tuint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n\t\tuint256 lastTokenIndex = ownerToIds[_from].length - 1;\r\n\r\n\t\tif (lastTokenIndex != tokenToRemoveIndex) {\r\n\t\t\tuint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n\t\t\townerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n\t\t\tidToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n\t\t}\r\n\r\n\t\townerToIds[_from].pop();\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n\t * @dev Assigns a new NFT to an address.\r\n\t * @param _to Address to wich we want to add the NFT.\r\n\t * @param _tokenId Which NFT we want to add.\r\n\t */\r\n\tfunction _addNFToken(address _to, uint256 _tokenId)\r\n\t\tinternal\r\n\t\tvirtual\r\n\t\toverride\r\n\t{\r\n\t\trequire(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\t\tidToOwner[_tokenId] = _to;\r\n\r\n\t\townerToIds[_to].push(_tokenId);\r\n\t\tidToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n\t * extension to remove double storage(gas optimization) of owner NFT count.\r\n\t * @param _owner Address for whom to query the count.\r\n\t * @return Number of _owner NFTs.\r\n\t */\r\n\tfunction _getOwnerNFTs(address _owner)\r\n\t\tinternal\r\n\t\tview\r\n\t\tvirtual\r\n\t\treturns (uint256[] memory)\r\n\t{\r\n\t\treturn ownerToIds[_owner];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n\t * extension to remove double storage(gas optimization) of owner NFT count.\r\n\t * @param _owner Address for whom to query the count.\r\n\t * @return Number of _owner NFTs.\r\n\t */\r\n\tfunction _getOwnerNFTCount(address _owner)\r\n\t\tinternal\r\n\t\tview\r\n\t\tvirtual\r\n\t\toverride\r\n\t\treturns (uint256)\r\n\t{\r\n\t\treturn ownerToIds[_owner].length;\r\n\t}\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.3.1pragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.1pragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(\r\n\t\taddress indexed previousOwner,\r\n\t\taddress indexed newOwner\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor() {\r\n\t\t_setOwner(_msgSender());\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view virtual returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(owner() == _msgSender(), 'Ownable: caller is not the owner');\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t *\r\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t * thereby removing any functionality that is only available to the owner.\r\n\t */\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\t_setOwner(address(0));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\trequire(\r\n\t\t\tnewOwner != address(0),\r\n\t\t\t'Ownable: new owner is the zero address'\r\n\t\t);\r\n\t\t_setOwner(newOwner);\r\n\t}\r\n\r\n\tfunction _setOwner(address newOwner) private {\r\n\t\taddress oldOwner = _owner;\r\n\t\t_owner = newOwner;\r\n\t\temit OwnershipTransferred(oldOwner, newOwner);\r\n\t}\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/math/SafeMath.sol@v4.3.1\r\n\r\npragma solidity 0.8.4; // CAUTION\r\n\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryAdd(uint256 a, uint256 b)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool, uint256)\r\n\t{\r\n\t\tunchecked {\r\n\t\t\tuint256 c = a + b;\r\n\t\t\tif (c < a) return (false, 0);\r\n\t\t\treturn (true, c);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction trySub(uint256 a, uint256 b)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool, uint256)\r\n\t{\r\n\t\tunchecked {\r\n\t\t\tif (b > a) return (false, 0);\r\n\t\t\treturn (true, a - b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryMul(uint256 a, uint256 b)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool, uint256)\r\n\t{\r\n\t\tunchecked {\r\n\t\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t\t// benefit is lost if 'b' is also tested.\r\n\t\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\t\t\tif (a == 0) return (true, 0);\r\n\t\t\tuint256 c = a * b;\r\n\t\t\tif (c / a != b) return (false, 0);\r\n\t\t\treturn (true, c);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryDiv(uint256 a, uint256 b)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool, uint256)\r\n\t{\r\n\t\tunchecked {\r\n\t\t\tif (b == 0) return (false, 0);\r\n\t\t\treturn (true, a / b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryMod(uint256 a, uint256 b)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool, uint256)\r\n\t{\r\n\t\tunchecked {\r\n\t\t\tif (b == 0) return (false, 0);\r\n\t\t\treturn (true, a % b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `+` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Addition cannot overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a + b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `*` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Multiplication cannot overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a * b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers, reverting on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * reverting when dividing by zero.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\t * message unnecessarily. For custom revert reasons use {trySub}.\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b <= a, errorMessage);\r\n\t\t\treturn a - b;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\t * uses an invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b > 0, errorMessage);\r\n\t\t\treturn a / b;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * reverting with custom message when dividing by zero.\r\n\t *\r\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\t * message unnecessarily. For custom revert reasons use {tryMod}.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b > 0, errorMessage);\r\n\t\t\treturn a % b;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File contracts/IReferral.sol\r\npragma solidity 0.8.4;\r\n\r\ninterface IReferral {\r\n\t/**\r\n\t * @dev Record referral.\r\n\t */\r\n\tfunction recordReferral(address user, address referrer) external;\r\n\r\n\t/**\r\n\t * @dev Record referral share.\r\n\t */\r\n\tfunction recordReferralShare(address referrer, uint256 share) external;\r\n\r\n\t/**\r\n\t * @dev Get the referrer address that referred the user.\r\n\t */\r\n\tfunction getReferrer(address user) external view returns (address);\r\n}\r\n\r\ninterface IErc20 {\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function transferFrom(address owner, address buyer, uint256 numTokens) external returns (bool);\r\n}\r\n\r\n// File contracts/Nfts.sol\r\npragma solidity 0.8.4;\r\n\r\ncontract Cyber_Fox is NFTokenEnumerableMetadata, Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 public price = 0 ether;\r\n\tuint256 public maxSupply = 100000000000000;\r\n\tstring public baseUri = 'https://onlyfun.city/nft/';\r\n\tuint16 public refShare = 500; // in basis points, so it's 10%\r\n\tuint256 public startTime = 0;\r\n\tuint256 public premint = 0;\r\n\tIReferral public referralContract;\r\n\r\n\tevent PriceUpdated(uint256 newPrice);\r\n\tevent MaxSupplyUpdated(uint256 newMaxSupply);\r\n\tevent BaseUriUpdated(string newBaseUri);\r\n\tevent ReferralSharePaid(\r\n\t\taddress indexed user,\r\n\t\taddress indexed referrer,\r\n\t\tuint256 shareAmount\r\n\t);\r\n\r\n\tconstructor() {\r\n\t\tnftName = 'Cyber Fox';\r\n\t\tnftSymbol = 'Cyber Fox';\r\n\t\t\r\n\t\tfor (uint i = 0; i < premint; i++) {\r\n    \t\tsuper._mint(msg.sender, i);\r\n    \t\tsuper._setTokenUri(\r\n    \t\t\ti,\r\n    \t\t\tstring(abi.encodePacked(baseUri, toString(i)))\r\n    \t\t);\r\n\t\t}\r\n\t}\r\n\r\n   function mint(address _to, uint256 _tokenId, string calldata _uri) external onlyOwner {\r\n    require(_to != address(0), \"ERC721: mint to the zero address\");\r\n    super._mint(_to, _tokenId);\r\n    super._setTokenUri(_tokenId, _uri);\r\n  }\r\n\r\n\t\r\n\r\n\tfunction getOwnerNFTs(address _owner)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256[] memory)\r\n\t{\r\n\t\treturn super._getOwnerNFTs(_owner);\r\n\t}\r\n\r\n\tfunction withdraw() external onlyOwner {\r\n\t\tpayable(msg.sender).transfer(address(this).balance);\r\n\t}\r\n\r\n\tfunction updatePrice(uint256 _newPrice) public onlyOwner {\r\n\t\tprice = _newPrice;\r\n\t\temit PriceUpdated(_newPrice);\r\n\t}\r\n\r\n\tfunction updateMaxSupply(uint256 _maxSupply) public onlyOwner {\r\n\t\tmaxSupply = _maxSupply;\r\n\t\temit MaxSupplyUpdated(_maxSupply);\r\n\t}\r\n\r\n\tfunction updateBaseUri(string memory _baseUri) public onlyOwner {\r\n\t\tbaseUri = _baseUri;\r\n\t\temit BaseUriUpdated(_baseUri);\r\n\t}\r\n\r\n\t// Update the referral contract address by the owner\r\n\tfunction setReferralAddress(IReferral _referralAddress) public onlyOwner {\r\n\t\treferralContract = _referralAddress;\r\n\t}\r\n\r\n\t// Update referral share rate by the owner\r\n\tfunction setRefShare(uint16 _refShare) public onlyOwner {\r\n\t\trefShare = _refShare;\r\n\t}\r\n\r\n\t// Pay referral share to the referrer who referred this user.\r\n\tfunction payReferral(address _to, uint256 _amount) internal {\r\n\t\tif (address(referralContract) != address(0) && refShare > 0) {\r\n\t\t\taddress referrer = referralContract.getReferrer(_to);\r\n\t\t\tuint256 shareAmount = _amount.mul(refShare).div(10000);\r\n\r\n\t\t\tif (referrer != address(0) && shareAmount > 0) {\r\n\t\t\t\tpayable(referrer).transfer(shareAmount);\r\n\r\n\t\t\t\treferralContract.recordReferralShare(referrer, shareAmount);\r\n\t\t\t\temit ReferralSharePaid(_to, referrer, shareAmount);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction toString(uint256 value) internal pure returns (string memory) {\r\n\t\t// Inspired by OraclizeAPI's implementation - MIT license\r\n\t\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\t\tif (value == 0) {\r\n\t\t\treturn '0';\r\n\t\t}\r\n\t\tuint256 temp = value;\r\n\t\tuint256 digits;\r\n\t\twhile (temp != 0) {\r\n\t\t\tdigits++;\r\n\t\t\ttemp /= 10;\r\n\t\t}\r\n\t\tbytes memory buffer = new bytes(digits);\r\n\t\twhile (value != 0) {\r\n\t\t\tdigits -= 1;\r\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n\t\t\tvalue /= 10;\r\n\t\t}\r\n\t\treturn string(buffer);\r\n\t}\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.3.1pragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n\t/**\r\n\t * @dev Returns the amount of tokens in existence.\r\n\t */\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the amount of tokens owned by `account`.\r\n\t */\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transfer(address recipient, uint256 amount)\r\n\t\texternal\r\n\t\treturns (bool);\r\n\r\n\t/**\r\n\t * @dev Returns the remaining number of tokens that `spender` will be\r\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n\t * zero by default.\r\n\t *\r\n\t * This value changes when {approve} or {transferFrom} are called.\r\n\t */\r\n\tfunction allowance(address owner, address spender)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\t/**\r\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n\t * that someone may use both the old and the new allowance by unfortunate\r\n\t * transaction ordering. One possible solution to mitigate this race\r\n\t * condition is to first reduce the spender's allowance to 0 and set the\r\n\t * desired value afterwards:\r\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t *\r\n\t * Emits an {Approval} event.\r\n\t */\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n\t * allowance mechanism. `amount` is then deducted from the caller's\r\n\t * allowance.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n\t * another (`to`).\r\n\t *\r\n\t * Note that `value` may be zero.\r\n\t */\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n\t * a call to {approve}. `value` is the new allowance.\r\n\t */\r\n\tevent Approval(\r\n\t\taddress indexed owner,\r\n\t\taddress indexed spender,\r\n\t\tuint256 value\r\n\t);\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.3.1pragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n\t/**\r\n\t * @dev Returns true if `account` is a contract.\r\n\t *\r\n\t * [IMPORTANT]\r\n\t * ====\r\n\t * It is unsafe to assume that an address for which this function returns\r\n\t * false is an externally-owned account (EOA) and not a contract.\r\n\t *\r\n\t * Among others, `isContract` will return false for the following\r\n\t * types of addresses:\r\n\t *\r\n\t *  - an externally-owned account\r\n\t *  - a contract in construction\r\n\t *  - an address where a contract will be created\r\n\t *  - an address where a contract lived, but was destroyed\r\n\t * ====\r\n\t */\r\n\tfunction isContract(address account) internal view returns (bool) {\r\n\t\t// This method relies on extcodesize, which returns 0 for contracts in\r\n\t\t// construction, since the code is only stored at the end of the\r\n\t\t// constructor execution.\r\n\r\n\t\tuint256 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(account)\r\n\t\t}\r\n\t\treturn size > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n\t * `recipient`, forwarding all available gas and reverting on errors.\r\n\t *\r\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n\t * imposed by `transfer`, making them unable to receive funds via\r\n\t * `transfer`. {sendValue} removes this limitation.\r\n\t *\r\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n\t *\r\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\r\n\t * taken to not create reentrancy vulnerabilities. Consider using\r\n\t * {ReentrancyGuard} or the\r\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n\t */\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(\r\n\t\t\taddress(this).balance >= amount,\r\n\t\t\t'Address: insufficient balance'\r\n\t\t);\r\n\r\n\t\t(bool success, ) = recipient.call{value: amount}('');\r\n\t\trequire(\r\n\t\t\tsuccess,\r\n\t\t\t'Address: unable to send value, recipient may have reverted'\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Performs a Solidity function call using a low level `call`. A\r\n\t * plain `call` is an unsafe replacement for a function call: use this\r\n\t * function instead.\r\n\t *\r\n\t * If `target` reverts with a revert reason, it is bubbled up by this\r\n\t * function (like regular Solidity function calls).\r\n\t *\r\n\t * Returns the raw returned data. To convert to the expected return value,\r\n\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `target` must be a contract.\r\n\t * - calling `target` with `data` must not revert.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(address target, bytes memory data)\r\n\t\tinternal\r\n\t\treturns (bytes memory)\r\n\t{\r\n\t\treturn functionCall(target, data, 'Address: low-level call failed');\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n\t * `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but also transferring `value` wei to `target`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the calling contract must have an ETH balance of at least `value`.\r\n\t * - the called Solidity function must be `payable`.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value\r\n\t) internal returns (bytes memory) {\r\n\t\treturn\r\n\t\t\tfunctionCallWithValue(\r\n\t\t\t\ttarget,\r\n\t\t\t\tdata,\r\n\t\t\t\tvalue,\r\n\t\t\t\t'Address: low-level call with value failed'\r\n\t\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n\t * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(\r\n\t\t\taddress(this).balance >= value,\r\n\t\t\t'Address: insufficient balance for call'\r\n\t\t);\r\n\t\trequire(isContract(target), 'Address: call to non-contract');\r\n\r\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(\r\n\t\t\tdata\r\n\t\t);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(address target, bytes memory data)\r\n\t\tinternal\r\n\t\tview\r\n\t\treturns (bytes memory)\r\n\t{\r\n\t\treturn\r\n\t\t\tfunctionStaticCall(\r\n\t\t\t\ttarget,\r\n\t\t\t\tdata,\r\n\t\t\t\t'Address: low-level static call failed'\r\n\t\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal view returns (bytes memory) {\r\n\t\trequire(isContract(target), 'Address: static call to non-contract');\r\n\r\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(address target, bytes memory data)\r\n\t\tinternal\r\n\t\treturns (bytes memory)\r\n\t{\r\n\t\treturn\r\n\t\t\tfunctionDelegateCall(\r\n\t\t\t\ttarget,\r\n\t\t\t\tdata,\r\n\t\t\t\t'Address: low-level delegate call failed'\r\n\t\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(isContract(target), 'Address: delegate call to non-contract');\r\n\r\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n\t * revert reason using the provided one.\r\n\t *\r\n\t * _Available since v4.3._\r\n\t */\r\n\tfunction verifyCallResult(\r\n\t\tbool success,\r\n\t\tbytes memory returndata,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (bytes memory) {\r\n\t\tif (success) {\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\t// Look for revert reason and bubble it up if present\r\n\t\t\tif (returndata.length > 0) {\r\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\trevert(errorMessage);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol@v4.3.1\r\n\r\npragma solidity 0.8.4;\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\n\r\nlibrary SafeERC20 {\r\n\tusing Address for address;\r\n\r\n\tfunction safeTransfer(\r\n\t\tIERC20 token,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\t_callOptionalReturn(\r\n\t\t\ttoken,\r\n\t\t\tabi.encodeWithSelector(token.transfer.selector, to, value)\r\n\t\t);\r\n\t}\r\n\r\n\tfunction safeTransferFrom(\r\n\t\tIERC20 token,\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\t_callOptionalReturn(\r\n\t\t\ttoken,\r\n\t\t\tabi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Deprecated. This function has issues similar to the ones found in\r\n\t * {IERC20-approve}, and its usage is discouraged.\r\n\t *\r\n\t * Whenever possible, use {safeIncreaseAllowance} and\r\n\t * {safeDecreaseAllowance} instead.\r\n\t */\r\n\tfunction safeApprove(\r\n\t\tIERC20 token,\r\n\t\taddress spender,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\t// safeApprove should only be called when setting an initial allowance,\r\n\t\t// or when resetting it to zero. To increase and decrease it, use\r\n\t\t// 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n\t\trequire(\r\n\t\t\t(value == 0) || (token.allowance(address(this), spender) == 0),\r\n\t\t\t'SafeERC20: approve from non-zero to non-zero allowance'\r\n\t\t);\r\n\t\t_callOptionalReturn(\r\n\t\t\ttoken,\r\n\t\t\tabi.encodeWithSelector(token.approve.selector, spender, value)\r\n\t\t);\r\n\t}\r\n\r\n\tfunction safeIncreaseAllowance(\r\n\t\tIERC20 token,\r\n\t\taddress spender,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\tuint256 newAllowance = token.allowance(address(this), spender) + value;\r\n\t\t_callOptionalReturn(\r\n\t\t\ttoken,\r\n\t\t\tabi.encodeWithSelector(\r\n\t\t\t\ttoken.approve.selector,\r\n\t\t\t\tspender,\r\n\t\t\t\tnewAllowance\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tfunction safeDecreaseAllowance(\r\n\t\tIERC20 token,\r\n\t\taddress spender,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\tunchecked {\r\n\t\t\tuint256 oldAllowance = token.allowance(address(this), spender);\r\n\t\t\trequire(\r\n\t\t\t\toldAllowance >= value,\r\n\t\t\t\t'SafeERC20: decreased allowance below zero'\r\n\t\t\t);\r\n\t\t\tuint256 newAllowance = oldAllowance - value;\r\n\t\t\t_callOptionalReturn(\r\n\t\t\t\ttoken,\r\n\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\ttoken.approve.selector,\r\n\t\t\t\t\tspender,\r\n\t\t\t\t\tnewAllowance\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n\t * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n\t * @param token The token targeted by the call.\r\n\t * @param data The call data (encoded using abi.encode or one of its variants).\r\n\t */\r\n\tfunction _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n\t\t// we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n\t\t// the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n\t\tbytes memory returndata = address(token).functionCall(\r\n\t\t\tdata,\r\n\t\t\t'SafeERC20: low-level call failed'\r\n\t\t);\r\n\t\tif (returndata.length > 0) {\r\n\t\t\t// Return data is optional\r\n\t\t\trequire(\r\n\t\t\t\tabi.decode(returndata, (bool)),\r\n\t\t\t\t'SafeERC20: ERC20 operation did not succeed'\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File contracts/Referral.solpragma solidity 0.8.4;\r\n\r\ncontract Referral is IReferral, Ownable {\r\n\tusing SafeERC20 for IERC20;\r\n\r\n\tmapping(address => bool) public operators;\r\n\tmapping(address => address) public referrers; // user address => referrer address\r\n\tmapping(address => uint256) public referralsCount; // referrer address => referrals count\r\n\tmapping(address => uint256) public totalReferralShares; // referrer address => total referral commissions\r\n\r\n\tevent ReferralRecorded(address indexed user, address indexed referrer);\r\n\tevent ReferralShareRecorded(address indexed referrer, uint256 commission);\r\n\tevent OperatorUpdated(address indexed operator, bool indexed status);\r\n\r\n\tmodifier onlyOperator() {\r\n\t\trequire(operators[msg.sender], 'Operator: caller is not the operator');\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction recordReferral(address _user, address _referrer)\r\n\t\tpublic\r\n\t\toverride\r\n\t\tonlyOperator\r\n\t{\r\n\t\tif (\r\n\t\t\t_user != address(0) &&\r\n\t\t\t_referrer != address(0) &&\r\n\t\t\t_user != _referrer &&\r\n\t\t\treferrers[_user] == address(0)\r\n\t\t) {\r\n\t\t\treferrers[_user] = _referrer;\r\n\t\t\treferralsCount[_referrer] += 1;\r\n\t\t\temit ReferralRecorded(_user, _referrer);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction recordReferralShare(address _referrer, uint256 _share)\r\n\t\tpublic\r\n\t\toverride\r\n\t\tonlyOperator\r\n\t{\r\n\t\tif (_referrer != address(0) && _share > 0) {\r\n\t\t\ttotalReferralShares[_referrer] += _share;\r\n\t\t\temit ReferralShareRecorded(_referrer, _share);\r\n\t\t}\r\n\t}\r\n\r\n\t// Get the referrer address that referred the user\r\n\tfunction getReferrer(address _user) public view override returns (address) {\r\n\t\treturn referrers[_user];\r\n\t}\r\n\r\n\t// Update the status of the operator\r\n\tfunction updateOperator(address _operator, bool _status)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t{\r\n\t\toperators[_operator] = _status;\r\n\t\temit OperatorUpdated(_operator, _status);\r\n\t}\r\n\r\n\tfunction transferTokens(\r\n\t\tIERC20 _token,\r\n\t\tuint256 _amount,\r\n\t\taddress _to\r\n\t) external onlyOwner {\r\n\t\t_token.safeTransfer(_to, _amount);\r\n\t}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newBaseUri\",\"type\":\"string\"}],\"name\":\"BaseUriUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxSupply\",\"type\":\"uint256\"}],\"name\":\"MaxSupplyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareAmount\",\"type\":\"uint256\"}],\"name\":\"ReferralSharePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getOwnerNFTs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"premint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refShare\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralContract\",\"outputs\":[{\"internalType\":\"contract IReferral\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_refShare\",\"type\":\"uint16\"}],\"name\":\"setRefShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IReferral\",\"name\":\"_referralAddress\",\"type\":\"address\"}],\"name\":\"setReferralAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseUri\",\"type\":\"string\"}],\"name\":\"updateBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"}],\"name\":\"updateMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Cyber_Fox", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://220631cc9b7c1624799582b192b77afe4760295621cb8732a7cc5fb5771ac755"}