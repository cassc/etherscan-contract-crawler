{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dripCustom/fountain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address public owner;\\n\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n}\\n\\n// File: openzeppelin-solidity/contracts/ownership/Whitelist.sol\\n\\n/**\\n * @title Whitelist\\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\\n * @dev This simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Whitelist is Ownable {\\n    mapping(address => bool) public whitelist;\\n\\n    event WhitelistedAddressAdded(address addr);\\n    event WhitelistedAddressRemoved(address addr);\\n\\n    /**\\n     * @dev Throws if called by any account that's not whitelisted.\\n     */\\n    modifier onlyWhitelisted() {\\n        require(whitelist[msg.sender], 'no whitelist');\\n        _;\\n    }\\n\\n    /**\\n     * @dev add an address to the whitelist\\n     * @param addr address\\n     */\\n    function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\\n        if (!whitelist[addr]) {\\n            whitelist[addr] = true;\\n            emit WhitelistedAddressAdded(addr);\\n            success = true;\\n        }\\n    }\\n\\n    /**\\n     * @dev add addresses to the whitelist\\n     * @param addrs addresses\\n     */\\n    function addAddressesToWhitelist(address[] memory addrs) onlyOwner public returns(bool success) {\\n        for (uint256 i = 0; i < addrs.length; i++) {\\n            if (addAddressToWhitelist(addrs[i])) {\\n                success = true;\\n            }\\n        }\\n        return success;\\n    }\\n\\n    /**\\n     * @dev remove an address from the whitelist\\n     * @param addr address\\n     */\\n    function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\\n        if (whitelist[addr]) {\\n            whitelist[addr] = false;\\n            emit WhitelistedAddressRemoved(addr);\\n            success = true;\\n        }\\n        return success;\\n    }\\n\\n    /**\\n     * @dev remove addresses from the whitelist\\n     * @param addrs addresses\\n     */\\n    function removeAddressesFromWhitelist(address[] memory addrs) onlyOwner public returns(bool success) {\\n        for (uint256 i = 0; i < addrs.length; i++) {\\n            if (removeAddressFromWhitelist(addrs[i])) {\\n                success = true;\\n            }\\n        }\\n        return success;\\n    }\\n\\n}\\n\\n/**\\n * @title Standard BEP20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://eips.ethereum.org/EIPS/eip-20\\n * Originally based on code by FirstBlood:\\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n *\\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\\n * compliant implementations may not do it.\\n */\\ncontract BEP20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) internal _balances;\\n    mapping (address => mapping (address => uint256)) internal _allowed;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    uint256 internal _totalSupply;\\n\\n    /**\\n      * @dev Total number of tokens in existence\\n      */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n      * @dev Gets the balance of the specified address.\\n      * @param owner The address to query the balance of.\\n      * @return A uint256 representing the amount owned by the passed address.\\n      */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /**\\n      * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n      * @param owner address The address which owns the funds.\\n      * @param spender address The address which will spend the funds.\\n      * @return A uint256 specifying the amount of tokens still available for the spender.\\n      */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    /**\\n      * @dev Transfer token to a specified address\\n      * @param to The address to transfer to.\\n      * @param value The amount to be transferred.\\n      */\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n      * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n      * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n      * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n      * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n      * @param spender The address which will spend the funds.\\n      * @param value The amount of tokens to be spent.\\n      */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n      * @dev Transfer tokens from one address to another.\\n      * Note that while this function emits an Approval event, this is not required as per the specification,\\n      * and other compliant implementations may not emit the event.\\n      * @param from address The address which you want to send tokens from\\n      * @param to address The address which you want to transfer to\\n      * @param value uint256 the amount of tokens to be transferred\\n      */\\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\\n        return true;\\n    }\\n\\n    /**\\n      * @dev Increase the amount of tokens that an owner allowed to a spender.\\n      * approve should be called when _allowed[msg.sender][spender] == 0. To increment\\n      * allowed value is better to use this function to avoid 2 calls (and wait until\\n      * the first transaction is mined)\\n      * From MonolithDAO Token.sol\\n      * Emits an Approval event.\\n      * @param spender The address which will spend the funds.\\n      * @param addedValue The amount of tokens to increase the allowance by.\\n      */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n      * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n      * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\\n      * allowed value is better to use this function to avoid 2 calls (and wait until\\n      * the first transaction is mined)\\n      * From MonolithDAO Token.sol\\n      * Emits an Approval event.\\n      * @param spender The address which will spend the funds.\\n      * @param subtractedValue The amount of tokens to decrease the allowance by.\\n      */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n      * @dev Transfer token for a specified addresses\\n      * @param from The address to transfer from.\\n      * @param to The address to transfer to.\\n      * @param value The amount to be transferred.\\n      */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n      * @dev Internal function that mints an amount of the token and assigns it to\\n      * an account. This encapsulates the modification of balances such that the\\n      * proper events are emitted.\\n      * @param account The account that will receive the created tokens.\\n      * @param value The amount that will be created.\\n      */\\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    /**\\n      * @dev Internal function that burns an amount of the token of a given\\n      * account.\\n      * @param account The account whose tokens will be burnt.\\n      * @param value The amount that will be burnt.\\n      */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n      * @dev Approve an address to spend another addresses' tokens.\\n      * @param owner The address that owns the tokens.\\n      * @param spender The address that will spend the tokens.\\n      * @param value The number of tokens that can be spent.\\n      */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(spender != address(0));\\n        require(owner != address(0));\\n\\n        _allowed[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n      * @dev Internal function that burns an amount of the token of a given\\n      * account, deducting from the sender's allowance for said account. Uses the\\n      * internal burn function.\\n      * Emits an Approval event (reflecting the reduced allowance).\\n      * @param account The account whose tokens will be burnt.\\n      * @param value The amount that will be burnt.\\n      */\\n    function _burnFrom(address account, uint256 value) internal {\\n        _burn(account, value);\\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\\n    }\\n}\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return a / b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    /* @dev Subtracts two numbers, else returns zero */\\n    function safeSub(uint a, uint b) internal pure returns (uint) {\\n        if (b > a) {\\n            return 0;\\n        } else {\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\\ninterface IToken {\\n    function calculateTransferTaxes(address _from, uint256 _value) external view returns (uint256 adjustedValue, uint256 taxAmount);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function burn(uint256 _value) external;\\n}\\n\\ncontract Fountain is BEP20, Whitelist {\\n\\n    string public constant name = \\\"DRIP Liquidity Token\\\";\\n    string public constant symbol = \\\"DROPS\\\";\\n    uint8 public constant decimals = 18;\\n\\n    /***********************************|\\n    |        Variables && Events        |\\n    |__________________________________*/\\n\\n    // Variables\\n    IToken internal token; // address of the BEP20 token traded on this contract\\n    uint256 public totalTxs;\\n\\n    uint256 internal lastBalance_;\\n    uint256 internal trackingInterval_ = 1 minutes;\\n    uint256 public providers;\\n\\n    mapping (address => bool) internal _providers;\\n    mapping (address => uint256) internal _txs;\\n\\n    bool public isPaused = true;\\n\\n    // Events\\n    event onTokenPurchase(address indexed buyer, uint256 indexed bnb_amount, uint256 indexed token_amount);\\n    event onBnbPurchase(address indexed buyer, uint256 indexed token_amount, uint256 indexed bnb_amount);\\n    event onAddLiquidity(address indexed provider, uint256 indexed bnb_amount, uint256 indexed token_amount);\\n    event onRemoveLiquidity(address indexed provider, uint256 indexed bnb_amount, uint256 indexed token_amount);\\n    event onLiquidity(address indexed provider, uint256 indexed amount);\\n    event onContractBalance(uint256 balance);\\n    event onPrice(uint256 price);\\n    event onSummary(uint256 liquidity, uint256 price);\\n\\n\\n    /***********************************|\\n    |            Constructor            |\\n    |__________________________________*/\\n    constructor (address token_addr) Ownable() public {\\n        token = IToken(token_addr);\\n        lastBalance_= now;\\n    }\\n\\n    function unpause() public onlyOwner {\\n        isPaused = false;\\n    }\\n\\n    function pause() public onlyOwner {\\n        isPaused = true;\\n    }\\n\\n    modifier isNotPaused() {\\n        require(!isPaused, \\\"Swaps currently paused\\\");\\n        _;\\n    }\\n\\n\\n    /***********************************|\\n    |        Exchange Functions         |\\n    |__________________________________*/\\n\\n\\n    /**\\n     * @notice Convert BNB to Tokens.\\n     * @dev User specifies exact input (msg.value).\\n     */\\n    receive() external payable {\\n        bnbToTokenInput(msg.value, 1, msg.sender, msg.sender);\\n    }\\n\\n    /**\\n      * @dev Pricing function for converting between BNB && Tokens.\\n      * @param input_amount Amount of BNB or Tokens being sold.\\n      * @param input_reserve Amount of BNB or Tokens (input type) in exchange reserves.\\n      * @param output_reserve Amount of BNB or Tokens (output type) in exchange reserves.\\n      * @return Amount of BNB or Tokens bought.\\n      */\\n    function getInputPrice(uint256 input_amount, uint256 input_reserve, uint256 output_reserve)  public view returns (uint256) {\\n        require(input_reserve > 0 && output_reserve > 0, \\\"INVALID_VALUE\\\");\\n        uint256 input_amount_with_fee = input_amount.mul(990);\\n        uint256 numerator = input_amount_with_fee.mul(output_reserve);\\n        uint256 denominator = input_reserve.mul(1000).add(input_amount_with_fee);\\n        return numerator / denominator;\\n    }\\n\\n    /**\\n      * @dev Pricing function for converting between BNB && Tokens.\\n      * @param output_amount Amount of BNB or Tokens being bought.\\n      * @param input_reserve Amount of BNB or Tokens (input type) in exchange reserves.\\n      * @param output_reserve Amount of BNB or Tokens (output type) in exchange reserves.\\n      * @return Amount of BNB or Tokens sold.\\n      */\\n    function getOutputPrice(uint256 output_amount, uint256 input_reserve, uint256 output_reserve)  public view returns (uint256) {\\n        require(input_reserve > 0 && output_reserve > 0);\\n        uint256 numerator = input_reserve.mul(output_amount).mul(1000);\\n        uint256 denominator = (output_reserve.sub(output_amount)).mul(990);\\n        return (numerator / denominator).add(1);\\n    }\\n\\n    function bnbToTokenInput(uint256 bnb_sold, uint256 min_tokens, address buyer, address recipient) private returns (uint256) {\\n        require(bnb_sold > 0 && min_tokens > 0, \\\"sold and min 0\\\");\\n\\n        uint256 token_reserve = token.balanceOf(address(this));\\n        uint256 tokens_bought = getInputPrice(bnb_sold, address(this).balance.sub(bnb_sold), token_reserve);\\n\\n        require(tokens_bought >= min_tokens, \\\"tokens_bought >= min_tokens\\\");\\n        require(token.transfer(recipient, tokens_bought), \\\"transfer err\\\");\\n\\n        emit onTokenPurchase(buyer, bnb_sold, tokens_bought);\\n        emit onContractBalance(bnbBalance());\\n\\n        trackGlobalStats();\\n\\n        return tokens_bought;\\n    }\\n\\n    /**\\n     * @notice Convert BNB to Tokens.\\n     * @dev User specifies exact input (msg.value) && minimum output.\\n     * @param min_tokens Minimum Tokens bought.\\n     * @return Amount of Tokens bought.\\n     */\\n    function bnbToTokenSwapInput(uint256 min_tokens) public payable isNotPaused returns (uint256) {\\n        return bnbToTokenInput(msg.value, min_tokens,msg.sender, msg.sender);\\n    }\\n\\n    function bnbToTokenOutput(uint256 tokens_bought, uint256 max_bnb, address buyer, address recipient) private returns (uint256) {\\n        require(tokens_bought > 0 && max_bnb > 0);\\n        uint256 token_reserve = token.balanceOf(address(this));\\n        uint256 bnb_sold = getOutputPrice(tokens_bought, address(this).balance.sub(max_bnb), token_reserve);\\n        // Throws if bnb_sold > max_bnb\\n        uint256 bnb_refund = max_bnb.sub(bnb_sold);\\n        if (bnb_refund > 0) {\\n            payable(buyer).transfer(bnb_refund);\\n        }\\n        require(token.transfer(recipient, tokens_bought));\\n        emit onTokenPurchase(buyer, bnb_sold, tokens_bought);\\n        trackGlobalStats();\\n        return bnb_sold;\\n    }\\n\\n    /**\\n     * @notice Convert BNB to Tokens.\\n     * @dev User specifies maximum input (msg.value) && exact output.\\n     * @param tokens_bought Amount of tokens bought.\\n     * @return Amount of BNB sold.\\n     */\\n    function bnbToTokenSwapOutput(uint256 tokens_bought) public payable isNotPaused returns (uint256) {\\n        return bnbToTokenOutput(tokens_bought, msg.value, msg.sender, msg.sender);\\n    }\\n\\n    function tokenToBnbInput(uint256 tokens_sold, uint256 min_bnb, address buyer, address recipient) private returns (uint256) {\\n        require(tokens_sold > 0 && min_bnb > 0);\\n        uint256 token_reserve = token.balanceOf(address(this));\\n\\n        (uint256 realized_sold, uint256 taxAmount) = token.calculateTransferTaxes(buyer, tokens_sold);\\n\\n        uint256 bnb_bought = getInputPrice(realized_sold, token_reserve, address(this).balance);\\n        require(bnb_bought >= min_bnb);\\n        payable(recipient).transfer(bnb_bought);\\n        require(token.transferFrom(buyer, address(this), tokens_sold));\\n        emit onBnbPurchase(buyer, tokens_sold, bnb_bought);\\n        trackGlobalStats();\\n        return bnb_bought;\\n    }\\n\\n    /**\\n     * @notice Convert Tokens to BNB.\\n     * @dev User specifies exact input && minimum output.\\n     * @param tokens_sold Amount of Tokens sold.\\n     * @param min_bnb Minimum BNB purchased.\\n     * @return Amount of BNB bought.\\n     */\\n    function tokenToBnbSwapInput(uint256 tokens_sold, uint256 min_bnb) public isNotPaused returns (uint256) {\\n        return tokenToBnbInput(tokens_sold, min_bnb, msg.sender, msg.sender);\\n    }\\n\\n    function tokenToBnbOutput(uint256 bnb_bought, uint256 max_tokens, address buyer, address recipient) private returns (uint256) {\\n        require(bnb_bought > 0);\\n        uint256 token_reserve = token.balanceOf(address(this));\\n        uint256 tokens_sold = getOutputPrice(bnb_bought, token_reserve, address(this).balance);\\n\\n        (uint256 realized_sold, uint256 taxAmount) = token.calculateTransferTaxes(buyer, tokens_sold);\\n        tokens_sold += taxAmount;\\n\\n        // tokens sold is always > 0\\n        require(max_tokens >= tokens_sold, 'max tokens exceeded');\\n        payable(recipient).transfer(bnb_bought);\\n        require(token.transferFrom(buyer, address(this), tokens_sold));\\n        emit onBnbPurchase(buyer, tokens_sold, bnb_bought);\\n        trackGlobalStats();\\n\\n        return tokens_sold;\\n    }\\n\\n    /**\\n     * @notice Convert Tokens to BNB.\\n     * @dev User specifies maximum input && exact output.\\n     * @param bnb_bought Amount of BNB purchased.\\n     * @param max_tokens Maximum Tokens sold.\\n     * @return Amount of Tokens sold.\\n     */\\n    function tokenToBnbSwapOutput(uint256 bnb_bought, uint256 max_tokens) public isNotPaused returns (uint256) {\\n        return tokenToBnbOutput(bnb_bought, max_tokens, msg.sender, msg.sender);\\n    }\\n\\n    function trackGlobalStats() private {\\n\\n        uint256 price = getBnbToTokenOutputPrice(1e18);\\n        uint256 balance = bnbBalance();\\n\\n        if (now.safeSub(lastBalance_) > trackingInterval_) {\\n\\n            emit onSummary(balance * 2, price);\\n            lastBalance_ = now;\\n        }\\n\\n        emit onContractBalance(balance);\\n        emit onPrice(price);\\n\\n        totalTxs += 1;\\n        _txs[msg.sender] += 1;\\n    }\\n\\n\\n    /***********************************|\\n    |         Getter Functions          |\\n    |__________________________________*/\\n\\n    /**\\n     * @notice Public price function for BNB to Token trades with an exact input.\\n     * @param bnb_sold Amount of BNB sold.\\n     * @return Amount of Tokens that can be bought with input BNB.\\n     */\\n    function getBnbToTokenInputPrice(uint256 bnb_sold) public view returns (uint256) {\\n        require(bnb_sold > 0);\\n        uint256 token_reserve = token.balanceOf(address(this));\\n        return getInputPrice(bnb_sold, address(this).balance, token_reserve);\\n    }\\n\\n    /**\\n     * @notice Public price function for BNB to Token trades with an exact output.\\n     * @param tokens_bought Amount of Tokens bought.\\n     * @return Amount of BNB needed to buy output Tokens.\\n     */\\n    function getBnbToTokenOutputPrice(uint256 tokens_bought) public view returns (uint256) {\\n        require(tokens_bought > 0);\\n        uint256 token_reserve = token.balanceOf(address(this));\\n        uint256 bnb_sold = getOutputPrice(tokens_bought, address(this).balance, token_reserve);\\n        return bnb_sold;\\n    }\\n\\n    /**\\n     * @notice Public price function for Token to BNB trades with an exact input.\\n     * @param tokens_sold Amount of Tokens sold.\\n     * @return Amount of BNB that can be bought with input Tokens.\\n     */\\n    function getTokenToBnbInputPrice(uint256 tokens_sold) public view returns (uint256) {\\n        require(tokens_sold > 0, \\\"token sold < 0\\\");\\n        uint256 token_reserve = token.balanceOf(address(this));\\n        uint256 bnb_bought = getInputPrice(tokens_sold, token_reserve, address(this).balance);\\n        return bnb_bought;\\n    }\\n\\n    /**\\n     * @notice Public price function for Token to BNB trades with an exact output.\\n     * @param bnb_bought Amount of output BNB.\\n     * @return Amount of Tokens needed to buy output BNB.\\n     */\\n    function getTokenToBnbOutputPrice(uint256 bnb_bought) public view returns (uint256) {\\n        require(bnb_bought > 0);\\n        uint256 token_reserve = token.balanceOf(address(this));\\n        return getOutputPrice(bnb_bought, token_reserve, address(this).balance);\\n    }\\n\\n    /**\\n     * @return Address of Token that is sold on this exchange.\\n     */\\n    function tokenAddress() public view returns (address) {\\n        return address(token);\\n    }\\n\\n    function bnbBalance() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    function tokenBalance() public view returns (uint256) {\\n        return token.balanceOf(address(this));\\n    }\\n\\n    function getBnbToLiquidityInputPrice(uint256 bnb_sold) public view returns (uint256){\\n        require(bnb_sold > 0);\\n        uint256 token_amount = 0;\\n        uint256 total_liquidity = _totalSupply;\\n        uint256 bnb_reserve = address(this).balance;\\n        uint256 token_reserve = token.balanceOf(address(this));\\n        token_amount = (bnb_sold.mul(token_reserve) / bnb_reserve).add(1);\\n        uint256 liquidity_minted = bnb_sold.mul(total_liquidity) / bnb_reserve;\\n\\n        return liquidity_minted;\\n    }\\n\\n    function getLiquidityToReserveInputPrice(uint amount) public view returns (uint256, uint256){\\n        uint256 total_liquidity = _totalSupply;\\n        require(total_liquidity > 0);\\n        uint256 token_reserve = token.balanceOf(address(this));\\n        uint256 bnb_amount = amount.mul(address(this).balance) / total_liquidity;\\n        uint256 token_amount = amount.mul(token_reserve) / total_liquidity;\\n        return (bnb_amount, token_amount);\\n    }\\n\\n    function txs(address owner) public view returns (uint256) {\\n        return _txs[owner];\\n    }\\n\\n    /***********************************|\\n    |        Liquidity Functions        |\\n    |__________________________________*/\\n\\n    /**\\n     * @notice Deposit BNB && Tokens (token) at current ratio to mint SWAP tokens.\\n     * @dev min_liquidity does nothing when total SWAP supply is 0.\\n     * @param min_liquidity Minimum number of DROPS sender will mint if total DROP supply is greater than 0.\\n     * @param max_tokens Maximum number of tokens deposited. Deposits max amount if total DROP supply is 0.\\n     * @return The amount of SWAP minted.\\n     */\\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens) isNotPaused public payable returns (uint256) {\\n        require(max_tokens > 0 && msg.value > 0, 'Swap#addLiquidity: INVALID_ARGUMENT');\\n        uint256 total_liquidity = _totalSupply;\\n\\n        uint256 token_amount = 0;\\n\\n        if (_providers[msg.sender] == false){\\n            _providers[msg.sender] = true;\\n            providers += 1;\\n        }\\n\\n        if (total_liquidity > 0) {\\n            require(min_liquidity > 0);\\n            uint256 bnb_reserve = address(this).balance.sub(msg.value);\\n            uint256 token_reserve = token.balanceOf(address(this));\\n            token_amount = (msg.value.mul(token_reserve) / bnb_reserve).add(1);\\n            uint256 liquidity_minted = msg.value.mul(total_liquidity) / bnb_reserve;\\n\\n            require(max_tokens >= token_amount && liquidity_minted >= min_liquidity);\\n            _balances[msg.sender] = _balances[msg.sender].add(liquidity_minted);\\n            _totalSupply = total_liquidity.add(liquidity_minted);\\n            require(token.transferFrom(msg.sender, address(this), token_amount));\\n\\n            emit onAddLiquidity(msg.sender, msg.value, token_amount);\\n            emit onLiquidity(msg.sender, _balances[msg.sender]);\\n            emit Transfer(address(0), msg.sender, liquidity_minted);\\n            return liquidity_minted;\\n\\n        } else {\\n            require(msg.value >= 1e18, \\\"INVALID_VALUE\\\");\\n            token_amount = max_tokens;\\n            uint256 initial_liquidity = address(this).balance;\\n            _totalSupply = initial_liquidity;\\n            _balances[msg.sender] = initial_liquidity;\\n            require(token.transferFrom(msg.sender, address(this), token_amount));\\n\\n            emit onAddLiquidity(msg.sender, msg.value, token_amount);\\n            emit onLiquidity(msg.sender, _balances[msg.sender]);\\n            emit Transfer(address(0), msg.sender, initial_liquidity);\\n            return initial_liquidity;\\n        }\\n    }\\n\\n    /**\\n     * @dev Burn SWAP tokens to withdraw BNB && Tokens at current ratio.\\n     * @param amount Amount of SWAP burned.\\n     * @param min_bnb Minimum BNB withdrawn.\\n     * @param min_tokens Minimum Tokens withdrawn.\\n     * @return The amount of BNB && Tokens withdrawn.\\n     */\\n    function removeLiquidity(uint256 amount, uint256 min_bnb, uint256 min_tokens) onlyWhitelisted public returns (uint256, uint256) {\\n        require(amount > 0 && min_bnb > 0 && min_tokens > 0);\\n        uint256 total_liquidity = _totalSupply;\\n        require(total_liquidity > 0);\\n        uint256 token_reserve = token.balanceOf(address(this));\\n        uint256 bnb_amount = amount.mul(address(this).balance) / total_liquidity;\\n\\n        uint256 token_amount = amount.mul(token_reserve) / total_liquidity;\\n        require(bnb_amount >= min_bnb && token_amount >= min_tokens);\\n\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n        _totalSupply = total_liquidity.sub(amount);\\n        msg.sender.transfer(bnb_amount);\\n        require(token.transfer(msg.sender, token_amount));\\n        emit onRemoveLiquidity(msg.sender, bnb_amount, token_amount);\\n        emit onLiquidity(msg.sender, _balances[msg.sender]);\\n        emit Transfer(msg.sender, address(0), amount);\\n        return (bnb_amount, token_amount);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_addr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bnb_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"token_amount\",\"type\":\"uint256\"}],\"name\":\"onAddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"token_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bnb_amount\",\"type\":\"uint256\"}],\"name\":\"onBnbPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"onContractBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"onPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bnb_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"token_amount\",\"type\":\"uint256\"}],\"name\":\"onRemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"onSummary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bnb_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"token_amount\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max_tokens\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min_tokens\",\"type\":\"uint256\"}],\"name\":\"bnbToTokenSwapInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens_bought\",\"type\":\"uint256\"}],\"name\":\"bnbToTokenSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bnb_sold\",\"type\":\"uint256\"}],\"name\":\"getBnbToLiquidityInputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bnb_sold\",\"type\":\"uint256\"}],\"name\":\"getBnbToTokenInputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens_bought\",\"type\":\"uint256\"}],\"name\":\"getBnbToTokenOutputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"input_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"input_reserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"output_reserve\",\"type\":\"uint256\"}],\"name\":\"getInputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getLiquidityToReserveInputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"output_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"input_reserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"output_reserve\",\"type\":\"uint256\"}],\"name\":\"getOutputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens_sold\",\"type\":\"uint256\"}],\"name\":\"getTokenToBnbInputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bnb_bought\",\"type\":\"uint256\"}],\"name\":\"getTokenToBnbOutputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"providers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_bnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_tokens\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens_sold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_bnb\",\"type\":\"uint256\"}],\"name\":\"tokenToBnbSwapInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bnb_bought\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max_tokens\",\"type\":\"uint256\"}],\"name\":\"tokenToBnbSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTxs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"txs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Fountain", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000020f663cea80face82acdfa3aae6862d246ce0333", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}